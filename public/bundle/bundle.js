/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 42);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(43);
} else {
  module.exports = __webpack_require__(44);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function warning() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function warning(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.length < 10 || /^[s\W]*$/.test(format)) {
      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(55)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(56)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var bind = __webpack_require__(37);
var isBuffer = __webpack_require__(86);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;

  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;

  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(6);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.createLocation = undefined;

var _resolvePathname = __webpack_require__(30);

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(31);

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(8);
  var warning = __webpack_require__(12);
  var ReactPropTypesSecret = __webpack_require__(15);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _resolvePathname = __webpack_require__(30);

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(31);

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(9);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Router = __webpack_require__(19);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Router2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: '/',
      url: '/',
      params: {},
      isExact: pathname === '/'
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;

    (0, _invariant2.default)(children == null || _react2.default.Children.count(children) === 1, 'A <Router> may have only one child element');

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    (0, _warning2.default)(this.props.history === nextProps.history, 'You cannot change <Router history>');
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? _react2.default.Children.only(children) : null;
  };

  return Router;
}(_react2.default.Component);

Router.propTypes = {
  history: _propTypes2.default.object.isRequired,
  children: _propTypes2.default.node
};
Router.contextTypes = {
  router: _propTypes2.default.object
};
Router.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = Router;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pathToRegexp = __webpack_require__(64);

var _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compilePath = function compilePath(pattern, options) {
  var cacheKey = '' + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = (0, _pathToRegexp2.default)(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === 'string') options = { path: options };

  var _options = options,
      _options$path = _options.path,
      path = _options$path === undefined ? '/' : _options$path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;

  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

exports.default = matchPath;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(4);
var normalizeHeaderName = __webpack_require__(88);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(38);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(38);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {/* Ignore */}
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(6);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(47);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withRouter = exports.matchPath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.NavLink = exports.MemoryRouter = exports.Link = exports.HashRouter = exports.BrowserRouter = undefined;

var _BrowserRouter2 = __webpack_require__(54);

var _BrowserRouter3 = _interopRequireDefault(_BrowserRouter2);

var _HashRouter2 = __webpack_require__(58);

var _HashRouter3 = _interopRequireDefault(_HashRouter2);

var _Link2 = __webpack_require__(33);

var _Link3 = _interopRequireDefault(_Link2);

var _MemoryRouter2 = __webpack_require__(60);

var _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2);

var _NavLink2 = __webpack_require__(63);

var _NavLink3 = _interopRequireDefault(_NavLink2);

var _Prompt2 = __webpack_require__(66);

var _Prompt3 = _interopRequireDefault(_Prompt2);

var _Redirect2 = __webpack_require__(68);

var _Redirect3 = _interopRequireDefault(_Redirect2);

var _Route2 = __webpack_require__(34);

var _Route3 = _interopRequireDefault(_Route2);

var _Router2 = __webpack_require__(18);

var _Router3 = _interopRequireDefault(_Router2);

var _StaticRouter2 = __webpack_require__(74);

var _StaticRouter3 = _interopRequireDefault(_StaticRouter2);

var _Switch2 = __webpack_require__(76);

var _Switch3 = _interopRequireDefault(_Switch2);

var _matchPath2 = __webpack_require__(78);

var _matchPath3 = _interopRequireDefault(_matchPath2);

var _withRouter2 = __webpack_require__(79);

var _withRouter3 = _interopRequireDefault(_withRouter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.BrowserRouter = _BrowserRouter3.default;
exports.HashRouter = _HashRouter3.default;
exports.Link = _Link3.default;
exports.MemoryRouter = _MemoryRouter3.default;
exports.NavLink = _NavLink3.default;
exports.Prompt = _Prompt3.default;
exports.Redirect = _Redirect3.default;
exports.Route = _Route3.default;
exports.Router = _Router3.default;
exports.StaticRouter = _StaticRouter3.default;
exports.Switch = _Switch3.default;
exports.matchPath = _matchPath3.default;
exports.withRouter = _withRouter3.default;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

exports.default = resolvePathname;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

exports.default = valueEqual;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    _classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore right clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;

          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ['replace', 'to', 'innerRef']); // eslint-disable-line no-unused-vars

    (0, _invariant2.default)(this.context.router, 'You should not use <Link> outside a <Router>');

    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);

    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(_react2.default.Component);

Link.propTypes = {
  onClick: _propTypes2.default.func,
  target: _propTypes2.default.string,
  replace: _propTypes2.default.bool,
  to: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired,
  innerRef: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func])
};
Link.defaultProps = {
  replace: false
};
Link.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      push: _propTypes2.default.func.isRequired,
      replace: _propTypes2.default.func.isRequired,
      createHref: _propTypes2.default.func.isRequired
    }).isRequired
  }).isRequired
};

exports.default = Link;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Route = __webpack_require__(35);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Route2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _matchPath = __webpack_require__(20);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var isEmptyChildren = function isEmptyChildren(children) {
  return _react2.default.Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  _inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    _classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    (0, _invariant2.default)(router, 'You should not use <Route> or withRouter() outside a <Router>');

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return path ? (0, _matchPath2.default)(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');

    (0, _warning2.default)(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');

    (0, _warning2.default)(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    return component ? // component prop gets first priority, only called if there's a match
    match ? _react2.default.createElement(component, props) : null : render ? // render prop is next, only called if there's a match
    match ? render(props) : null : children ? // children come last, always called
    typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? _react2.default.Children.only(children) : null : null;
  };

  return Route;
}(_react2.default.Component);

Route.propTypes = {
  computedMatch: _propTypes2.default.object, // private, from <Switch>
  path: _propTypes2.default.string,
  exact: _propTypes2.default.bool,
  strict: _propTypes2.default.bool,
  sensitive: _propTypes2.default.bool,
  component: _propTypes2.default.func,
  render: _propTypes2.default.func,
  children: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]),
  location: _propTypes2.default.object
};
Route.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.object.isRequired,
    route: _propTypes2.default.object.isRequired,
    staticContext: _propTypes2.default.object
  })
};
Route.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = Route;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(4);
var settle = __webpack_require__(89);
var buildURL = __webpack_require__(91);
var parseHeaders = __webpack_require__(92);
var isURLSameOrigin = __webpack_require__(93);
var createError = __webpack_require__(39);
var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(94);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(95);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(90);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(45);

var _reactRouterDom = __webpack_require__(29);

var _routes = __webpack_require__(82);

var _routes2 = _interopRequireDefault(_routes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _reactDom.render)(_react2.default.createElement(
	_reactRouterDom.BrowserRouter,
	null,
	_routes2.default
), document.getElementById('app'));

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var m = __webpack_require__(7),
    n = __webpack_require__(11),
    p = __webpack_require__(6),
    q = "function" === typeof Symbol && Symbol["for"],
    r = q ? Symbol["for"]("react.element") : 60103,
    t = q ? Symbol["for"]("react.call") : 60104,
    u = q ? Symbol["for"]("react.return") : 60105,
    v = q ? Symbol["for"]("react.portal") : 60106,
    w = q ? Symbol["for"]("react.fragment") : 60107,
    x = "function" === typeof Symbol && Symbol.iterator;
function y(a) {
  for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, c = 0; c < b; c++) {
    e += "\x26args[]\x3d" + encodeURIComponent(arguments[c + 1]);
  }b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}
var z = { isMounted: function isMounted() {
    return !1;
  }, enqueueForceUpdate: function enqueueForceUpdate() {}, enqueueReplaceState: function enqueueReplaceState() {}, enqueueSetState: function enqueueSetState() {} };function A(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}A.prototype.isReactComponent = {};A.prototype.setState = function (a, b) {
  "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) && "function" !== typeof a && null != a ? y("85") : void 0;this.updater.enqueueSetState(this, a, b, "setState");
};A.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function B(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}function C() {}C.prototype = A.prototype;var D = B.prototype = new C();D.constructor = B;m(D, A.prototype);D.isPureReactComponent = !0;function E(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}var F = E.prototype = new C();F.constructor = E;m(F, A.prototype);F.unstable_isAsyncReactComponent = !0;F.render = function () {
  return this.props.children;
};var G = { current: null },
    H = Object.prototype.hasOwnProperty,
    I = { key: !0, ref: !0, __self: !0, __source: !0 };
function J(a, b, e) {
  var c,
      d = {},
      g = null,
      k = null;if (null != b) for (c in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), b) {
    H.call(b, c) && !I.hasOwnProperty(c) && (d[c] = b[c]);
  }var f = arguments.length - 2;if (1 === f) d.children = e;else if (1 < f) {
    for (var h = Array(f), l = 0; l < f; l++) {
      h[l] = arguments[l + 2];
    }d.children = h;
  }if (a && a.defaultProps) for (c in f = a.defaultProps, f) {
    void 0 === d[c] && (d[c] = f[c]);
  }return { $$typeof: r, type: a, key: g, ref: k, props: d, _owner: G.current };
}function K(a) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === r;
}
function escape(a) {
  var b = { "\x3d": "\x3d0", ":": "\x3d2" };return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}var L = /\/+/g,
    M = [];function N(a, b, e, c) {
  if (M.length) {
    var d = M.pop();d.result = a;d.keyPrefix = b;d.func = e;d.context = c;d.count = 0;return d;
  }return { result: a, keyPrefix: b, func: e, context: c, count: 0 };
}function O(a) {
  a.result = null;a.keyPrefix = null;a.func = null;a.context = null;a.count = 0;10 > M.length && M.push(a);
}
function P(a, b, e, c) {
  var d = typeof a === "undefined" ? "undefined" : _typeof(a);if ("undefined" === d || "boolean" === d) a = null;var g = !1;if (null === a) g = !0;else switch (d) {case "string":case "number":
      g = !0;break;case "object":
      switch (a.$$typeof) {case r:case t:case u:case v:
          g = !0;}}if (g) return e(c, a, "" === b ? "." + Q(a, 0) : b), 1;g = 0;b = "" === b ? "." : b + ":";if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
    d = a[k];var f = b + Q(d, k);g += P(d, f, e, c);
  } else if (null === a || "undefined" === typeof a ? f = null : (f = x && a[x] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), k = 0; !(d = a.next()).done;) {
    d = d.value, f = b + Q(d, k++), g += P(d, f, e, c);
  } else "object" === d && (e = "" + a, y("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));return g;
}function Q(a, b) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}function R(a, b) {
  a.func.call(a.context, b, a.count++);
}
function S(a, b, e) {
  var c = a.result,
      d = a.keyPrefix;a = a.func.call(a.context, b, a.count++);Array.isArray(a) ? T(a, c, e, p.thatReturnsArgument) : null != a && (K(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(L, "$\x26/") + "/") + e, a = { $$typeof: r, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner }), c.push(a));
}function T(a, b, e, c, d) {
  var g = "";null != e && (g = ("" + e).replace(L, "$\x26/") + "/");b = N(b, g, c, d);null == a || P(a, "", S, b);O(b);
}
var U = { Children: { map: function map(a, b, e) {
      if (null == a) return a;var c = [];T(a, c, null, b, e);return c;
    }, forEach: function forEach(a, b, e) {
      if (null == a) return a;b = N(null, null, b, e);null == a || P(a, "", R, b);O(b);
    }, count: function count(a) {
      return null == a ? 0 : P(a, "", p.thatReturnsNull, null);
    }, toArray: function toArray(a) {
      var b = [];T(a, b, null, p.thatReturnsArgument);return b;
    }, only: function only(a) {
      K(a) ? void 0 : y("143");return a;
    } }, Component: A, PureComponent: B, unstable_AsyncComponent: E, Fragment: w, createElement: J, cloneElement: function cloneElement(a, b, e) {
    var c = m({}, a.props),
        d = a.key,
        g = a.ref,
        k = a._owner;if (null != b) {
      void 0 !== b.ref && (g = b.ref, k = G.current);void 0 !== b.key && (d = "" + b.key);if (a.type && a.type.defaultProps) var f = a.type.defaultProps;for (h in b) {
        H.call(b, h) && !I.hasOwnProperty(h) && (c[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
      }
    }var h = arguments.length - 2;if (1 === h) c.children = e;else if (1 < h) {
      f = Array(h);for (var l = 0; l < h; l++) {
        f[l] = arguments[l + 2];
      }c.children = f;
    }return { $$typeof: r, type: a.type, key: d, ref: g, props: c, _owner: k };
  }, createFactory: function createFactory(a) {
    var b = J.bind(null, a);b.type = a;return b;
  },
  isValidElement: K, version: "16.2.0", __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: G, assign: m } },
    V = Object.freeze({ default: U }),
    W = V && U || V;module.exports = W["default"] ? W["default"] : W;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__(7);
    var emptyObject = __webpack_require__(11);
    var invariant = __webpack_require__(8);
    var warning = __webpack_require__(12);
    var emptyFunction = __webpack_require__(6);
    var checkPropTypes = __webpack_require__(14);

    // TODO: this is special because it gets imported during build.

    var ReactVersion = '16.2.0';

    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
    var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
    var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable === 'undefined') {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }
      return null;
    }

    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var constructor = publicInstance.constructor;
        var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }
        warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }

    /**
     * This is the abstract API for an update queue.
     */
    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };

    /**
     * Base class helpers for the updating state of a component.
     */
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};

    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */
    Component.prototype.setState = function (partialState, callback) {
      !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };

    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */
    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    /**
     * Base class helpers for the updating state of a component.
     */
    function PureComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;

    function AsyncComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
    asyncComponentPrototype.constructor = AsyncComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(asyncComponentPrototype, Component.prototype);
    asyncComponentPrototype.unstable_isAsyncReactComponent = true;
    asyncComponentPrototype.render = function () {
      return this.props.children;
    };

    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };

    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */
    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allow us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,

        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,

        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {};

        // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };

    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */
    function createElement(type, config, children) {
      var propName;

      // Reserved names are extracted
      var props = {};

      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        // Remaining properties are added to a new props object
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }

      // Resolve default props
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

      return newElement;
    }

    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */
    function cloneElement(element, config, children) {
      var propName;

      // Original props are copied
      var props = _assign({}, element.props);

      // Reserved names are extracted
      var key = element.key;
      var ref = element.ref;
      // Self is preserved since the owner is preserved.
      var self = element._self;
      // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.
      var source = element._source;

      // Owner will be preserved, unless ref is overridden
      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        // Remaining properties override existing props
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }

    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a valid component.
     * @final
     */
    function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var ReactDebugCurrentFrame = {};

    {
      // Component that is being worked on
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) {
          return impl();
        }
        return null;
      };
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';

    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });

      return '$' + escapedString;
    }

    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */

    var didWarnAboutMaps = false;

    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];
    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;
      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }

    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;
          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_CALL_TYPE:
              case REACT_RETURN_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }
        }
      }

      if (invokeCallback) {
        callback(traverseContext, children,
        // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
              didWarnAboutMaps = true;
            }
          }

          var iterator = iteratorFn.call(children);
          var step;
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }

    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }

    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */
    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      }
      // Implicit key determined by the index in the set
      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;

      func.call(context, child, bookKeeping.count++);
    }

    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.foreach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;

      var mappedChild = func.call(context, child, bookKeeping.count++);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild,
          // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }
        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }
      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.map
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }

    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.count
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */
    function countChildren(children, context) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }

    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.toarray
     */
    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
      return result;
    }

    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.only
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */
    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }
      if (typeof type === 'function') {
        return type.displayName || type.name;
      }
      return null;
    }

    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */

    {
      var currentlyValidatingElement = null;

      var propTypesMisspellWarningShown = false;

      var getDisplayName = function getDisplayName(element) {
        if (element == null) {
          return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
          return '#text';
        } else if (typeof element.type === 'string') {
          return element.type;
        } else if (element.type === REACT_FRAGMENT_TYPE) {
          return 'React.Fragment';
        } else {
          return element.type.displayName || element.type.name || 'Unknown';
        }
      };

      var getStackAddendum = function getStackAddendum() {
        var stack = '';
        if (currentlyValidatingElement) {
          var name = getDisplayName(currentlyValidatingElement);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
        }
        stack += ReactDebugCurrentFrame.getStackAddendum() || '';
        return stack;
      };

      var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current);
        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }
      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }
      return '';
    }

    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */
    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }

    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;

      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

      // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
      }

      currentlyValidatingElement = element;
      {
        warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
      }
      currentlyValidatingElement = null;
    }

    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */
    function validateChildKeys(node, parentType) {
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }

    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      var propTypes = componentClass.propTypes;
      if (propTypes) {
        currentlyValidatingElement = element;
        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
        currentlyValidatingElement = null;
      } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true;
        warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }

    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */
    function validateFragmentProps(fragment) {
      currentlyValidatingElement = fragment;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!VALID_FRAGMENT_PROPS.has(key)) {
            warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (fragment.ref !== null) {
        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
      }

      currentlyValidatingElement = null;
    }

    function createElementWithValidation(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || typeof type === 'number';
      // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.
      if (!validType) {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += getStackAddendum() || '';

        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info);
      }

      var element = createElement.apply(this, arguments);

      // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.
      if (element == null) {
        return element;
      }

      // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' && type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      // Legacy hook TODO: Warn if this is accessed
      validatedFactory.type = type;

      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }

      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },

      Component: Component,
      PureComponent: PureComponent,
      unstable_AsyncComponent: AsyncComponent,

      Fragment: REACT_FRAGMENT_TYPE,

      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,

      version: ReactVersion,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentOwner: ReactCurrentOwner,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      }
    };

    {
      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }

    var React$2 = Object.freeze({
      default: React
    });

    var React$3 = React$2 && React || React$2;

    // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.
    var react = React$3['default'] ? React$3['default'] : React$3;

    module.exports = react;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(46);
} else {
  module.exports = __webpack_require__(49);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var aa = __webpack_require__(0),
    l = __webpack_require__(23),
    B = __webpack_require__(7),
    C = __webpack_require__(6),
    ba = __webpack_require__(24),
    da = __webpack_require__(25),
    ea = __webpack_require__(26),
    fa = __webpack_require__(27),
    ia = __webpack_require__(28),
    D = __webpack_require__(11);
function E(a) {
  for (var b = arguments.length - 1, c = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) {
    c += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);
  }b = Error(c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}aa ? void 0 : E("227");
var oa = { children: !0, dangerouslySetInnerHTML: !0, defaultValue: !0, defaultChecked: !0, innerHTML: !0, suppressContentEditableWarning: !0, suppressHydrationWarning: !0, style: !0 };function pa(a, b) {
  return (a & b) === b;
}
var ta = { MUST_USE_PROPERTY: 1, HAS_BOOLEAN_VALUE: 4, HAS_NUMERIC_VALUE: 8, HAS_POSITIVE_NUMERIC_VALUE: 24, HAS_OVERLOADED_BOOLEAN_VALUE: 32, HAS_STRING_BOOLEAN_VALUE: 64, injectDOMPropertyConfig: function injectDOMPropertyConfig(a) {
    var b = ta,
        c = a.Properties || {},
        d = a.DOMAttributeNamespaces || {},
        e = a.DOMAttributeNames || {};a = a.DOMMutationMethods || {};for (var f in c) {
      ua.hasOwnProperty(f) ? E("48", f) : void 0;var g = f.toLowerCase(),
          h = c[f];g = { attributeName: g, attributeNamespace: null, propertyName: f, mutationMethod: null, mustUseProperty: pa(h, b.MUST_USE_PROPERTY),
        hasBooleanValue: pa(h, b.HAS_BOOLEAN_VALUE), hasNumericValue: pa(h, b.HAS_NUMERIC_VALUE), hasPositiveNumericValue: pa(h, b.HAS_POSITIVE_NUMERIC_VALUE), hasOverloadedBooleanValue: pa(h, b.HAS_OVERLOADED_BOOLEAN_VALUE), hasStringBooleanValue: pa(h, b.HAS_STRING_BOOLEAN_VALUE) };1 >= g.hasBooleanValue + g.hasNumericValue + g.hasOverloadedBooleanValue ? void 0 : E("50", f);e.hasOwnProperty(f) && (g.attributeName = e[f]);d.hasOwnProperty(f) && (g.attributeNamespace = d[f]);a.hasOwnProperty(f) && (g.mutationMethod = a[f]);ua[f] = g;
    }
  } },
    ua = {};
function va(a, b) {
  if (oa.hasOwnProperty(a) || 2 < a.length && ("o" === a[0] || "O" === a[0]) && ("n" === a[1] || "N" === a[1])) return !1;if (null === b) return !0;switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case "boolean":
      return oa.hasOwnProperty(a) ? a = !0 : (b = wa(a)) ? a = b.hasBooleanValue || b.hasStringBooleanValue || b.hasOverloadedBooleanValue : (a = a.toLowerCase().slice(0, 5), a = "data-" === a || "aria-" === a), a;case "undefined":case "number":case "string":case "object":
      return !0;default:
      return !1;}
}function wa(a) {
  return ua.hasOwnProperty(a) ? ua[a] : null;
}
var xa = ta,
    ya = xa.MUST_USE_PROPERTY,
    K = xa.HAS_BOOLEAN_VALUE,
    za = xa.HAS_NUMERIC_VALUE,
    Aa = xa.HAS_POSITIVE_NUMERIC_VALUE,
    Ba = xa.HAS_OVERLOADED_BOOLEAN_VALUE,
    Ca = xa.HAS_STRING_BOOLEAN_VALUE,
    Da = { Properties: { allowFullScreen: K, async: K, autoFocus: K, autoPlay: K, capture: Ba, checked: ya | K, cols: Aa, contentEditable: Ca, controls: K, "default": K, defer: K, disabled: K, download: Ba, draggable: Ca, formNoValidate: K, hidden: K, loop: K, multiple: ya | K, muted: ya | K, noValidate: K, open: K, playsInline: K, readOnly: K, required: K, reversed: K, rows: Aa, rowSpan: za,
    scoped: K, seamless: K, selected: ya | K, size: Aa, start: za, span: Aa, spellCheck: Ca, style: 0, tabIndex: 0, itemScope: K, acceptCharset: 0, className: 0, htmlFor: 0, httpEquiv: 0, value: Ca }, DOMAttributeNames: { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, DOMMutationMethods: { value: function value(a, b) {
      if (null == b) return a.removeAttribute("value");"number" !== a.type || !1 === a.hasAttribute("value") ? a.setAttribute("value", "" + b) : a.validity && !a.validity.badInput && a.ownerDocument.activeElement !== a && a.setAttribute("value", "" + b);
    } } },
    Ea = xa.HAS_STRING_BOOLEAN_VALUE,
    M = { xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace" },
    Ga = { Properties: { autoReverse: Ea, externalResourcesRequired: Ea, preserveAlpha: Ea }, DOMAttributeNames: { autoReverse: "autoReverse", externalResourcesRequired: "externalResourcesRequired", preserveAlpha: "preserveAlpha" }, DOMAttributeNamespaces: { xlinkActuate: M.xlink, xlinkArcrole: M.xlink, xlinkHref: M.xlink, xlinkRole: M.xlink, xlinkShow: M.xlink, xlinkTitle: M.xlink, xlinkType: M.xlink,
    xmlBase: M.xml, xmlLang: M.xml, xmlSpace: M.xml } },
    Ha = /[\-\:]([a-z])/g;function Ia(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function (a) {
  var b = a.replace(Ha, Ia);Ga.Properties[b] = 0;Ga.DOMAttributeNames[b] = a;
});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
var P = { _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, injection: { injectErrorUtils: function injectErrorUtils(a) {
      "function" !== typeof a.invokeGuardedCallback ? E("197") : void 0;Ja = a.invokeGuardedCallback;
    } }, invokeGuardedCallback: function invokeGuardedCallback(a, b, c, d, e, f, g, h, k) {
    Ja.apply(P, arguments);
  }, invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(a, b, c, d, e, f, g, h, k) {
    P.invokeGuardedCallback.apply(this, arguments);if (P.hasCaughtError()) {
      var q = P.clearCaughtError();P._hasRethrowError || (P._hasRethrowError = !0, P._rethrowError = q);
    }
  }, rethrowCaughtError: function rethrowCaughtError() {
    return Ka.apply(P, arguments);
  }, hasCaughtError: function hasCaughtError() {
    return P._hasCaughtError;
  }, clearCaughtError: function clearCaughtError() {
    if (P._hasCaughtError) {
      var a = P._caughtError;P._caughtError = null;P._hasCaughtError = !1;return a;
    }E("198");
  } };function Ja(a, b, c, d, e, f, g, h, k) {
  P._hasCaughtError = !1;P._caughtError = null;var q = Array.prototype.slice.call(arguments, 3);try {
    b.apply(c, q);
  } catch (v) {
    P._caughtError = v, P._hasCaughtError = !0;
  }
}
function Ka() {
  if (P._hasRethrowError) {
    var a = P._rethrowError;P._rethrowError = null;P._hasRethrowError = !1;throw a;
  }
}var La = null,
    Ma = {};
function Na() {
  if (La) for (var a in Ma) {
    var b = Ma[a],
        c = La.indexOf(a);-1 < c ? void 0 : E("96", a);if (!Oa[c]) {
      b.extractEvents ? void 0 : E("97", a);Oa[c] = b;c = b.eventTypes;for (var d in c) {
        var e = void 0;var f = c[d],
            g = b,
            h = d;Pa.hasOwnProperty(h) ? E("99", h) : void 0;Pa[h] = f;var k = f.phasedRegistrationNames;if (k) {
          for (e in k) {
            k.hasOwnProperty(e) && Qa(k[e], g, h);
          }e = !0;
        } else f.registrationName ? (Qa(f.registrationName, g, h), e = !0) : e = !1;e ? void 0 : E("98", d, a);
      }
    }
  }
}
function Qa(a, b, c) {
  Ra[a] ? E("100", a) : void 0;Ra[a] = b;Sa[a] = b.eventTypes[c].dependencies;
}var Oa = [],
    Pa = {},
    Ra = {},
    Sa = {};function Ta(a) {
  La ? E("101") : void 0;La = Array.prototype.slice.call(a);Na();
}function Ua(a) {
  var b = !1,
      c;for (c in a) {
    if (a.hasOwnProperty(c)) {
      var d = a[c];Ma.hasOwnProperty(c) && Ma[c] === d || (Ma[c] ? E("102", c) : void 0, Ma[c] = d, b = !0);
    }
  }b && Na();
}
var Va = Object.freeze({ plugins: Oa, eventNameDispatchConfigs: Pa, registrationNameModules: Ra, registrationNameDependencies: Sa, possibleRegistrationNames: null, injectEventPluginOrder: Ta, injectEventPluginsByName: Ua }),
    Wa = null,
    Xa = null,
    Ya = null;function Za(a, b, c, d) {
  b = a.type || "unknown-event";a.currentTarget = Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);a.currentTarget = null;
}
function $a(a, b) {
  null == b ? E("30") : void 0;if (null == a) return b;if (Array.isArray(a)) {
    if (Array.isArray(b)) return a.push.apply(a, b), a;a.push(b);return a;
  }return Array.isArray(b) ? [a].concat(b) : [a, b];
}function ab(a, b, c) {
  Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
}var bb = null;
function cb(a, b) {
  if (a) {
    var c = a._dispatchListeners,
        d = a._dispatchInstances;if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) {
      Za(a, b, c[e], d[e]);
    } else c && Za(a, b, c, d);a._dispatchListeners = null;a._dispatchInstances = null;a.isPersistent() || a.constructor.release(a);
  }
}function db(a) {
  return cb(a, !0);
}function gb(a) {
  return cb(a, !1);
}var hb = { injectEventPluginOrder: Ta, injectEventPluginsByName: Ua };
function ib(a, b) {
  var c = a.stateNode;if (!c) return null;var d = Wa(c);if (!d) return null;c = d[b];a: switch (b) {case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));a = !d;break a;default:
      a = !1;}if (a) return null;c && "function" !== typeof c ? E("231", b, typeof c === "undefined" ? "undefined" : _typeof(c)) : void 0;
  return c;
}function jb(a, b, c, d) {
  for (var e, f = 0; f < Oa.length; f++) {
    var g = Oa[f];g && (g = g.extractEvents(a, b, c, d)) && (e = $a(e, g));
  }return e;
}function kb(a) {
  a && (bb = $a(bb, a));
}function lb(a) {
  var b = bb;bb = null;b && (a ? ab(b, db) : ab(b, gb), bb ? E("95") : void 0, P.rethrowCaughtError());
}var mb = Object.freeze({ injection: hb, getListener: ib, extractEvents: jb, enqueueEvents: kb, processEventQueue: lb }),
    nb = Math.random().toString(36).slice(2),
    Q = "__reactInternalInstance$" + nb,
    ob = "__reactEventHandlers$" + nb;
function pb(a) {
  if (a[Q]) return a[Q];for (var b = []; !a[Q];) {
    if (b.push(a), a.parentNode) a = a.parentNode;else return null;
  }var c = void 0,
      d = a[Q];if (5 === d.tag || 6 === d.tag) return d;for (; a && (d = a[Q]); a = b.pop()) {
    c = d;
  }return c;
}function qb(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;E("33");
}function rb(a) {
  return a[ob] || null;
}
var sb = Object.freeze({ precacheFiberNode: function precacheFiberNode(a, b) {
    b[Q] = a;
  }, getClosestInstanceFromNode: pb, getInstanceFromNode: function getInstanceFromNode(a) {
    a = a[Q];return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
  }, getNodeFromInstance: qb, getFiberCurrentPropsFromNode: rb, updateFiberProps: function updateFiberProps(a, b) {
    a[ob] = b;
  } });function tb(a) {
  do {
    a = a["return"];
  } while (a && 5 !== a.tag);return a ? a : null;
}function ub(a, b, c) {
  for (var d = []; a;) {
    d.push(a), a = tb(a);
  }for (a = d.length; 0 < a--;) {
    b(d[a], "captured", c);
  }for (a = 0; a < d.length; a++) {
    b(d[a], "bubbled", c);
  }
}
function vb(a, b, c) {
  if (b = ib(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = $a(c._dispatchListeners, b), c._dispatchInstances = $a(c._dispatchInstances, a);
}function wb(a) {
  a && a.dispatchConfig.phasedRegistrationNames && ub(a._targetInst, vb, a);
}function xb(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    var b = a._targetInst;b = b ? tb(b) : null;ub(b, vb, a);
  }
}
function yb(a, b, c) {
  a && c && c.dispatchConfig.registrationName && (b = ib(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = $a(c._dispatchListeners, b), c._dispatchInstances = $a(c._dispatchInstances, a));
}function zb(a) {
  a && a.dispatchConfig.registrationName && yb(a._targetInst, null, a);
}function Ab(a) {
  ab(a, wb);
}
function Bb(a, b, c, d) {
  if (c && d) a: {
    var e = c;for (var f = d, g = 0, h = e; h; h = tb(h)) {
      g++;
    }h = 0;for (var k = f; k; k = tb(k)) {
      h++;
    }for (; 0 < g - h;) {
      e = tb(e), g--;
    }for (; 0 < h - g;) {
      f = tb(f), h--;
    }for (; g--;) {
      if (e === f || e === f.alternate) break a;e = tb(e);f = tb(f);
    }e = null;
  } else e = null;f = e;for (e = []; c && c !== f;) {
    g = c.alternate;if (null !== g && g === f) break;e.push(c);c = tb(c);
  }for (c = []; d && d !== f;) {
    g = d.alternate;if (null !== g && g === f) break;c.push(d);d = tb(d);
  }for (d = 0; d < e.length; d++) {
    yb(e[d], "bubbled", a);
  }for (a = c.length; 0 < a--;) {
    yb(c[a], "captured", b);
  }
}
var Cb = Object.freeze({ accumulateTwoPhaseDispatches: Ab, accumulateTwoPhaseDispatchesSkipTarget: function accumulateTwoPhaseDispatchesSkipTarget(a) {
    ab(a, xb);
  }, accumulateEnterLeaveDispatches: Bb, accumulateDirectDispatches: function accumulateDirectDispatches(a) {
    ab(a, zb);
  } }),
    Db = null;function Eb() {
  !Db && l.canUseDOM && (Db = "textContent" in document.documentElement ? "textContent" : "innerText");return Db;
}var S = { _root: null, _startText: null, _fallbackText: null };
function Fb() {
  if (S._fallbackText) return S._fallbackText;var a,
      b = S._startText,
      c = b.length,
      d,
      e = Gb(),
      f = e.length;for (a = 0; a < c && b[a] === e[a]; a++) {}var g = c - a;for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {}S._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);return S._fallbackText;
}function Gb() {
  return "value" in S._root ? S._root.value : S._root[Eb()];
}
var Hb = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
    Ib = { type: null, target: null, currentTarget: C.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: null, isTrusted: null };
function T(a, b, c, d) {
  this.dispatchConfig = a;this._targetInst = b;this.nativeEvent = c;a = this.constructor.Interface;for (var e in a) {
    a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
  }this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? C.thatReturnsTrue : C.thatReturnsFalse;this.isPropagationStopped = C.thatReturnsFalse;return this;
}
B(T.prototype, { preventDefault: function preventDefault() {
    this.defaultPrevented = !0;var a = this.nativeEvent;a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = C.thatReturnsTrue);
  }, stopPropagation: function stopPropagation() {
    var a = this.nativeEvent;a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = C.thatReturnsTrue);
  }, persist: function persist() {
    this.isPersistent = C.thatReturnsTrue;
  }, isPersistent: C.thatReturnsFalse,
  destructor: function destructor() {
    var a = this.constructor.Interface,
        b;for (b in a) {
      this[b] = null;
    }for (a = 0; a < Hb.length; a++) {
      this[Hb[a]] = null;
    }
  } });T.Interface = Ib;T.augmentClass = function (a, b) {
  function c() {}c.prototype = this.prototype;var d = new c();B(d, a.prototype);a.prototype = d;a.prototype.constructor = a;a.Interface = B({}, this.Interface, b);a.augmentClass = this.augmentClass;Jb(a);
};Jb(T);function Kb(a, b, c, d) {
  if (this.eventPool.length) {
    var e = this.eventPool.pop();this.call(e, a, b, c, d);return e;
  }return new this(a, b, c, d);
}
function Lb(a) {
  a instanceof this ? void 0 : E("223");a.destructor();10 > this.eventPool.length && this.eventPool.push(a);
}function Jb(a) {
  a.eventPool = [];a.getPooled = Kb;a.release = Lb;
}function Mb(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Mb, { data: null });function Nb(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Nb, { data: null });var Pb = [9, 13, 27, 32],
    Vb = l.canUseDOM && "CompositionEvent" in window,
    Wb = null;l.canUseDOM && "documentMode" in document && (Wb = document.documentMode);var Xb;
if (Xb = l.canUseDOM && "TextEvent" in window && !Wb) {
  var Yb = window.opera;Xb = !("object" === (typeof Yb === "undefined" ? "undefined" : _typeof(Yb)) && "function" === typeof Yb.version && 12 >= parseInt(Yb.version(), 10));
}
var Zb = Xb,
    $b = l.canUseDOM && (!Vb || Wb && 8 < Wb && 11 >= Wb),
    ac = String.fromCharCode(32),
    bc = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["topCompositionEnd", "topKeyPress", "topTextInput", "topPaste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionStart: { phasedRegistrationNames: { bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture" }, dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") } },
    cc = !1;
function dc(a, b) {
  switch (a) {case "topKeyUp":
      return -1 !== Pb.indexOf(b.keyCode);case "topKeyDown":
      return 229 !== b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":
      return !0;default:
      return !1;}
}function ec(a) {
  a = a.detail;return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "data" in a ? a.data : null;
}var fc = !1;function gc(a, b) {
  switch (a) {case "topCompositionEnd":
      return ec(b);case "topKeyPress":
      if (32 !== b.which) return null;cc = !0;return ac;case "topTextInput":
      return a = b.data, a === ac && cc ? null : a;default:
      return null;}
}
function hc(a, b) {
  if (fc) return "topCompositionEnd" === a || !Vb && dc(a, b) ? (a = Fb(), S._root = null, S._startText = null, S._fallbackText = null, fc = !1, a) : null;switch (a) {case "topPaste":
      return null;case "topKeyPress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;if (b.which) return String.fromCharCode(b.which);
      }return null;case "topCompositionEnd":
      return $b ? null : b.data;default:
      return null;}
}
var ic = { eventTypes: bc, extractEvents: function extractEvents(a, b, c, d) {
    var e;if (Vb) b: {
      switch (a) {case "topCompositionStart":
          var f = bc.compositionStart;break b;case "topCompositionEnd":
          f = bc.compositionEnd;break b;case "topCompositionUpdate":
          f = bc.compositionUpdate;break b;}f = void 0;
    } else fc ? dc(a, c) && (f = bc.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (f = bc.compositionStart);f ? ($b && (fc || f !== bc.compositionStart ? f === bc.compositionEnd && fc && (e = Fb()) : (S._root = d, S._startText = Gb(), fc = !0)), f = Mb.getPooled(f, b, c, d), e ? f.data = e : (e = ec(c), null !== e && (f.data = e)), Ab(f), e = f) : e = null;(a = Zb ? gc(a, c) : hc(a, c)) ? (b = Nb.getPooled(bc.beforeInput, b, c, d), b.data = a, Ab(b)) : b = null;return [e, b];
  } },
    jc = null,
    kc = null,
    lc = null;function mc(a) {
  if (a = Xa(a)) {
    jc && "function" === typeof jc.restoreControlledState ? void 0 : E("194");var b = Wa(a.stateNode);jc.restoreControlledState(a.stateNode, a.type, b);
  }
}var nc = { injectFiberControlledHostComponent: function injectFiberControlledHostComponent(a) {
    jc = a;
  } };function oc(a) {
  kc ? lc ? lc.push(a) : lc = [a] : kc = a;
}
function pc() {
  if (kc) {
    var a = kc,
        b = lc;lc = kc = null;mc(a);if (b) for (a = 0; a < b.length; a++) {
      mc(b[a]);
    }
  }
}var qc = Object.freeze({ injection: nc, enqueueStateRestore: oc, restoreStateIfNeeded: pc });function rc(a, b) {
  return a(b);
}var sc = !1;function tc(a, b) {
  if (sc) return rc(a, b);sc = !0;try {
    return rc(a, b);
  } finally {
    sc = !1, pc();
  }
}var uc = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function vc(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return "input" === b ? !!uc[a.type] : "textarea" === b ? !0 : !1;
}function wc(a) {
  a = a.target || a.srcElement || window;a.correspondingUseElement && (a = a.correspondingUseElement);return 3 === a.nodeType ? a.parentNode : a;
}var xc;l.canUseDOM && (xc = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
function yc(a, b) {
  if (!l.canUseDOM || b && !("addEventListener" in document)) return !1;b = "on" + a;var c = b in document;c || (c = document.createElement("div"), c.setAttribute(b, "return;"), c = "function" === typeof c[b]);!c && xc && "wheel" === a && (c = document.implementation.hasFeature("Events.wheel", "3.0"));return c;
}function zc(a) {
  var b = a.type;return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ac(a) {
  var b = zc(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, { enumerable: c.enumerable, configurable: !0, get: function get() {
      return c.get.call(this);
    }, set: function set(a) {
      d = "" + a;c.set.call(this, a);
    } }), { getValue: function getValue() {
      return d;
    }, setValue: function setValue(a) {
      d = "" + a;
    }, stopTracking: function stopTracking() {
      a._valueTracker = null;delete a[b];
    } };
}
function Bc(a) {
  a._valueTracker || (a._valueTracker = Ac(a));
}function Cc(a) {
  if (!a) return !1;var b = a._valueTracker;if (!b) return !0;var c = b.getValue();var d = "";a && (d = zc(a) ? a.checked ? "true" : "false" : a.value);a = d;return a !== c ? (b.setValue(a), !0) : !1;
}var Dc = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ") } };
function Ec(a, b, c) {
  a = T.getPooled(Dc.change, a, b, c);a.type = "change";oc(c);Ab(a);return a;
}var Fc = null,
    Gc = null;function Hc(a) {
  kb(a);lb(!1);
}function Ic(a) {
  var b = qb(a);if (Cc(b)) return a;
}function Jc(a, b) {
  if ("topChange" === a) return b;
}var Kc = !1;l.canUseDOM && (Kc = yc("input") && (!document.documentMode || 9 < document.documentMode));function Lc() {
  Fc && (Fc.detachEvent("onpropertychange", Mc), Gc = Fc = null);
}function Mc(a) {
  "value" === a.propertyName && Ic(Gc) && (a = Ec(Gc, a, wc(a)), tc(Hc, a));
}
function Nc(a, b, c) {
  "topFocus" === a ? (Lc(), Fc = b, Gc = c, Fc.attachEvent("onpropertychange", Mc)) : "topBlur" === a && Lc();
}function Oc(a) {
  if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return Ic(Gc);
}function Pc(a, b) {
  if ("topClick" === a) return Ic(b);
}function $c(a, b) {
  if ("topInput" === a || "topChange" === a) return Ic(b);
}
var ad = { eventTypes: Dc, _isInputEventSupported: Kc, extractEvents: function extractEvents(a, b, c, d) {
    var e = b ? qb(b) : window,
        f = e.nodeName && e.nodeName.toLowerCase();if ("select" === f || "input" === f && "file" === e.type) var g = Jc;else if (vc(e)) {
      if (Kc) g = $c;else {
        g = Oc;var h = Nc;
      }
    } else f = e.nodeName, !f || "input" !== f.toLowerCase() || "checkbox" !== e.type && "radio" !== e.type || (g = Pc);if (g && (g = g(a, b))) return Ec(g, c, d);h && h(a, e, b);"topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && (a = "" + e.value, e.getAttribute("value") !== a && e.setAttribute("value", a));
  } };function bd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(bd, { view: null, detail: null });var cd = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };function dd(a) {
  var b = this.nativeEvent;return b.getModifierState ? b.getModifierState(a) : (a = cd[a]) ? !!b[a] : !1;
}function ed() {
  return dd;
}function fd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}
bd.augmentClass(fd, { screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: ed, button: null, buttons: null, relatedTarget: function relatedTarget(a) {
    return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
  } });
var gd = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["topMouseOut", "topMouseOver"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["topMouseOut", "topMouseOver"] } },
    hd = { eventTypes: gd, extractEvents: function extractEvents(a, b, c, d) {
    if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;"topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? pb(b) : null) : a = null;if (a === b) return null;var f = null == a ? e : qb(a);e = null == b ? e : qb(b);var g = fd.getPooled(gd.mouseLeave, a, c, d);g.type = "mouseleave";g.target = f;g.relatedTarget = e;c = fd.getPooled(gd.mouseEnter, b, c, d);c.type = "mouseenter";c.target = e;c.relatedTarget = f;Bb(g, c, a, b);return [g, c];
  } },
    id = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a) {
  a = a.type;return "string" === typeof a ? a : "function" === typeof a ? a.displayName || a.name : null;
}
function kd(a) {
  var b = a;if (a.alternate) for (; b["return"];) {
    b = b["return"];
  } else {
    if (0 !== (b.effectTag & 2)) return 1;for (; b["return"];) {
      if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
    }
  }return 3 === b.tag ? 2 : 3;
}function ld(a) {
  return (a = a._reactInternalFiber) ? 2 === kd(a) : !1;
}function md(a) {
  2 !== kd(a) ? E("188") : void 0;
}
function nd(a) {
  var b = a.alternate;if (!b) return b = kd(a), 3 === b ? E("188") : void 0, 1 === b ? null : a;for (var c = a, d = b;;) {
    var e = c["return"],
        f = e ? e.alternate : null;if (!e || !f) break;if (e.child === f.child) {
      for (var g = e.child; g;) {
        if (g === c) return md(e), a;if (g === d) return md(e), b;g = g.sibling;
      }E("188");
    }if (c["return"] !== d["return"]) c = e, d = f;else {
      g = !1;for (var h = e.child; h;) {
        if (h === c) {
          g = !0;c = e;d = f;break;
        }if (h === d) {
          g = !0;d = e;c = f;break;
        }h = h.sibling;
      }if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;c = f;d = e;break;
          }if (h === d) {
            g = !0;d = f;c = e;break;
          }h = h.sibling;
        }g ? void 0 : E("189");
      }
    }c.alternate !== d ? E("190") : void 0;
  }3 !== c.tag ? E("188") : void 0;return c.stateNode.current === c ? a : b;
}function od(a) {
  a = nd(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}
function pd(a) {
  a = nd(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}var qd = [];
function rd(a) {
  var b = a.targetInst;do {
    if (!b) {
      a.ancestors.push(b);break;
    }var c;for (c = b; c["return"];) {
      c = c["return"];
    }c = 3 !== c.tag ? null : c.stateNode.containerInfo;if (!c) break;a.ancestors.push(b);b = pb(c);
  } while (b);for (c = 0; c < a.ancestors.length; c++) {
    b = a.ancestors[c], sd(a.topLevelType, b, a.nativeEvent, wc(a.nativeEvent));
  }
}var td = !0,
    sd = void 0;function ud(a) {
  td = !!a;
}function U(a, b, c) {
  return c ? ba.listen(c, b, vd.bind(null, a)) : null;
}function wd(a, b, c) {
  return c ? ba.capture(c, b, vd.bind(null, a)) : null;
}
function vd(a, b) {
  if (td) {
    var c = wc(b);c = pb(c);null === c || "number" !== typeof c.tag || 2 === kd(c) || (c = null);if (qd.length) {
      var d = qd.pop();d.topLevelType = a;d.nativeEvent = b;d.targetInst = c;a = d;
    } else a = { topLevelType: a, nativeEvent: b, targetInst: c, ancestors: [] };try {
      tc(rd, a);
    } finally {
      a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > qd.length && qd.push(a);
    }
  }
}
var xd = Object.freeze({ get _enabled() {
    return td;
  }, get _handleTopLevel() {
    return sd;
  }, setHandleTopLevel: function setHandleTopLevel(a) {
    sd = a;
  }, setEnabled: ud, isEnabled: function isEnabled() {
    return td;
  }, trapBubbledEvent: U, trapCapturedEvent: wd, dispatchEvent: vd });function yd(a, b) {
  var c = {};c[a.toLowerCase()] = b.toLowerCase();c["Webkit" + a] = "webkit" + b;c["Moz" + a] = "moz" + b;c["ms" + a] = "MS" + b;c["O" + a] = "o" + b.toLowerCase();return c;
}
var zd = { animationend: yd("Animation", "AnimationEnd"), animationiteration: yd("Animation", "AnimationIteration"), animationstart: yd("Animation", "AnimationStart"), transitionend: yd("Transition", "TransitionEnd") },
    Ad = {},
    Bd = {};l.canUseDOM && (Bd = document.createElement("div").style, "AnimationEvent" in window || (delete zd.animationend.animation, delete zd.animationiteration.animation, delete zd.animationstart.animation), "TransitionEvent" in window || delete zd.transitionend.transition);
function Cd(a) {
  if (Ad[a]) return Ad[a];if (!zd[a]) return a;var b = zd[a],
      c;for (c in b) {
    if (b.hasOwnProperty(c) && c in Bd) return Ad[a] = b[c];
  }return "";
}
var Dd = { topAbort: "abort", topAnimationEnd: Cd("animationend") || "animationend", topAnimationIteration: Cd("animationiteration") || "animationiteration", topAnimationStart: Cd("animationstart") || "animationstart", topBlur: "blur", topCancel: "cancel", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topChange: "change", topClick: "click", topClose: "close", topCompositionEnd: "compositionend", topCompositionStart: "compositionstart", topCompositionUpdate: "compositionupdate", topContextMenu: "contextmenu", topCopy: "copy",
  topCut: "cut", topDoubleClick: "dblclick", topDrag: "drag", topDragEnd: "dragend", topDragEnter: "dragenter", topDragExit: "dragexit", topDragLeave: "dragleave", topDragOver: "dragover", topDragStart: "dragstart", topDrop: "drop", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topFocus: "focus", topInput: "input", topKeyDown: "keydown", topKeyPress: "keypress", topKeyUp: "keyup", topLoadedData: "loadeddata", topLoad: "load", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart",
  topMouseDown: "mousedown", topMouseMove: "mousemove", topMouseOut: "mouseout", topMouseOver: "mouseover", topMouseUp: "mouseup", topPaste: "paste", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topScroll: "scroll", topSeeked: "seeked", topSeeking: "seeking", topSelectionChange: "selectionchange", topStalled: "stalled", topSuspend: "suspend", topTextInput: "textInput", topTimeUpdate: "timeupdate", topToggle: "toggle", topTouchCancel: "touchcancel", topTouchEnd: "touchend", topTouchMove: "touchmove",
  topTouchStart: "touchstart", topTransitionEnd: Cd("transitionend") || "transitionend", topVolumeChange: "volumechange", topWaiting: "waiting", topWheel: "wheel" },
    Ed = {},
    Fd = 0,
    Gd = "_reactListenersID" + ("" + Math.random()).slice(2);function Hd(a) {
  Object.prototype.hasOwnProperty.call(a, Gd) || (a[Gd] = Fd++, Ed[a[Gd]] = {});return Ed[a[Gd]];
}function Id(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }return a;
}
function Jd(a, b) {
  var c = Id(a);a = 0;for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;if (a <= b && d >= b) return { node: c, offset: b - a };a = d;
    }a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;break a;
        }c = c.parentNode;
      }c = void 0;
    }c = Id(c);
  }
}function Kd(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
}
var Ld = l.canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    Md = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" }, dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ") } },
    Nd = null,
    Od = null,
    Pd = null,
    Qd = !1;
function Rd(a, b) {
  if (Qd || null == Nd || Nd !== da()) return null;var c = Nd;"selectionStart" in c && Kd(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : window.getSelection ? (c = window.getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }) : c = void 0;return Pd && ea(Pd, c) ? null : (Pd = c, a = T.getPooled(Md.select, Od, a, b), a.type = "select", a.target = Nd, Ab(a), a);
}
var Sd = { eventTypes: Md, extractEvents: function extractEvents(a, b, c, d) {
    var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument,
        f;if (!(f = !e)) {
      a: {
        e = Hd(e);f = Sa.onSelect;for (var g = 0; g < f.length; g++) {
          var h = f[g];if (!e.hasOwnProperty(h) || !e[h]) {
            e = !1;break a;
          }
        }e = !0;
      }f = !e;
    }if (f) return null;e = b ? qb(b) : window;switch (a) {case "topFocus":
        if (vc(e) || "true" === e.contentEditable) Nd = e, Od = b, Pd = null;break;case "topBlur":
        Pd = Od = Nd = null;break;case "topMouseDown":
        Qd = !0;break;case "topContextMenu":case "topMouseUp":
        return Qd = !1, Rd(c, d);case "topSelectionChange":
        if (Ld) break;
      case "topKeyDown":case "topKeyUp":
        return Rd(c, d);}return null;
  } };function Td(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Td, { animationName: null, elapsedTime: null, pseudoElement: null });function Ud(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Ud, { clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } });function Vd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}bd.augmentClass(Vd, { relatedTarget: null });
function Wd(a) {
  var b = a.keyCode;"charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;return 32 <= a || 13 === a ? a : 0;
}
var Xd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" },
    Yd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4",
  116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };function Zd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}
bd.augmentClass(Zd, { key: function key(a) {
    if (a.key) {
      var b = Xd[a.key] || a.key;if ("Unidentified" !== b) return b;
    }return "keypress" === a.type ? (a = Wd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Yd[a.keyCode] || "Unidentified" : "";
  }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: ed, charCode: function charCode(a) {
    return "keypress" === a.type ? Wd(a) : 0;
  }, keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function which(a) {
    return "keypress" === a.type ? Wd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } });function $d(a, b, c, d) {
  return T.call(this, a, b, c, d);
}fd.augmentClass($d, { dataTransfer: null });function ae(a, b, c, d) {
  return T.call(this, a, b, c, d);
}bd.augmentClass(ae, { touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: ed });function be(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(be, { propertyName: null, elapsedTime: null, pseudoElement: null });
function ce(a, b, c, d) {
  return T.call(this, a, b, c, d);
}fd.augmentClass(ce, { deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  }, deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  }, deltaZ: null, deltaMode: null });var de = {},
    ee = {};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function (a) {
  var b = a[0].toUpperCase() + a.slice(1),
      c = "on" + b;b = "top" + b;c = { phasedRegistrationNames: { bubbled: c, captured: c + "Capture" }, dependencies: [b] };de[a] = c;ee[b] = c;
});
var fe = { eventTypes: de, extractEvents: function extractEvents(a, b, c, d) {
    var e = ee[a];if (!e) return null;switch (a) {case "topKeyPress":
        if (0 === Wd(c)) return null;case "topKeyDown":case "topKeyUp":
        a = Zd;break;case "topBlur":case "topFocus":
        a = Vd;break;case "topClick":
        if (2 === c.button) return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":
        a = fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":
        a = $d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":
        a = ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":
        a = Td;break;case "topTransitionEnd":
        a = be;break;case "topScroll":
        a = bd;break;case "topWheel":
        a = ce;break;case "topCopy":case "topCut":case "topPaste":
        a = Ud;break;default:
        a = T;}b = a.getPooled(e, b, c, d);Ab(b);return b;
  } };sd = function sd(a, b, c, d) {
  a = jb(a, b, c, d);kb(a);lb(!1);
};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Wa = sb.getFiberCurrentPropsFromNode;Xa = sb.getInstanceFromNode;Ya = sb.getNodeFromInstance;hb.injectEventPluginsByName({ SimpleEventPlugin: fe, EnterLeaveEventPlugin: hd, ChangeEventPlugin: ad, SelectEventPlugin: Sd, BeforeInputEventPlugin: ic });var ge = [],
    he = -1;function V(a) {
  0 > he || (a.current = ge[he], ge[he] = null, he--);
}function W(a, b) {
  he++;ge[he] = a.current;a.current = b;
}new Set();var ie = { current: D },
    X = { current: !1 },
    je = D;function ke(a) {
  return le(a) ? je : ie.current;
}
function me(a, b) {
  var c = a.type.contextTypes;if (!c) return D;var d = a.stateNode;if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;var e = {},
      f;for (f in c) {
    e[f] = b[f];
  }d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);return e;
}function le(a) {
  return 2 === a.tag && null != a.type.childContextTypes;
}function ne(a) {
  le(a) && (V(X, a), V(ie, a));
}
function oe(a, b, c) {
  null != ie.cursor ? E("168") : void 0;W(ie, b, a);W(X, c, a);
}function pe(a, b) {
  var c = a.stateNode,
      d = a.type.childContextTypes;if ("function" !== typeof c.getChildContext) return b;c = c.getChildContext();for (var e in c) {
    e in d ? void 0 : E("108", jd(a) || "Unknown", e);
  }return B({}, b, c);
}function qe(a) {
  if (!le(a)) return !1;var b = a.stateNode;b = b && b.__reactInternalMemoizedMergedChildContext || D;je = ie.current;W(ie, b, a);W(X, X.current, a);return !0;
}
function re(a, b) {
  var c = a.stateNode;c ? void 0 : E("169");if (b) {
    var d = pe(a, je);c.__reactInternalMemoizedMergedChildContext = d;V(X, a);V(ie, a);W(ie, d, a);
  } else V(X, a);W(X, b, a);
}
function Y(a, b, c) {
  this.tag = a;this.key = b;this.stateNode = this.type = null;this.sibling = this.child = this["return"] = null;this.index = 0;this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;this.internalContextTag = c;this.effectTag = 0;this.lastEffect = this.firstEffect = this.nextEffect = null;this.expirationTime = 0;this.alternate = null;
}
function se(a, b, c) {
  var d = a.alternate;null === d ? (d = new Y(a.tag, a.key, a.internalContextTag), d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, d.lastEffect = null);d.expirationTime = c;d.pendingProps = b;d.child = a.child;d.memoizedProps = a.memoizedProps;d.memoizedState = a.memoizedState;d.updateQueue = a.updateQueue;d.sibling = a.sibling;d.index = a.index;d.ref = a.ref;return d;
}
function te(a, b, c) {
  var d = void 0,
      e = a.type,
      f = a.key;"function" === typeof e ? (d = e.prototype && e.prototype.isReactComponent ? new Y(2, f, b) : new Y(0, f, b), d.type = e, d.pendingProps = a.props) : "string" === typeof e ? (d = new Y(5, f, b), d.type = e, d.pendingProps = a.props) : "object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e && "number" === typeof e.tag ? (d = e, d.pendingProps = a.props) : E("130", null == e ? e : typeof e === "undefined" ? "undefined" : _typeof(e), "");d.expirationTime = c;return d;
}function ue(a, b, c, d) {
  b = new Y(10, d, b);b.pendingProps = a;b.expirationTime = c;return b;
}
function ve(a, b, c) {
  b = new Y(6, null, b);b.pendingProps = a;b.expirationTime = c;return b;
}function we(a, b, c) {
  b = new Y(7, a.key, b);b.type = a.handler;b.pendingProps = a;b.expirationTime = c;return b;
}function xe(a, b, c) {
  a = new Y(9, null, b);a.expirationTime = c;return a;
}function ye(a, b, c) {
  b = new Y(4, a.key, b);b.pendingProps = a.children || [];b.expirationTime = c;b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };return b;
}var ze = null,
    Ae = null;
function Be(a) {
  return function (b) {
    try {
      return a(b);
    } catch (c) {}
  };
}function Ce(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;if (b.isDisabled || !b.supportsFiber) return !0;try {
    var c = b.inject(a);ze = Be(function (a) {
      return b.onCommitFiberRoot(c, a);
    });Ae = Be(function (a) {
      return b.onCommitFiberUnmount(c, a);
    });
  } catch (d) {}return !0;
}function De(a) {
  "function" === typeof ze && ze(a);
}function Ee(a) {
  "function" === typeof Ae && Ae(a);
}
function Fe(a) {
  return { baseState: a, expirationTime: 0, first: null, last: null, callbackList: null, hasForceUpdate: !1, isInitialized: !1 };
}function Ge(a, b) {
  null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
}
function He(a, b) {
  var c = a.alternate,
      d = a.updateQueue;null === d && (d = a.updateQueue = Fe(null));null !== c ? (a = c.updateQueue, null === a && (a = c.updateQueue = Fe(null))) : a = null;a = a !== d ? a : null;null === a ? Ge(d, b) : null === d.last || null === a.last ? (Ge(d, b), Ge(a, b)) : (Ge(d, b), a.last = b);
}function Ie(a, b, c, d) {
  a = a.partialState;return "function" === typeof a ? a.call(b, c, d) : a;
}
function Je(a, b, c, d, e, f) {
  null !== a && a.updateQueue === c && (c = b.updateQueue = { baseState: c.baseState, expirationTime: c.expirationTime, first: c.first, last: c.last, isInitialized: c.isInitialized, callbackList: null, hasForceUpdate: !1 });c.expirationTime = 0;c.isInitialized ? a = c.baseState : (a = c.baseState = b.memoizedState, c.isInitialized = !0);for (var g = !0, h = c.first, k = !1; null !== h;) {
    var q = h.expirationTime;if (q > f) {
      var v = c.expirationTime;if (0 === v || v > q) c.expirationTime = q;k || (k = !0, c.baseState = a);
    } else {
      k || (c.first = h.next, null === c.first && (c.last = null));if (h.isReplace) a = Ie(h, d, a, e), g = !0;else if (q = Ie(h, d, a, e)) a = g ? B({}, a, q) : B(a, q), g = !1;h.isForced && (c.hasForceUpdate = !0);null !== h.callback && (q = c.callbackList, null === q && (q = c.callbackList = []), q.push(h));
    }h = h.next;
  }null !== c.callbackList ? b.effectTag |= 32 : null !== c.first || c.hasForceUpdate || (b.updateQueue = null);k || (c.baseState = a);return a;
}
function Ke(a, b) {
  var c = a.callbackList;if (null !== c) for (a.callbackList = null, a = 0; a < c.length; a++) {
    var d = c[a],
        e = d.callback;d.callback = null;"function" !== typeof e ? E("191", e) : void 0;e.call(b);
  }
}
function Le(a, b, c, d) {
  function e(a, b) {
    b.updater = f;a.stateNode = b;b._reactInternalFiber = a;
  }var f = { isMounted: ld, enqueueSetState: function enqueueSetState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var g = b(c);He(c, { expirationTime: g, partialState: d, callback: e, isReplace: !1, isForced: !1, nextCallback: null, next: null });a(c, g);
    }, enqueueReplaceState: function enqueueReplaceState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var g = b(c);He(c, { expirationTime: g, partialState: d, callback: e, isReplace: !0, isForced: !1, nextCallback: null, next: null });
      a(c, g);
    }, enqueueForceUpdate: function enqueueForceUpdate(c, d) {
      c = c._reactInternalFiber;d = void 0 === d ? null : d;var e = b(c);He(c, { expirationTime: e, partialState: null, callback: d, isReplace: !1, isForced: !0, nextCallback: null, next: null });a(c, e);
    } };return { adoptClassInstance: e, constructClassInstance: function constructClassInstance(a, b) {
      var c = a.type,
          d = ke(a),
          f = 2 === a.tag && null != a.type.contextTypes,
          g = f ? me(a, d) : D;b = new c(b, g);e(a, b);f && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = d, a.__reactInternalMemoizedMaskedChildContext = g);return b;
    }, mountClassInstance: function mountClassInstance(a, b) {
      var c = a.alternate,
          d = a.stateNode,
          e = d.state || null,
          g = a.pendingProps;g ? void 0 : E("158");var h = ke(a);d.props = g;d.state = a.memoizedState = e;d.refs = D;d.context = me(a, h);null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= 1);"function" === typeof d.componentWillMount && (e = d.state, d.componentWillMount(), e !== d.state && f.enqueueReplaceState(d, d.state, null), e = a.updateQueue, null !== e && (d.state = Je(c, a, e, d, g, b)));"function" === typeof d.componentDidMount && (a.effectTag |= 4);
    }, updateClassInstance: function updateClassInstance(a, b, e) {
      var g = b.stateNode;g.props = b.memoizedProps;g.state = b.memoizedState;var h = b.memoizedProps,
          k = b.pendingProps;k || (k = h, null == k ? E("159") : void 0);var u = g.context,
          z = ke(b);z = me(b, z);"function" !== typeof g.componentWillReceiveProps || h === k && u === z || (u = g.state, g.componentWillReceiveProps(k, z), g.state !== u && f.enqueueReplaceState(g, g.state, null));u = b.memoizedState;e = null !== b.updateQueue ? Je(a, b, b.updateQueue, g, k, e) : u;if (!(h !== k || u !== e || X.current || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), !1;var G = k;if (null === h || null !== b.updateQueue && b.updateQueue.hasForceUpdate) G = !0;else {
        var I = b.stateNode,
            L = b.type;G = "function" === typeof I.shouldComponentUpdate ? I.shouldComponentUpdate(G, e, z) : L.prototype && L.prototype.isPureReactComponent ? !ea(h, G) || !ea(u, e) : !0;
      }G ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(k, e, z), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), c(b, k), d(b, e));g.props = k;g.state = e;g.context = z;return G;
    } };
}var Qe = "function" === typeof Symbol && Symbol["for"],
    Re = Qe ? Symbol["for"]("react.element") : 60103,
    Se = Qe ? Symbol["for"]("react.call") : 60104,
    Te = Qe ? Symbol["for"]("react.return") : 60105,
    Ue = Qe ? Symbol["for"]("react.portal") : 60106,
    Ve = Qe ? Symbol["for"]("react.fragment") : 60107,
    We = "function" === typeof Symbol && Symbol.iterator;
function Xe(a) {
  if (null === a || "undefined" === typeof a) return null;a = We && a[We] || a["@@iterator"];return "function" === typeof a ? a : null;
}var Ye = Array.isArray;
function Ze(a, b) {
  var c = b.ref;if (null !== c && "function" !== typeof c) {
    if (b._owner) {
      b = b._owner;var d = void 0;b && (2 !== b.tag ? E("110") : void 0, d = b.stateNode);d ? void 0 : E("147", c);var e = "" + c;if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;a = function a(_a) {
        var b = d.refs === D ? d.refs = {} : d.refs;null === _a ? delete b[e] : b[e] = _a;
      };a._stringRef = e;return a;
    }"string" !== typeof c ? E("148") : void 0;b._owner ? void 0 : E("149", c);
  }return c;
}
function $e(a, b) {
  "textarea" !== a.type && E("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}
function af(a) {
  function b(b, c) {
    if (a) {
      var d = b.lastEffect;null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;c.nextEffect = null;c.effectTag = 8;
    }
  }function c(c, d) {
    if (!a) return null;for (; null !== d;) {
      b(c, d), d = d.sibling;
    }return null;
  }function d(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }return a;
  }function e(a, b, c) {
    a = se(a, b, c);a.index = 0;a.sibling = null;return a;
  }function f(b, c, d) {
    b.index = d;if (!a) return c;d = b.alternate;if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;b.effectTag = 2;return c;
  }function g(b) {
    a && null === b.alternate && (b.effectTag = 2);return b;
  }function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = ve(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c, d);b["return"] = a;return b;
  }function k(a, b, c, d) {
    if (null !== b && b.type === c.type) return d = e(b, c.props, d), d.ref = Ze(b, c), d["return"] = a, d;d = te(c, a.internalContextTag, d);d.ref = Ze(b, c);d["return"] = a;return d;
  }function q(a, b, c, d) {
    if (null === b || 7 !== b.tag) return b = we(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c, d);
    b["return"] = a;return b;
  }function v(a, b, c, d) {
    if (null === b || 9 !== b.tag) return b = xe(c, a.internalContextTag, d), b.type = c.value, b["return"] = a, b;b = e(b, null, d);b.type = c.value;b["return"] = a;return b;
  }function y(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = ye(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c.children || [], d);b["return"] = a;return b;
  }function u(a, b, c, d, f) {
    if (null === b || 10 !== b.tag) return b = ue(c, a.internalContextTag, d, f), b["return"] = a, b;b = e(b, c, d);b["return"] = a;return b;
  }function z(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = ve("" + b, a.internalContextTag, c), b["return"] = a, b;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
      switch (b.$$typeof) {case Re:
          if (b.type === Ve) return b = ue(b.props.children, a.internalContextTag, c, b.key), b["return"] = a, b;c = te(b, a.internalContextTag, c);c.ref = Ze(null, b);c["return"] = a;return c;case Se:
          return b = we(b, a.internalContextTag, c), b["return"] = a, b;case Te:
          return c = xe(b, a.internalContextTag, c), c.type = b.value, c["return"] = a, c;case Ue:
          return b = ye(b, a.internalContextTag, c), b["return"] = a, b;}if (Ye(b) || Xe(b)) return b = ue(b, a.internalContextTag, c, null), b["return"] = a, b;$e(a, b);
    }return null;
  }function G(a, b, c, d) {
    var e = null !== b ? b.key : null;if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c) {
      switch (c.$$typeof) {case Re:
          return c.key === e ? c.type === Ve ? u(a, b, c.props.children, d, e) : k(a, b, c, d) : null;case Se:
          return c.key === e ? q(a, b, c, d) : null;case Te:
          return null === e ? v(a, b, c, d) : null;case Ue:
          return c.key === e ? y(a, b, c, d) : null;}if (Ye(c) || Xe(c)) return null !== e ? null : u(a, b, c, d, null);$e(a, c);
    }return null;
  }function I(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) {
      switch (d.$$typeof) {case Re:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === Ve ? u(b, a, d.props.children, e, d.key) : k(b, a, d, e);case Se:
          return a = a.get(null === d.key ? c : d.key) || null, q(b, a, d, e);case Te:
          return a = a.get(c) || null, v(b, a, d, e);case Ue:
          return a = a.get(null === d.key ? c : d.key) || null, y(b, a, d, e);}if (Ye(d) || Xe(d)) return a = a.get(c) || null, u(b, a, d, e, null);$e(b, d);
    }return null;
  }function L(e, g, m, A) {
    for (var h = null, r = null, n = g, w = g = 0, k = null; null !== n && w < m.length; w++) {
      n.index > w ? (k = n, n = null) : k = n.sibling;var x = G(e, n, m[w], A);if (null === x) {
        null === n && (n = k);break;
      }a && n && null === x.alternate && b(e, n);g = f(x, g, w);null === r ? h = x : r.sibling = x;r = x;n = k;
    }if (w === m.length) return c(e, n), h;if (null === n) {
      for (; w < m.length; w++) {
        if (n = z(e, m[w], A)) g = f(n, g, w), null === r ? h = n : r.sibling = n, r = n;
      }return h;
    }for (n = d(e, n); w < m.length; w++) {
      if (k = I(n, e, w, m[w], A)) {
        if (a && null !== k.alternate) n["delete"](null === k.key ? w : k.key);g = f(k, g, w);null === r ? h = k : r.sibling = k;r = k;
      }
    }a && n.forEach(function (a) {
      return b(e, a);
    });return h;
  }function N(e, g, m, A) {
    var h = Xe(m);"function" !== typeof h ? E("150") : void 0;m = h.call(m);null == m ? E("151") : void 0;for (var r = h = null, n = g, w = g = 0, k = null, x = m.next(); null !== n && !x.done; w++, x = m.next()) {
      n.index > w ? (k = n, n = null) : k = n.sibling;var J = G(e, n, x.value, A);if (null === J) {
        n || (n = k);break;
      }a && n && null === J.alternate && b(e, n);g = f(J, g, w);null === r ? h = J : r.sibling = J;r = J;n = k;
    }if (x.done) return c(e, n), h;if (null === n) {
      for (; !x.done; w++, x = m.next()) {
        x = z(e, x.value, A), null !== x && (g = f(x, g, w), null === r ? h = x : r.sibling = x, r = x);
      }return h;
    }for (n = d(e, n); !x.done; w++, x = m.next()) {
      if (x = I(n, e, w, x.value, A), null !== x) {
        if (a && null !== x.alternate) n["delete"](null === x.key ? w : x.key);g = f(x, g, w);null === r ? h = x : r.sibling = x;r = x;
      }
    }a && n.forEach(function (a) {
      return b(e, a);
    });return h;
  }return function (a, d, f, h) {
    "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f && f.type === Ve && null === f.key && (f = f.props.children);
    var m = "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f;if (m) switch (f.$$typeof) {case Re:
        a: {
          var r = f.key;for (m = d; null !== m;) {
            if (m.key === r) {
              if (10 === m.tag ? f.type === Ve : m.type === f.type) {
                c(a, m.sibling);d = e(m, f.type === Ve ? f.props.children : f.props, h);d.ref = Ze(m, f);d["return"] = a;a = d;break a;
              } else {
                c(a, m);break;
              }
            } else b(a, m);m = m.sibling;
          }f.type === Ve ? (d = ue(f.props.children, a.internalContextTag, h, f.key), d["return"] = a, a = d) : (h = te(f, a.internalContextTag, h), h.ref = Ze(d, f), h["return"] = a, a = h);
        }return g(a);case Se:
        a: {
          for (m = f.key; null !== d;) {
            if (d.key === m) {
              if (7 === d.tag) {
                c(a, d.sibling);d = e(d, f, h);d["return"] = a;a = d;break a;
              } else {
                c(a, d);break;
              }
            } else b(a, d);d = d.sibling;
          }d = we(f, a.internalContextTag, h);d["return"] = a;a = d;
        }return g(a);case Te:
        a: {
          if (null !== d) if (9 === d.tag) {
            c(a, d.sibling);d = e(d, null, h);d.type = f.value;d["return"] = a;a = d;break a;
          } else c(a, d);d = xe(f, a.internalContextTag, h);d.type = f.value;d["return"] = a;a = d;
        }return g(a);case Ue:
        a: {
          for (m = f.key; null !== d;) {
            if (d.key === m) {
              if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                c(a, d.sibling);d = e(d, f.children || [], h);d["return"] = a;a = d;break a;
              } else {
                c(a, d);break;
              }
            } else b(a, d);d = d.sibling;
          }d = ye(f, a.internalContextTag, h);d["return"] = a;a = d;
        }return g(a);}if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f, h)) : (c(a, d), d = ve(f, a.internalContextTag, h)), d["return"] = a, a = d, g(a);if (Ye(f)) return L(a, d, f, h);if (Xe(f)) return N(a, d, f, h);m && $e(a, f);if ("undefined" === typeof f) switch (a.tag) {case 2:case 1:
        h = a.type, E("152", h.displayName || h.name || "Component");}return c(a, d);
  };
}var bf = af(!0),
    cf = af(!1);
function df(a, b, c, d, e) {
  function f(a, b, c) {
    var d = b.expirationTime;b.child = null === a ? cf(b, null, c, d) : bf(b, a.child, c, d);
  }function g(a, b) {
    var c = b.ref;null === c || a && a.ref === c || (b.effectTag |= 128);
  }function h(a, b, c, d) {
    g(a, b);if (!c) return d && re(b, !1), q(a, b);c = b.stateNode;id.current = b;var e = c.render();b.effectTag |= 1;f(a, b, e);b.memoizedState = c.state;b.memoizedProps = c.props;d && re(b, !0);return b.child;
  }function k(a) {
    var b = a.stateNode;b.pendingContext ? oe(a, b.pendingContext, b.pendingContext !== b.context) : b.context && oe(a, b.context, !1);I(a, b.containerInfo);
  }function q(a, b) {
    null !== a && b.child !== a.child ? E("153") : void 0;if (null !== b.child) {
      a = b.child;var c = se(a, a.pendingProps, a.expirationTime);b.child = c;for (c["return"] = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = se(a, a.pendingProps, a.expirationTime), c["return"] = b;
      }c.sibling = null;
    }return b.child;
  }function v(a, b) {
    switch (b.tag) {case 3:
        k(b);break;case 2:
        qe(b);break;case 4:
        I(b, b.stateNode.containerInfo);}return null;
  }var y = a.shouldSetTextContent,
      u = a.useSyncScheduling,
      z = a.shouldDeprioritizeSubtree,
      G = b.pushHostContext,
      I = b.pushHostContainer,
      L = c.enterHydrationState,
      N = c.resetHydrationState,
      J = c.tryToClaimNextHydratableInstance;a = Le(d, e, function (a, b) {
    a.memoizedProps = b;
  }, function (a, b) {
    a.memoizedState = b;
  });var w = a.adoptClassInstance,
      m = a.constructClassInstance,
      A = a.mountClassInstance,
      Ob = a.updateClassInstance;return { beginWork: function beginWork(a, b, c) {
      if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);switch (b.tag) {case 0:
          null !== a ? E("155") : void 0;var d = b.type,
              e = b.pendingProps,
              r = ke(b);r = me(b, r);d = d(e, r);b.effectTag |= 1;"object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d && "function" === typeof d.render ? (b.tag = 2, e = qe(b), w(b, d), A(b, c), b = h(a, b, !0, e)) : (b.tag = 1, f(a, b, d), b.memoizedProps = e, b = b.child);return b;case 1:
          a: {
            e = b.type;c = b.pendingProps;d = b.memoizedProps;if (X.current) null === c && (c = d);else if (null === c || d === c) {
              b = q(a, b);break a;
            }d = ke(b);d = me(b, d);e = e(c, d);b.effectTag |= 1;f(a, b, e);b.memoizedProps = c;b = b.child;
          }return b;case 2:
          return e = qe(b), d = void 0, null === a ? b.stateNode ? E("153") : (m(b, b.pendingProps), A(b, c), d = !0) : d = Ob(a, b, c), h(a, b, d, e);case 3:
          return k(b), e = b.updateQueue, null !== e ? (d = b.memoizedState, e = Je(a, b, e, null, null, c), d === e ? (N(), b = q(a, b)) : (d = e.element, r = b.stateNode, (null === a || null === a.child) && r.hydrate && L(b) ? (b.effectTag |= 2, b.child = cf(b, null, d, c)) : (N(), f(a, b, d)), b.memoizedState = e, b = b.child)) : (N(), b = q(a, b)), b;case 5:
          G(b);null === a && J(b);e = b.type;var n = b.memoizedProps;d = b.pendingProps;null === d && (d = n, null === d ? E("154") : void 0);r = null !== a ? a.memoizedProps : null;X.current || null !== d && n !== d ? (n = d.children, y(e, d) ? n = null : r && y(e, r) && (b.effectTag |= 16), g(a, b), 2147483647 !== c && !u && z(e, d) ? (b.expirationTime = 2147483647, b = null) : (f(a, b, n), b.memoizedProps = d, b = b.child)) : b = q(a, b);return b;case 6:
          return null === a && J(b), a = b.pendingProps, null === a && (a = b.memoizedProps), b.memoizedProps = a, null;case 8:
          b.tag = 7;case 7:
          e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null === e ? E("154") : void 0);else if (null === e || b.memoizedProps === e) e = b.memoizedProps;d = e.children;b.stateNode = null === a ? cf(b, b.stateNode, d, c) : bf(b, b.stateNode, d, c);b.memoizedProps = e;return b.stateNode;
        case 9:
          return null;case 4:
          a: {
            I(b, b.stateNode.containerInfo);e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null == e ? E("154") : void 0);else if (null === e || b.memoizedProps === e) {
              b = q(a, b);break a;
            }null === a ? b.child = bf(b, null, e, c) : f(a, b, e);b.memoizedProps = e;b = b.child;
          }return b;case 10:
          a: {
            c = b.pendingProps;if (X.current) null === c && (c = b.memoizedProps);else if (null === c || b.memoizedProps === c) {
              b = q(a, b);break a;
            }f(a, b, c);b.memoizedProps = c;b = b.child;
          }return b;default:
          E("156");}
    }, beginFailedWork: function beginFailedWork(a, b, c) {
      switch (b.tag) {case 2:
          qe(b);break;case 3:
          k(b);break;default:
          E("157");}b.effectTag |= 64;null === a ? b.child = null : b.child !== a.child && (b.child = a.child);if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);b.firstEffect = null;b.lastEffect = null;b.child = null === a ? cf(b, null, null, c) : bf(b, a.child, null, c);2 === b.tag && (a = b.stateNode, b.memoizedProps = a.props, b.memoizedState = a.state);return b.child;
    } };
}
function ef(a, b, c) {
  function d(a) {
    a.effectTag |= 4;
  }var e = a.createInstance,
      f = a.createTextInstance,
      g = a.appendInitialChild,
      h = a.finalizeInitialChildren,
      k = a.prepareUpdate,
      q = a.persistence,
      v = b.getRootHostContainer,
      y = b.popHostContext,
      u = b.getHostContext,
      z = b.popHostContainer,
      G = c.prepareToHydrateHostInstance,
      I = c.prepareToHydrateHostTextInstance,
      L = c.popHydrationState,
      N = void 0,
      J = void 0,
      w = void 0;a.mutation ? (N = function N() {}, J = function J(a, b, c) {
    (b.updateQueue = c) && d(b);
  }, w = function w(a, b, c, e) {
    c !== e && d(b);
  }) : q ? E("235") : E("236");
  return { completeWork: function completeWork(a, b, c) {
      var m = b.pendingProps;if (null === m) m = b.memoizedProps;else if (2147483647 !== b.expirationTime || 2147483647 === c) b.pendingProps = null;switch (b.tag) {case 1:
          return null;case 2:
          return ne(b), null;case 3:
          z(b);V(X, b);V(ie, b);m = b.stateNode;m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null);if (null === a || null === a.child) L(b), b.effectTag &= -3;N(b);return null;case 5:
          y(b);c = v();var A = b.type;if (null !== a && null != b.stateNode) {
            var p = a.memoizedProps,
                q = b.stateNode,
                x = u();q = k(q, A, p, m, c, x);J(a, b, q, A, p, m, c);a.ref !== b.ref && (b.effectTag |= 128);
          } else {
            if (!m) return null === b.stateNode ? E("166") : void 0, null;a = u();if (L(b)) G(b, c, a) && d(b);else {
              a = e(A, m, c, a, b);a: for (p = b.child; null !== p;) {
                if (5 === p.tag || 6 === p.tag) g(a, p.stateNode);else if (4 !== p.tag && null !== p.child) {
                  p.child["return"] = p;p = p.child;continue;
                }if (p === b) break;for (; null === p.sibling;) {
                  if (null === p["return"] || p["return"] === b) break a;p = p["return"];
                }p.sibling["return"] = p["return"];p = p.sibling;
              }h(a, A, m, c) && d(b);b.stateNode = a;
            }null !== b.ref && (b.effectTag |= 128);
          }return null;case 6:
          if (a && null != b.stateNode) w(a, b, a.memoizedProps, m);else {
            if ("string" !== typeof m) return null === b.stateNode ? E("166") : void 0, null;a = v();c = u();L(b) ? I(b) && d(b) : b.stateNode = f(m, a, c, b);
          }return null;case 7:
          (m = b.memoizedProps) ? void 0 : E("165");b.tag = 8;A = [];a: for ((p = b.stateNode) && (p["return"] = b); null !== p;) {
            if (5 === p.tag || 6 === p.tag || 4 === p.tag) E("247");else if (9 === p.tag) A.push(p.type);else if (null !== p.child) {
              p.child["return"] = p;p = p.child;continue;
            }for (; null === p.sibling;) {
              if (null === p["return"] || p["return"] === b) break a;p = p["return"];
            }p.sibling["return"] = p["return"];p = p.sibling;
          }p = m.handler;m = p(m.props, A);b.child = bf(b, null !== a ? a.child : null, m, c);return b.child;case 8:
          return b.tag = 7, null;case 9:
          return null;case 10:
          return null;case 4:
          return z(b), N(b), null;case 0:
          E("167");default:
          E("156");}
    } };
}
function ff(a, b) {
  function c(a) {
    var c = a.ref;if (null !== c) try {
      c(null);
    } catch (A) {
      b(a, A);
    }
  }function d(a) {
    "function" === typeof Ee && Ee(a);switch (a.tag) {case 2:
        c(a);var d = a.stateNode;if ("function" === typeof d.componentWillUnmount) try {
          d.props = a.memoizedProps, d.state = a.memoizedState, d.componentWillUnmount();
        } catch (A) {
          b(a, A);
        }break;case 5:
        c(a);break;case 7:
        e(a.stateNode);break;case 4:
        k && g(a);}
  }function e(a) {
    for (var b = a;;) {
      if (d(b), null === b.child || k && 4 === b.tag) {
        if (b === a) break;for (; null === b.sibling;) {
          if (null === b["return"] || b["return"] === a) return;b = b["return"];
        }b.sibling["return"] = b["return"];b = b.sibling;
      } else b.child["return"] = b, b = b.child;
    }
  }function f(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }function g(a) {
    for (var b = a, c = !1, f = void 0, g = void 0;;) {
      if (!c) {
        c = b["return"];a: for (;;) {
          null === c ? E("160") : void 0;switch (c.tag) {case 5:
              f = c.stateNode;g = !1;break a;case 3:
              f = c.stateNode.containerInfo;g = !0;break a;case 4:
              f = c.stateNode.containerInfo;g = !0;break a;}c = c["return"];
        }c = !0;
      }if (5 === b.tag || 6 === b.tag) e(b), g ? J(f, b.stateNode) : N(f, b.stateNode);else if (4 === b.tag ? f = b.stateNode.containerInfo : d(b), null !== b.child) {
        b.child["return"] = b;b = b.child;continue;
      }if (b === a) break;for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;b = b["return"];4 === b.tag && (c = !1);
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }var h = a.getPublicInstance,
      k = a.mutation;a = a.persistence;k || (a ? E("235") : E("236"));var q = k.commitMount,
      v = k.commitUpdate,
      y = k.resetTextContent,
      u = k.commitTextUpdate,
      z = k.appendChild,
      G = k.appendChildToContainer,
      I = k.insertBefore,
      L = k.insertInContainerBefore,
      N = k.removeChild,
      J = k.removeChildFromContainer;return { commitResetTextContent: function commitResetTextContent(a) {
      y(a.stateNode);
    }, commitPlacement: function commitPlacement(a) {
      a: {
        for (var b = a["return"]; null !== b;) {
          if (f(b)) {
            var c = b;break a;
          }b = b["return"];
        }E("160");c = void 0;
      }var d = b = void 0;switch (c.tag) {case 5:
          b = c.stateNode;d = !1;break;case 3:
          b = c.stateNode.containerInfo;d = !0;break;case 4:
          b = c.stateNode.containerInfo;d = !0;break;default:
          E("161");}c.effectTag & 16 && (y(b), c.effectTag &= -17);a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c["return"] || f(c["return"])) {
            c = null;break a;
          }c = c["return"];
        }c.sibling["return"] = c["return"];for (c = c.sibling; 5 !== c.tag && 6 !== c.tag;) {
          if (c.effectTag & 2) continue b;if (null === c.child || 4 === c.tag) continue b;else c.child["return"] = c, c = c.child;
        }if (!(c.effectTag & 2)) {
          c = c.stateNode;break a;
        }
      }for (var e = a;;) {
        if (5 === e.tag || 6 === e.tag) c ? d ? L(b, e.stateNode, c) : I(b, e.stateNode, c) : d ? G(b, e.stateNode) : z(b, e.stateNode);else if (4 !== e.tag && null !== e.child) {
          e.child["return"] = e;e = e.child;continue;
        }if (e === a) break;for (; null === e.sibling;) {
          if (null === e["return"] || e["return"] === a) return;e = e["return"];
        }e.sibling["return"] = e["return"];e = e.sibling;
      }
    }, commitDeletion: function commitDeletion(a) {
      g(a);a["return"] = null;a.child = null;a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
    }, commitWork: function commitWork(a, b) {
      switch (b.tag) {case 2:
          break;case 5:
          var c = b.stateNode;if (null != c) {
            var d = b.memoizedProps;a = null !== a ? a.memoizedProps : d;var e = b.type,
                f = b.updateQueue;b.updateQueue = null;null !== f && v(c, f, e, a, d, b);
          }break;case 6:
          null === b.stateNode ? E("162") : void 0;c = b.memoizedProps;u(b.stateNode, null !== a ? a.memoizedProps : c, c);break;case 3:
          break;default:
          E("163");}
    }, commitLifeCycles: function commitLifeCycles(a, b) {
      switch (b.tag) {case 2:
          var c = b.stateNode;if (b.effectTag & 4) if (null === a) c.props = b.memoizedProps, c.state = b.memoizedState, c.componentDidMount();else {
            var d = a.memoizedProps;a = a.memoizedState;c.props = b.memoizedProps;c.state = b.memoizedState;c.componentDidUpdate(d, a);
          }b = b.updateQueue;null !== b && Ke(b, c);break;case 3:
          c = b.updateQueue;null !== c && Ke(c, null !== b.child ? b.child.stateNode : null);break;case 5:
          c = b.stateNode;null === a && b.effectTag & 4 && q(c, b.type, b.memoizedProps, b);break;case 6:
          break;case 4:
          break;default:
          E("163");}
    }, commitAttachRef: function commitAttachRef(a) {
      var b = a.ref;if (null !== b) {
        var c = a.stateNode;switch (a.tag) {case 5:
            b(h(c));break;default:
            b(c);}
      }
    }, commitDetachRef: function commitDetachRef(a) {
      a = a.ref;null !== a && a(null);
    } };
}var gf = {};
function hf(a) {
  function b(a) {
    a === gf ? E("174") : void 0;return a;
  }var c = a.getChildHostContext,
      d = a.getRootHostContext,
      e = { current: gf },
      f = { current: gf },
      g = { current: gf };return { getHostContext: function getHostContext() {
      return b(e.current);
    }, getRootHostContainer: function getRootHostContainer() {
      return b(g.current);
    }, popHostContainer: function popHostContainer(a) {
      V(e, a);V(f, a);V(g, a);
    }, popHostContext: function popHostContext(a) {
      f.current === a && (V(e, a), V(f, a));
    }, pushHostContainer: function pushHostContainer(a, b) {
      W(g, b, a);b = d(b);W(f, a, a);W(e, b, a);
    }, pushHostContext: function pushHostContext(a) {
      var d = b(g.current),
          h = b(e.current);
      d = c(h, a.type, d);h !== d && (W(f, a, a), W(e, d, a));
    }, resetHostContainer: function resetHostContainer() {
      e.current = gf;g.current = gf;
    } };
}
function jf(a) {
  function b(a, b) {
    var c = new Y(5, null, 0);c.type = "DELETED";c.stateNode = b;c["return"] = a;c.effectTag = 8;null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }function c(a, b) {
    switch (a.tag) {case 5:
        return b = f(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;case 6:
        return b = g(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;default:
        return !1;}
  }function d(a) {
    for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag;) {
      a = a["return"];
    }y = a;
  }var e = a.shouldSetTextContent;
  a = a.hydration;if (!a) return { enterHydrationState: function enterHydrationState() {
      return !1;
    }, resetHydrationState: function resetHydrationState() {}, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {}, prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
      E("175");
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
      E("176");
    }, popHydrationState: function popHydrationState() {
      return !1;
    } };var f = a.canHydrateInstance,
      g = a.canHydrateTextInstance,
      h = a.getNextHydratableSibling,
      k = a.getFirstHydratableChild,
      q = a.hydrateInstance,
      v = a.hydrateTextInstance,
      y = null,
      u = null,
      z = !1;return { enterHydrationState: function enterHydrationState(a) {
      u = k(a.stateNode.containerInfo);y = a;return z = !0;
    }, resetHydrationState: function resetHydrationState() {
      u = y = null;z = !1;
    }, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance(a) {
      if (z) {
        var d = u;if (d) {
          if (!c(a, d)) {
            d = h(d);if (!d || !c(a, d)) {
              a.effectTag |= 2;z = !1;y = a;return;
            }b(y, u);
          }y = a;u = k(d);
        } else a.effectTag |= 2, z = !1, y = a;
      }
    }, prepareToHydrateHostInstance: function prepareToHydrateHostInstance(a, b, c) {
      b = q(a.stateNode, a.type, a.memoizedProps, b, c, a);a.updateQueue = b;return null !== b ? !0 : !1;
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance(a) {
      return v(a.stateNode, a.memoizedProps, a);
    }, popHydrationState: function popHydrationState(a) {
      if (a !== y) return !1;if (!z) return d(a), z = !0, !1;var c = a.type;if (5 !== a.tag || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = u; c;) {
        b(a, c), c = h(c);
      }d(a);u = y ? h(a.stateNode) : null;return !0;
    } };
}
function kf(a) {
  function b(a) {
    Qb = ja = !0;var b = a.stateNode;b.current === a ? E("177") : void 0;b.isReadyForCommit = !1;id.current = null;if (1 < a.effectTag) {
      if (null !== a.lastEffect) {
        a.lastEffect.nextEffect = a;var c = a.firstEffect;
      } else c = a;
    } else c = a.firstEffect;yg();for (t = c; null !== t;) {
      var d = !1,
          e = void 0;try {
        for (; null !== t;) {
          var f = t.effectTag;f & 16 && zg(t);if (f & 128) {
            var g = t.alternate;null !== g && Ag(g);
          }switch (f & -242) {case 2:
              Ne(t);t.effectTag &= -3;break;case 6:
              Ne(t);t.effectTag &= -3;Oe(t.alternate, t);break;case 4:
              Oe(t.alternate, t);break;case 8:
              Sc = !0, Bg(t), Sc = !1;}t = t.nextEffect;
        }
      } catch (Tc) {
        d = !0, e = Tc;
      }d && (null === t ? E("178") : void 0, h(t, e), null !== t && (t = t.nextEffect));
    }Cg();b.current = a;for (t = c; null !== t;) {
      c = !1;d = void 0;try {
        for (; null !== t;) {
          var k = t.effectTag;k & 36 && Dg(t.alternate, t);k & 128 && Eg(t);if (k & 64) switch (e = t, f = void 0, null !== R && (f = R.get(e), R["delete"](e), null == f && null !== e.alternate && (e = e.alternate, f = R.get(e), R["delete"](e))), null == f ? E("184") : void 0, e.tag) {case 2:
              e.stateNode.componentDidCatch(f.error, { componentStack: f.componentStack });
              break;case 3:
              null === ca && (ca = f.error);break;default:
              E("157");}var Qc = t.nextEffect;t.nextEffect = null;t = Qc;
        }
      } catch (Tc) {
        c = !0, d = Tc;
      }c && (null === t ? E("178") : void 0, h(t, d), null !== t && (t = t.nextEffect));
    }ja = Qb = !1;"function" === typeof De && De(a.stateNode);ha && (ha.forEach(G), ha = null);null !== ca && (a = ca, ca = null, Ob(a));b = b.current.expirationTime;0 === b && (qa = R = null);return b;
  }function c(a) {
    for (;;) {
      var b = Fg(a.alternate, a, H),
          c = a["return"],
          d = a.sibling;var e = a;if (2147483647 === H || 2147483647 !== e.expirationTime) {
        if (2 !== e.tag && 3 !== e.tag) var f = 0;else f = e.updateQueue, f = null === f ? 0 : f.expirationTime;for (var g = e.child; null !== g;) {
          0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), g = g.sibling;
        }e.expirationTime = f;
      }if (null !== b) return b;null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));if (null !== d) return d;
      if (null !== c) a = c;else {
        a.stateNode.isReadyForCommit = !0;break;
      }
    }return null;
  }function d(a) {
    var b = rg(a.alternate, a, H);null === b && (b = c(a));id.current = null;return b;
  }function e(a) {
    var b = Gg(a.alternate, a, H);null === b && (b = c(a));id.current = null;return b;
  }function f(a) {
    if (null !== R) {
      if (!(0 === H || H > a)) if (H <= Uc) for (; null !== F;) {
        F = k(F) ? e(F) : d(F);
      } else for (; null !== F && !A();) {
        F = k(F) ? e(F) : d(F);
      }
    } else if (!(0 === H || H > a)) if (H <= Uc) for (; null !== F;) {
      F = d(F);
    } else for (; null !== F && !A();) {
      F = d(F);
    }
  }function g(a, b) {
    ja ? E("243") : void 0;ja = !0;a.isReadyForCommit = !1;if (a !== ra || b !== H || null === F) {
      for (; -1 < he;) {
        ge[he] = null, he--;
      }je = D;ie.current = D;X.current = !1;x();ra = a;H = b;F = se(ra.current, null, b);
    }var c = !1,
        d = null;try {
      f(b);
    } catch (Rc) {
      c = !0, d = Rc;
    }for (; c;) {
      if (eb) {
        ca = d;break;
      }var g = F;if (null === g) eb = !0;else {
        var k = h(g, d);null === k ? E("183") : void 0;if (!eb) {
          try {
            c = k;d = b;for (k = c; null !== g;) {
              switch (g.tag) {case 2:
                  ne(g);break;case 5:
                  qg(g);break;case 3:
                  p(g);break;case 4:
                  p(g);}if (g === k || g.alternate === k) break;g = g["return"];
            }F = e(c);f(d);
          } catch (Rc) {
            c = !0;d = Rc;continue;
          }break;
        }
      }
    }b = ca;eb = ja = !1;ca = null;null !== b && Ob(b);return a.isReadyForCommit ? a.current.alternate : null;
  }function h(a, b) {
    var c = id.current = null,
        d = !1,
        e = !1,
        f = null;if (3 === a.tag) c = a, q(a) && (eb = !0);else for (var g = a["return"]; null !== g && null === c;) {
      2 === g.tag ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = jd(g), c = g, e = !0) : 3 === g.tag && (c = g);if (q(g)) {
        if (Sc || null !== ha && (ha.has(g) || null !== g.alternate && ha.has(g.alternate))) return null;c = null;e = !1;
      }g = g["return"];
    }if (null !== c) {
      null === qa && (qa = new Set());qa.add(c);var h = "";g = a;do {
        a: switch (g.tag) {case 0:case 1:case 2:case 5:
            var k = g._debugOwner,
                Qc = g._debugSource;var m = jd(g);var n = null;k && (n = jd(k));k = Qc;m = "\n    in " + (m || "Unknown") + (k ? " (at " + k.fileName.replace(/^.*[\\\/]/, "") + ":" + k.lineNumber + ")" : n ? " (created by " + n + ")" : "");break a;default:
            m = "";}h += m;g = g["return"];
      } while (g);g = h;a = jd(a);null === R && (R = new Map());b = { componentName: a, componentStack: g, error: b, errorBoundary: d ? c.stateNode : null, errorBoundaryFound: d, errorBoundaryName: f, willRetry: e };R.set(c, b);try {
        var p = b.error;p && p.suppressReactErrorLogging || console.error(p);
      } catch (Vc) {
        Vc && Vc.suppressReactErrorLogging || console.error(Vc);
      }Qb ? (null === ha && (ha = new Set()), ha.add(c)) : G(c);return c;
    }null === ca && (ca = b);return null;
  }function k(a) {
    return null !== R && (R.has(a) || null !== a.alternate && R.has(a.alternate));
  }function q(a) {
    return null !== qa && (qa.has(a) || null !== a.alternate && qa.has(a.alternate));
  }function v() {
    return 20 * (((I() + 100) / 20 | 0) + 1);
  }function y(a) {
    return 0 !== ka ? ka : ja ? Qb ? 1 : H : !Hg || a.internalContextTag & 1 ? v() : 1;
  }function u(a, b) {
    return z(a, b, !1);
  }function z(a, b) {
    for (; null !== a;) {
      if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b);if (null === a["return"]) if (3 === a.tag) {
        var c = a.stateNode;!ja && c === ra && b < H && (F = ra = null, H = 0);var d = c,
            e = b;Rb > Ig && E("185");if (null === d.nextScheduledRoot) d.remainingExpirationTime = e, null === O ? (sa = O = d, d.nextScheduledRoot = d) : (O = O.nextScheduledRoot = d, O.nextScheduledRoot = sa);else {
          var f = d.remainingExpirationTime;if (0 === f || e < f) d.remainingExpirationTime = e;
        }Fa || (la ? Sb && (ma = d, na = 1, m(ma, na)) : 1 === e ? w(1, null) : L(e));!ja && c === ra && b < H && (F = ra = null, H = 0);
      } else break;a = a["return"];
    }
  }function G(a) {
    z(a, 1, !0);
  }function I() {
    return Uc = ((Wc() - Pe) / 10 | 0) + 2;
  }function L(a) {
    if (0 !== Tb) {
      if (a > Tb) return;Jg(Xc);
    }var b = Wc() - Pe;Tb = a;Xc = Kg(J, { timeout: 10 * (a - 2) - b });
  }function N() {
    var a = 0,
        b = null;if (null !== O) for (var c = O, d = sa; null !== d;) {
      var e = d.remainingExpirationTime;if (0 === e) {
        null === c || null === O ? E("244") : void 0;if (d === d.nextScheduledRoot) {
          sa = O = d.nextScheduledRoot = null;break;
        } else if (d === sa) sa = e = d.nextScheduledRoot, O.nextScheduledRoot = e, d.nextScheduledRoot = null;else if (d === O) {
          O = c;O.nextScheduledRoot = sa;d.nextScheduledRoot = null;break;
        } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;d = c.nextScheduledRoot;
      } else {
        if (0 === a || e < a) a = e, b = d;if (d === O) break;c = d;d = d.nextScheduledRoot;
      }
    }c = ma;null !== c && c === b ? Rb++ : Rb = 0;ma = b;na = a;
  }function J(a) {
    w(0, a);
  }function w(a, b) {
    fb = b;for (N(); null !== ma && 0 !== na && (0 === a || na <= a) && !Yc;) {
      m(ma, na), N();
    }null !== fb && (Tb = 0, Xc = -1);0 !== na && L(na);fb = null;Yc = !1;Rb = 0;if (Ub) throw a = Zc, Zc = null, Ub = !1, a;
  }function m(a, c) {
    Fa ? E("245") : void 0;Fa = !0;if (c <= I()) {
      var d = a.finishedWork;null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (a.remainingExpirationTime = b(d)));
    } else d = a.finishedWork, null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (A() ? a.finishedWork = d : a.remainingExpirationTime = b(d)));Fa = !1;
  }function A() {
    return null === fb || fb.timeRemaining() > Lg ? !1 : Yc = !0;
  }function Ob(a) {
    null === ma ? E("246") : void 0;ma.remainingExpirationTime = 0;Ub || (Ub = !0, Zc = a);
  }var r = hf(a),
      n = jf(a),
      p = r.popHostContainer,
      qg = r.popHostContext,
      x = r.resetHostContainer,
      Me = df(a, r, n, u, y),
      rg = Me.beginWork,
      Gg = Me.beginFailedWork,
      Fg = ef(a, r, n).completeWork;r = ff(a, h);var zg = r.commitResetTextContent,
      Ne = r.commitPlacement,
      Bg = r.commitDeletion,
      Oe = r.commitWork,
      Dg = r.commitLifeCycles,
      Eg = r.commitAttachRef,
      Ag = r.commitDetachRef,
      Wc = a.now,
      Kg = a.scheduleDeferredCallback,
      Jg = a.cancelDeferredCallback,
      Hg = a.useSyncScheduling,
      yg = a.prepareForCommit,
      Cg = a.resetAfterCommit,
      Pe = Wc(),
      Uc = 2,
      ka = 0,
      ja = !1,
      F = null,
      ra = null,
      H = 0,
      t = null,
      R = null,
      qa = null,
      ha = null,
      ca = null,
      eb = !1,
      Qb = !1,
      Sc = !1,
      sa = null,
      O = null,
      Tb = 0,
      Xc = -1,
      Fa = !1,
      ma = null,
      na = 0,
      Yc = !1,
      Ub = !1,
      Zc = null,
      fb = null,
      la = !1,
      Sb = !1,
      Ig = 1E3,
      Rb = 0,
      Lg = 1;return { computeAsyncExpiration: v, computeExpirationForFiber: y, scheduleWork: u, batchedUpdates: function batchedUpdates(a, b) {
      var c = la;la = !0;try {
        return a(b);
      } finally {
        (la = c) || Fa || w(1, null);
      }
    }, unbatchedUpdates: function unbatchedUpdates(a) {
      if (la && !Sb) {
        Sb = !0;try {
          return a();
        } finally {
          Sb = !1;
        }
      }return a();
    }, flushSync: function flushSync(a) {
      var b = la;la = !0;try {
        a: {
          var c = ka;ka = 1;try {
            var d = a();break a;
          } finally {
            ka = c;
          }d = void 0;
        }return d;
      } finally {
        la = b, Fa ? E("187") : void 0, w(1, null);
      }
    }, deferredUpdates: function deferredUpdates(a) {
      var b = ka;ka = v();try {
        return a();
      } finally {
        ka = b;
      }
    } };
}
function lf(a) {
  function b(a) {
    a = od(a);return null === a ? null : a.stateNode;
  }var c = a.getPublicInstance;a = kf(a);var d = a.computeAsyncExpiration,
      e = a.computeExpirationForFiber,
      f = a.scheduleWork;return { createContainer: function createContainer(a, b) {
      var c = new Y(3, null, 0);a = { current: c, containerInfo: a, pendingChildren: null, remainingExpirationTime: 0, isReadyForCommit: !1, finishedWork: null, context: null, pendingContext: null, hydrate: b, nextScheduledRoot: null };return c.stateNode = a;
    }, updateContainer: function updateContainer(a, b, c, q) {
      var g = b.current;if (c) {
        c = c._reactInternalFiber;var h;b: {
          2 === kd(c) && 2 === c.tag ? void 0 : E("170");for (h = c; 3 !== h.tag;) {
            if (le(h)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;break b;
            }(h = h["return"]) ? void 0 : E("171");
          }h = h.stateNode.context;
        }c = le(c) ? pe(c, h) : h;
      } else c = D;null === b.context ? b.context = c : b.pendingContext = c;b = q;b = void 0 === b ? null : b;q = null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent ? d() : e(g);He(g, { expirationTime: q, partialState: { element: a }, callback: b, isReplace: !1, isForced: !1,
        nextCallback: null, next: null });f(g, q);
    }, batchedUpdates: a.batchedUpdates, unbatchedUpdates: a.unbatchedUpdates, deferredUpdates: a.deferredUpdates, flushSync: a.flushSync, getPublicRootInstance: function getPublicRootInstance(a) {
      a = a.current;if (!a.child) return null;switch (a.child.tag) {case 5:
          return c(a.child.stateNode);default:
          return a.child.stateNode;}
    }, findHostInstance: b, findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {
      a = pd(a);return null === a ? null : a.stateNode;
    }, injectIntoDevTools: function injectIntoDevTools(a) {
      var c = a.findFiberByHostInstance;return Ce(B({}, a, { findHostInstanceByFiber: function findHostInstanceByFiber(a) {
          return b(a);
        }, findFiberByHostInstance: function findFiberByHostInstance(a) {
          return c ? c(a) : null;
        } }));
    } };
}var mf = Object.freeze({ default: lf }),
    nf = mf && lf || mf,
    of = nf["default"] ? nf["default"] : nf;function pf(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: Ue, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}var qf = "object" === (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" === typeof performance.now,
    rf = void 0;rf = qf ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
var sf = void 0,
    tf = void 0;
if (l.canUseDOM) {
  if ("function" !== typeof requestIdleCallback || "function" !== typeof cancelIdleCallback) {
    var uf = null,
        vf = !1,
        wf = -1,
        xf = !1,
        yf = 0,
        zf = 33,
        Af = 33,
        Bf;Bf = qf ? { didTimeout: !1, timeRemaining: function timeRemaining() {
        var a = yf - performance.now();return 0 < a ? a : 0;
      } } : { didTimeout: !1, timeRemaining: function timeRemaining() {
        var a = yf - Date.now();return 0 < a ? a : 0;
      } };var Cf = "__reactIdleCallback$" + Math.random().toString(36).slice(2);window.addEventListener("message", function (a) {
      if (a.source === window && a.data === Cf) {
        vf = !1;a = rf();if (0 >= yf - a) {
          if (-1 !== wf && wf <= a) Bf.didTimeout = !0;else {
            xf || (xf = !0, requestAnimationFrame(Df));return;
          }
        } else Bf.didTimeout = !1;wf = -1;a = uf;uf = null;null !== a && a(Bf);
      }
    }, !1);var Df = function Df(a) {
      xf = !1;var b = a - yf + Af;b < Af && zf < Af ? (8 > b && (b = 8), Af = b < zf ? zf : b) : zf = b;yf = a + Af;vf || (vf = !0, window.postMessage(Cf, "*"));
    };sf = function sf(a, b) {
      uf = a;null != b && "number" === typeof b.timeout && (wf = rf() + b.timeout);xf || (xf = !0, requestAnimationFrame(Df));return 0;
    };tf = function tf() {
      uf = null;vf = !1;wf = -1;
    };
  } else sf = window.requestIdleCallback, tf = window.cancelIdleCallback;
} else sf = function sf(a) {
  return setTimeout(function () {
    a({ timeRemaining: function timeRemaining() {
        return Infinity;
      } });
  });
}, tf = function tf(a) {
  clearTimeout(a);
};var Ef = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    Ff = {},
    Gf = {};
function Hf(a) {
  if (Gf.hasOwnProperty(a)) return !0;if (Ff.hasOwnProperty(a)) return !1;if (Ef.test(a)) return Gf[a] = !0;Ff[a] = !0;return !1;
}
function If(a, b, c) {
  var d = wa(b);if (d && va(b, c)) {
    var e = d.mutationMethod;e ? e(a, c) : null == c || d.hasBooleanValue && !c || d.hasNumericValue && isNaN(c) || d.hasPositiveNumericValue && 1 > c || d.hasOverloadedBooleanValue && !1 === c ? Jf(a, b) : d.mustUseProperty ? a[d.propertyName] = c : (b = d.attributeName, (e = d.attributeNamespace) ? a.setAttributeNS(e, b, "" + c) : d.hasBooleanValue || d.hasOverloadedBooleanValue && !0 === c ? a.setAttribute(b, "") : a.setAttribute(b, "" + c));
  } else Kf(a, b, va(b, c) ? c : null);
}
function Kf(a, b, c) {
  Hf(b) && (null == c ? a.removeAttribute(b) : a.setAttribute(b, "" + c));
}function Jf(a, b) {
  var c = wa(b);c ? (b = c.mutationMethod) ? b(a, void 0) : c.mustUseProperty ? a[c.propertyName] = c.hasBooleanValue ? !1 : "" : a.removeAttribute(c.attributeName) : a.removeAttribute(b);
}
function Lf(a, b) {
  var c = b.value,
      d = b.checked;return B({ type: void 0, step: void 0, min: void 0, max: void 0 }, b, { defaultChecked: void 0, defaultValue: void 0, value: null != c ? c : a._wrapperState.initialValue, checked: null != d ? d : a._wrapperState.initialChecked });
}function Mf(a, b) {
  var c = b.defaultValue;a._wrapperState = { initialChecked: null != b.checked ? b.checked : b.defaultChecked, initialValue: null != b.value ? b.value : c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function Nf(a, b) {
  b = b.checked;null != b && If(a, "checked", b);
}function Of(a, b) {
  Nf(a, b);var c = b.value;if (null != c) {
    if (0 === c && "" === a.value) a.value = "0";else if ("number" === b.type) {
      if (b = parseFloat(a.value) || 0, c != b || c == b && a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else null == b.value && null != b.defaultValue && a.defaultValue !== "" + b.defaultValue && (a.defaultValue = "" + b.defaultValue), null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function Pf(a, b) {
  switch (b.type) {case "submit":case "reset":
      break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":
      a.value = "";a.value = a.defaultValue;break;default:
      a.value = a.value;}b = a.name;"" !== b && (a.name = "");a.defaultChecked = !a.defaultChecked;a.defaultChecked = !a.defaultChecked;"" !== b && (a.name = b);
}function Qf(a) {
  var b = "";aa.Children.forEach(a, function (a) {
    null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
  });return b;
}
function Rf(a, b) {
  a = B({ children: void 0 }, b);if (b = Qf(b.children)) a.children = b;return a;
}function Sf(a, b, c, d) {
  a = a.options;if (b) {
    b = {};for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + c;b = null;for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;d && (a[e].defaultSelected = !0);return;
      }null !== b || a[e].disabled || (b = a[e]);
    }null !== b && (b.selected = !0);
  }
}
function Tf(a, b) {
  var c = b.value;a._wrapperState = { initialValue: null != c ? c : b.defaultValue, wasMultiple: !!b.multiple };
}function Uf(a, b) {
  null != b.dangerouslySetInnerHTML ? E("91") : void 0;return B({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}function Vf(a, b) {
  var c = b.value;null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? E("92") : void 0, Array.isArray(b) && (1 >= b.length ? void 0 : E("93"), b = b[0]), c = "" + b), null == c && (c = ""));a._wrapperState = { initialValue: "" + c };
}
function Wf(a, b) {
  var c = b.value;null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));null != b.defaultValue && (a.defaultValue = b.defaultValue);
}function Xf(a) {
  var b = a.textContent;b === a._wrapperState.initialValue && (a.value = b);
}var Yf = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function Zf(a) {
  switch (a) {case "svg":
      return "http://www.w3.org/2000/svg";case "math":
      return "http://www.w3.org/1998/Math/MathML";default:
      return "http://www.w3.org/1999/xhtml";}
}function $f(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? Zf(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var ag = void 0,
    bg = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== Yf.svg || "innerHTML" in a) a.innerHTML = b;else {
    ag = ag || document.createElement("div");ag.innerHTML = "\x3csvg\x3e" + b + "\x3c/svg\x3e";for (b = ag.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
});
function cg(a, b) {
  if (b) {
    var c = a.firstChild;if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;return;
    }
  }a.textContent = b;
}
var dg = { animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0,
  stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    eg = ["Webkit", "ms", "Moz", "O"];Object.keys(dg).forEach(function (a) {
  eg.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);dg[b] = dg[a];
  });
});
function fg(a, b) {
  a = a.style;for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--");var e = c;var f = b[c];e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || dg.hasOwnProperty(e) && dg[e] ? ("" + f).trim() : f + "px";"float" === c && (c = "cssFloat");d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}var gg = B({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function hg(a, b, c) {
  b && (gg[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? E("137", a, c()) : void 0), null != b.dangerouslySetInnerHTML && (null != b.children ? E("60") : void 0, "object" === _typeof(b.dangerouslySetInnerHTML) && "__html" in b.dangerouslySetInnerHTML ? void 0 : E("61")), null != b.style && "object" !== _typeof(b.style) ? E("62", c()) : void 0);
}
function ig(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;switch (a) {case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":
      return !1;default:
      return !0;}
}var jg = Yf.html,
    kg = C.thatReturns("");
function lg(a, b) {
  a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;var c = Hd(a);b = Sa[b];for (var d = 0; d < b.length; d++) {
    var e = b[d];c.hasOwnProperty(e) && c[e] || ("topScroll" === e ? wd("topScroll", "scroll", a) : "topFocus" === e || "topBlur" === e ? (wd("topFocus", "focus", a), wd("topBlur", "blur", a), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (yc("cancel", !0) && wd("topCancel", "cancel", a), c.topCancel = !0) : "topClose" === e ? (yc("close", !0) && wd("topClose", "close", a), c.topClose = !0) : Dd.hasOwnProperty(e) && U(e, Dd[e], a), c[e] = !0);
  }
}
var mg = { topAbort: "abort", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topLoadedData: "loadeddata", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topSeeked: "seeked", topSeeking: "seeking", topStalled: "stalled", topSuspend: "suspend", topTimeUpdate: "timeupdate", topVolumeChange: "volumechange",
  topWaiting: "waiting" };function ng(a, b, c, d) {
  c = 9 === c.nodeType ? c : c.ownerDocument;d === jg && (d = Zf(a));d === jg ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "\x3cscript\x3e\x3c/script\x3e", a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, { is: b.is }) : c.createElement(a) : a = c.createElementNS(d, a);return a;
}function og(a, b) {
  return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a);
}
function pg(a, b, c, d) {
  var e = ig(b, c);switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);var f = c;break;case "video":case "audio":
      for (f in mg) {
        mg.hasOwnProperty(f) && U(f, mg[f], a);
      }f = c;break;case "source":
      U("topError", "error", a);f = c;break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);f = c;break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);f = c;break;case "details":
      U("topToggle", "toggle", a);f = c;break;case "input":
      Mf(a, c);f = Lf(a, c);U("topInvalid", "invalid", a);
      lg(d, "onChange");break;case "option":
      f = Rf(a, c);break;case "select":
      Tf(a, c);f = B({}, c, { value: void 0 });U("topInvalid", "invalid", a);lg(d, "onChange");break;case "textarea":
      Vf(a, c);f = Uf(a, c);U("topInvalid", "invalid", a);lg(d, "onChange");break;default:
      f = c;}hg(b, f, kg);var g = f,
      h;for (h in g) {
    if (g.hasOwnProperty(h)) {
      var k = g[h];"style" === h ? fg(a, k, kg) : "dangerouslySetInnerHTML" === h ? (k = k ? k.__html : void 0, null != k && bg(a, k)) : "children" === h ? "string" === typeof k ? ("textarea" !== b || "" !== k) && cg(a, k) : "number" === typeof k && cg(a, "" + k) : "suppressContentEditableWarning" !== h && "suppressHydrationWarning" !== h && "autoFocus" !== h && (Ra.hasOwnProperty(h) ? null != k && lg(d, h) : e ? Kf(a, h, k) : null != k && If(a, h, k));
    }
  }switch (b) {case "input":
      Bc(a);Pf(a, c);break;case "textarea":
      Bc(a);Xf(a, c);break;case "option":
      null != c.value && a.setAttribute("value", c.value);break;case "select":
      a.multiple = !!c.multiple;b = c.value;null != b ? Sf(a, !!c.multiple, b, !1) : null != c.defaultValue && Sf(a, !!c.multiple, c.defaultValue, !0);break;default:
      "function" === typeof f.onClick && (a.onclick = C);}
}
function sg(a, b, c, d, e) {
  var f = null;switch (b) {case "input":
      c = Lf(a, c);d = Lf(a, d);f = [];break;case "option":
      c = Rf(a, c);d = Rf(a, d);f = [];break;case "select":
      c = B({}, c, { value: void 0 });d = B({}, d, { value: void 0 });f = [];break;case "textarea":
      c = Uf(a, c);d = Uf(a, d);f = [];break;default:
      "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = C);}hg(b, d, kg);var g, h;a = null;for (g in c) {
    if (!d.hasOwnProperty(g) && c.hasOwnProperty(g) && null != c[g]) if ("style" === g) for (h in b = c[g], b) {
      b.hasOwnProperty(h) && (a || (a = {}), a[h] = "");
    } else "dangerouslySetInnerHTML" !== g && "children" !== g && "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && "autoFocus" !== g && (Ra.hasOwnProperty(g) ? f || (f = []) : (f = f || []).push(g, null));
  }for (g in d) {
    var k = d[g];b = null != c ? c[g] : void 0;if (d.hasOwnProperty(g) && k !== b && (null != k || null != b)) if ("style" === g) {
      if (b) {
        for (h in b) {
          !b.hasOwnProperty(h) || k && k.hasOwnProperty(h) || (a || (a = {}), a[h] = "");
        }for (h in k) {
          k.hasOwnProperty(h) && b[h] !== k[h] && (a || (a = {}), a[h] = k[h]);
        }
      } else a || (f || (f = []), f.push(g, a)), a = k;
    } else "dangerouslySetInnerHTML" === g ? (k = k ? k.__html : void 0, b = b ? b.__html : void 0, null != k && b !== k && (f = f || []).push(g, "" + k)) : "children" === g ? b === k || "string" !== typeof k && "number" !== typeof k || (f = f || []).push(g, "" + k) : "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && (Ra.hasOwnProperty(g) ? (null != k && lg(e, g), f || b === k || (f = [])) : (f = f || []).push(g, k));
  }a && (f = f || []).push("style", a);return f;
}
function tg(a, b, c, d, e) {
  "input" === c && "radio" === e.type && null != e.name && Nf(a, e);ig(c, d);d = ig(c, e);for (var f = 0; f < b.length; f += 2) {
    var g = b[f],
        h = b[f + 1];"style" === g ? fg(a, h, kg) : "dangerouslySetInnerHTML" === g ? bg(a, h) : "children" === g ? cg(a, h) : d ? null != h ? Kf(a, g, h) : a.removeAttribute(g) : null != h ? If(a, g, h) : Jf(a, g);
  }switch (c) {case "input":
      Of(a, e);break;case "textarea":
      Wf(a, e);break;case "select":
      a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, c = e.value, null != c ? Sf(a, !!e.multiple, c, !1) : b !== !!e.multiple && (null != e.defaultValue ? Sf(a, !!e.multiple, e.defaultValue, !0) : Sf(a, !!e.multiple, e.multiple ? [] : "", !1));}
}
function ug(a, b, c, d, e) {
  switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);break;case "video":case "audio":
      for (var f in mg) {
        mg.hasOwnProperty(f) && U(f, mg[f], a);
      }break;case "source":
      U("topError", "error", a);break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);break;case "details":
      U("topToggle", "toggle", a);break;case "input":
      Mf(a, c);U("topInvalid", "invalid", a);lg(e, "onChange");break;case "select":
      Tf(a, c);
      U("topInvalid", "invalid", a);lg(e, "onChange");break;case "textarea":
      Vf(a, c), U("topInvalid", "invalid", a), lg(e, "onChange");}hg(b, c, kg);d = null;for (var g in c) {
    c.hasOwnProperty(g) && (f = c[g], "children" === g ? "string" === typeof f ? a.textContent !== f && (d = ["children", f]) : "number" === typeof f && a.textContent !== "" + f && (d = ["children", "" + f]) : Ra.hasOwnProperty(g) && null != f && lg(e, g));
  }switch (b) {case "input":
      Bc(a);Pf(a, c);break;case "textarea":
      Bc(a);Xf(a, c);break;case "select":case "option":
      break;default:
      "function" === typeof c.onClick && (a.onclick = C);}return d;
}function vg(a, b) {
  return a.nodeValue !== b;
}
var wg = Object.freeze({ createElement: ng, createTextNode: og, setInitialProperties: pg, diffProperties: sg, updateProperties: tg, diffHydratedProperties: ug, diffHydratedText: vg, warnForUnmatchedText: function warnForUnmatchedText() {}, warnForDeletedHydratableElement: function warnForDeletedHydratableElement() {}, warnForDeletedHydratableText: function warnForDeletedHydratableText() {}, warnForInsertedHydratedElement: function warnForInsertedHydratedElement() {}, warnForInsertedHydratedText: function warnForInsertedHydratedText() {}, restoreControlledState: function restoreControlledState(a, b, c) {
    switch (b) {case "input":
        Of(a, c);b = c.name;if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode;) {
            c = c.parentNode;
          }c = c.querySelectorAll("input[name\x3d" + JSON.stringify("" + b) + '][type\x3d"radio"]');for (b = 0; b < c.length; b++) {
            var d = c[b];if (d !== a && d.form === a.form) {
              var e = rb(d);e ? void 0 : E("90");Cc(d);Of(d, e);
            }
          }
        }break;case "textarea":
        Wf(a, c);break;case "select":
        b = c.value, null != b && Sf(a, !!c.multiple, b, !1);}
  } });nc.injectFiberControlledHostComponent(wg);var xg = null,
    Mg = null;function Ng(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function Og(a) {
  a = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null;return !(!a || 1 !== a.nodeType || !a.hasAttribute("data-reactroot"));
}
var Z = of({ getRootHostContext: function getRootHostContext(a) {
    var b = a.nodeType;switch (b) {case 9:case 11:
        a = (a = a.documentElement) ? a.namespaceURI : $f(null, "");break;default:
        b = 8 === b ? a.parentNode : a, a = b.namespaceURI || null, b = b.tagName, a = $f(a, b);}return a;
  }, getChildHostContext: function getChildHostContext(a, b) {
    return $f(a, b);
  }, getPublicInstance: function getPublicInstance(a) {
    return a;
  }, prepareForCommit: function prepareForCommit() {
    xg = td;var a = da();if (Kd(a)) {
      if ("selectionStart" in a) var b = { start: a.selectionStart, end: a.selectionEnd };else a: {
        var c = window.getSelection && window.getSelection();
        if (c && 0 !== c.rangeCount) {
          b = c.anchorNode;var d = c.anchorOffset,
              e = c.focusNode;c = c.focusOffset;try {
            b.nodeType, e.nodeType;
          } catch (z) {
            b = null;break a;
          }var f = 0,
              g = -1,
              h = -1,
              k = 0,
              q = 0,
              v = a,
              y = null;b: for (;;) {
            for (var u;;) {
              v !== b || 0 !== d && 3 !== v.nodeType || (g = f + d);v !== e || 0 !== c && 3 !== v.nodeType || (h = f + c);3 === v.nodeType && (f += v.nodeValue.length);if (null === (u = v.firstChild)) break;y = v;v = u;
            }for (;;) {
              if (v === a) break b;y === b && ++k === d && (g = f);y === e && ++q === c && (h = f);if (null !== (u = v.nextSibling)) break;v = y;y = v.parentNode;
            }v = u;
          }b = -1 === g || -1 === h ? null : { start: g, end: h };
        } else b = null;
      }b = b || { start: 0, end: 0 };
    } else b = null;Mg = { focusedElem: a, selectionRange: b };ud(!1);
  }, resetAfterCommit: function resetAfterCommit() {
    var a = Mg,
        b = da(),
        c = a.focusedElem,
        d = a.selectionRange;if (b !== c && fa(document.documentElement, c)) {
      if (Kd(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (window.getSelection) {
        b = window.getSelection();var e = c[Eb()].length;a = Math.min(d.start, e);d = void 0 === d.end ? a : Math.min(d.end, e);!b.extend && a > d && (e = d, d = a, a = e);e = Jd(c, a);var f = Jd(c, d);if (e && f && (1 !== b.rangeCount || b.anchorNode !== e.node || b.anchorOffset !== e.offset || b.focusNode !== f.node || b.focusOffset !== f.offset)) {
          var g = document.createRange();g.setStart(e.node, e.offset);b.removeAllRanges();a > d ? (b.addRange(g), b.extend(f.node, f.offset)) : (g.setEnd(f.node, f.offset), b.addRange(g));
        }
      }b = [];for (a = c; a = a.parentNode;) {
        1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      }ia(c);for (c = 0; c < b.length; c++) {
        a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }Mg = null;ud(xg);xg = null;
  }, createInstance: function createInstance(a, b, c, d, e) {
    a = ng(a, b, c, d);a[Q] = e;a[ob] = b;return a;
  }, appendInitialChild: function appendInitialChild(a, b) {
    a.appendChild(b);
  }, finalizeInitialChildren: function finalizeInitialChildren(a, b, c, d) {
    pg(a, b, c, d);a: {
      switch (b) {case "button":case "input":case "select":case "textarea":
          a = !!c.autoFocus;break a;}a = !1;
    }return a;
  }, prepareUpdate: function prepareUpdate(a, b, c, d, e) {
    return sg(a, b, c, d, e);
  }, shouldSetTextContent: function shouldSetTextContent(a, b) {
    return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
  }, shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(a, b) {
    return !!b.hidden;
  }, createTextInstance: function createTextInstance(a, b, c, d) {
    a = og(a, b);a[Q] = d;return a;
  }, now: rf, mutation: { commitMount: function commitMount(a) {
      a.focus();
    }, commitUpdate: function commitUpdate(a, b, c, d, e) {
      a[ob] = e;tg(a, b, c, d, e);
    }, resetTextContent: function resetTextContent(a) {
      a.textContent = "";
    }, commitTextUpdate: function commitTextUpdate(a, b, c) {
      a.nodeValue = c;
    }, appendChild: function appendChild(a, b) {
      a.appendChild(b);
    }, appendChildToContainer: function appendChildToContainer(a, b) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
    }, insertBefore: function insertBefore(a, b, c) {
      a.insertBefore(b, c);
    }, insertInContainerBefore: function insertInContainerBefore(a, b, c) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
    }, removeChild: function removeChild(a, b) {
      a.removeChild(b);
    }, removeChildFromContainer: function removeChildFromContainer(a, b) {
      8 === a.nodeType ? a.parentNode.removeChild(b) : a.removeChild(b);
    } }, hydration: { canHydrateInstance: function canHydrateInstance(a, b) {
      return 1 !== a.nodeType || b.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
    }, canHydrateTextInstance: function canHydrateTextInstance(a, b) {
      return "" === b || 3 !== a.nodeType ? null : a;
    }, getNextHydratableSibling: function getNextHydratableSibling(a) {
      for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, getFirstHydratableChild: function getFirstHydratableChild(a) {
      for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, hydrateInstance: function hydrateInstance(a, b, c, d, e, f) {
      a[Q] = f;a[ob] = c;return ug(a, b, c, e, d);
    }, hydrateTextInstance: function hydrateTextInstance(a, b, c) {
      a[Q] = c;return vg(a, b);
    }, didNotMatchHydratedContainerTextInstance: function didNotMatchHydratedContainerTextInstance() {}, didNotMatchHydratedTextInstance: function didNotMatchHydratedTextInstance() {},
    didNotHydrateContainerInstance: function didNotHydrateContainerInstance() {}, didNotHydrateInstance: function didNotHydrateInstance() {}, didNotFindHydratableContainerInstance: function didNotFindHydratableContainerInstance() {}, didNotFindHydratableContainerTextInstance: function didNotFindHydratableContainerTextInstance() {}, didNotFindHydratableInstance: function didNotFindHydratableInstance() {}, didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance() {} }, scheduleDeferredCallback: sf, cancelDeferredCallback: tf, useSyncScheduling: !0 });rc = Z.batchedUpdates;
function Pg(a, b, c, d, e) {
  Ng(c) ? void 0 : E("200");var f = c._reactRootContainer;if (f) Z.updateContainer(b, f, a, e);else {
    d = d || Og(c);if (!d) for (f = void 0; f = c.lastChild;) {
      c.removeChild(f);
    }var g = Z.createContainer(c, d);f = c._reactRootContainer = g;Z.unbatchedUpdates(function () {
      Z.updateContainer(b, g, a, e);
    });
  }return Z.getPublicRootInstance(f);
}function Qg(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;Ng(b) ? void 0 : E("200");return pf(a, b, null, c);
}
function Rg(a, b) {
  this._reactRootContainer = Z.createContainer(a, b);
}Rg.prototype.render = function (a, b) {
  Z.updateContainer(a, this._reactRootContainer, null, b);
};Rg.prototype.unmount = function (a) {
  Z.updateContainer(null, this._reactRootContainer, null, a);
};
var Sg = { createPortal: Qg, findDOMNode: function findDOMNode(a) {
    if (null == a) return null;if (1 === a.nodeType) return a;var b = a._reactInternalFiber;if (b) return Z.findHostInstance(b);"function" === typeof a.render ? E("188") : E("213", Object.keys(a));
  }, hydrate: function hydrate(a, b, c) {
    return Pg(null, a, b, !0, c);
  }, render: function render(a, b, c) {
    return Pg(null, a, b, !1, c);
  }, unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(a, b, c, d) {
    null == a || void 0 === a._reactInternalFiber ? E("38") : void 0;return Pg(a, b, c, !1, d);
  }, unmountComponentAtNode: function unmountComponentAtNode(a) {
    Ng(a) ? void 0 : E("40");return a._reactRootContainer ? (Z.unbatchedUpdates(function () {
      Pg(null, null, a, !1, function () {
        a._reactRootContainer = null;
      });
    }), !0) : !1;
  }, unstable_createPortal: Qg, unstable_batchedUpdates: tc, unstable_deferredUpdates: Z.deferredUpdates, flushSync: Z.flushSync, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { EventPluginHub: mb, EventPluginRegistry: Va, EventPropagators: Cb, ReactControlledComponent: qc, ReactDOMComponentTree: sb, ReactDOMEventListener: xd } };
Z.injectIntoDevTools({ findFiberByHostInstance: pb, bundleType: 0, version: "16.2.0", rendererPackageName: "react-dom" });var Tg = Object.freeze({ default: Sg }),
    Ug = Tg && Sg || Tg;module.exports = Ug["default"] ? Ug["default"] : Ug;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(48);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};if(process.env.NODE_ENV!=="production"){(function(){'use strict';var React=__webpack_require__(0);var invariant=__webpack_require__(8);var warning=__webpack_require__(12);var ExecutionEnvironment=__webpack_require__(23);var _assign=__webpack_require__(7);var emptyFunction=__webpack_require__(6);var EventListener=__webpack_require__(24);var getActiveElement=__webpack_require__(25);var shallowEqual=__webpack_require__(26);var containsNode=__webpack_require__(27);var focusNode=__webpack_require__(28);var emptyObject=__webpack_require__(11);var checkPropTypes=__webpack_require__(14);var hyphenateStyleName=__webpack_require__(50);var camelizeStyleName=__webpack_require__(52);/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS={children:true,dangerouslySetInnerHTML:true,defaultValue:true,defaultChecked:true,innerHTML:true,suppressContentEditableWarning:true,suppressHydrationWarning:true,style:true};function checkMask(value,bitmask){return(value&bitmask)===bitmask;}var DOMPropertyInjection={/**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */MUST_USE_PROPERTY:0x1,HAS_BOOLEAN_VALUE:0x4,HAS_NUMERIC_VALUE:0x8,HAS_POSITIVE_NUMERIC_VALUE:0x10|0x8,HAS_OVERLOADED_BOOLEAN_VALUE:0x20,HAS_STRING_BOOLEAN_VALUE:0x40,/**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */injectDOMPropertyConfig:function injectDOMPropertyConfig(domPropertyConfig){var Injection=DOMPropertyInjection;var Properties=domPropertyConfig.Properties||{};var DOMAttributeNamespaces=domPropertyConfig.DOMAttributeNamespaces||{};var DOMAttributeNames=domPropertyConfig.DOMAttributeNames||{};var DOMMutationMethods=domPropertyConfig.DOMMutationMethods||{};for(var propName in Properties){!!properties.hasOwnProperty(propName)?invariant(false,"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",propName):void 0;var lowerCased=propName.toLowerCase();var propConfig=Properties[propName];var propertyInfo={attributeName:lowerCased,attributeNamespace:null,propertyName:propName,mutationMethod:null,mustUseProperty:checkMask(propConfig,Injection.MUST_USE_PROPERTY),hasBooleanValue:checkMask(propConfig,Injection.HAS_BOOLEAN_VALUE),hasNumericValue:checkMask(propConfig,Injection.HAS_NUMERIC_VALUE),hasPositiveNumericValue:checkMask(propConfig,Injection.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:checkMask(propConfig,Injection.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:checkMask(propConfig,Injection.HAS_STRING_BOOLEAN_VALUE)};!(propertyInfo.hasBooleanValue+propertyInfo.hasNumericValue+propertyInfo.hasOverloadedBooleanValue<=1)?invariant(false,"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s",propName):void 0;if(DOMAttributeNames.hasOwnProperty(propName)){var attributeName=DOMAttributeNames[propName];propertyInfo.attributeName=attributeName;}if(DOMAttributeNamespaces.hasOwnProperty(propName)){propertyInfo.attributeNamespace=DOMAttributeNamespaces[propName];}if(DOMMutationMethods.hasOwnProperty(propName)){propertyInfo.mutationMethod=DOMMutationMethods[propName];}// Downcase references to whitelist properties to check for membership
// without case-sensitivity. This allows the whitelist to pick up
// `allowfullscreen`, which should be written using the property configuration
// for `allowFullscreen`
properties[propName]=propertyInfo;}}};/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */var properties={};/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */function shouldSetAttribute(name,value){if(isReservedProp(name)){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return false;}if(value===null){return true;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':return shouldAttributeAcceptBooleanValue(name);case'undefined':case'number':case'string':case'object':return true;default:// function, symbol
return false;}}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function shouldAttributeAcceptBooleanValue(name){if(isReservedProp(name)){return true;}var propertyInfo=getPropertyInfo(name);if(propertyInfo){return propertyInfo.hasBooleanValue||propertyInfo.hasStringBooleanValue||propertyInfo.hasOverloadedBooleanValue;}var prefix=name.toLowerCase().slice(0,5);return prefix==='data-'||prefix==='aria-';}/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */function isReservedProp(name){return RESERVED_PROPS.hasOwnProperty(name);}var injection=DOMPropertyInjection;var MUST_USE_PROPERTY=injection.MUST_USE_PROPERTY;var HAS_BOOLEAN_VALUE=injection.HAS_BOOLEAN_VALUE;var HAS_NUMERIC_VALUE=injection.HAS_NUMERIC_VALUE;var HAS_POSITIVE_NUMERIC_VALUE=injection.HAS_POSITIVE_NUMERIC_VALUE;var HAS_OVERLOADED_BOOLEAN_VALUE=injection.HAS_OVERLOADED_BOOLEAN_VALUE;var HAS_STRING_BOOLEAN_VALUE=injection.HAS_STRING_BOOLEAN_VALUE;var HTMLDOMPropertyConfig={// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
Properties:{allowFullScreen:HAS_BOOLEAN_VALUE,// specifies target context for links with `preload` type
async:HAS_BOOLEAN_VALUE,// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
autoFocus:HAS_BOOLEAN_VALUE,autoPlay:HAS_BOOLEAN_VALUE,capture:HAS_OVERLOADED_BOOLEAN_VALUE,checked:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,cols:HAS_POSITIVE_NUMERIC_VALUE,contentEditable:HAS_STRING_BOOLEAN_VALUE,controls:HAS_BOOLEAN_VALUE,'default':HAS_BOOLEAN_VALUE,defer:HAS_BOOLEAN_VALUE,disabled:HAS_BOOLEAN_VALUE,download:HAS_OVERLOADED_BOOLEAN_VALUE,draggable:HAS_STRING_BOOLEAN_VALUE,formNoValidate:HAS_BOOLEAN_VALUE,hidden:HAS_BOOLEAN_VALUE,loop:HAS_BOOLEAN_VALUE,// Caution; `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`.
multiple:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,muted:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,noValidate:HAS_BOOLEAN_VALUE,open:HAS_BOOLEAN_VALUE,playsInline:HAS_BOOLEAN_VALUE,readOnly:HAS_BOOLEAN_VALUE,required:HAS_BOOLEAN_VALUE,reversed:HAS_BOOLEAN_VALUE,rows:HAS_POSITIVE_NUMERIC_VALUE,rowSpan:HAS_NUMERIC_VALUE,scoped:HAS_BOOLEAN_VALUE,seamless:HAS_BOOLEAN_VALUE,selected:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,size:HAS_POSITIVE_NUMERIC_VALUE,start:HAS_NUMERIC_VALUE,// support for projecting regular DOM Elements via V1 named slots ( shadow dom )
span:HAS_POSITIVE_NUMERIC_VALUE,spellCheck:HAS_STRING_BOOLEAN_VALUE,// Style must be explicitly set in the attribute list. React components
// expect a style object
style:0,// Keep it in the whitelist because it is case-sensitive for SVG.
tabIndex:0,// itemScope is for for Microdata support.
// See http://schema.org/docs/gs.html
itemScope:HAS_BOOLEAN_VALUE,// These attributes must stay in the white-list because they have
// different attribute names (see DOMAttributeNames below)
acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,// Attributes with mutation methods must be specified in the whitelist
// Set the string boolean flag to allow the behavior
value:HAS_STRING_BOOLEAN_VALUE},DOMAttributeNames:{acceptCharset:'accept-charset',className:'class',htmlFor:'for',httpEquiv:'http-equiv'},DOMMutationMethods:{value:function value(node,_value){if(_value==null){return node.removeAttribute('value');}// Number inputs get special treatment due to some edge cases in
// Chrome. Let everything else assign the value attribute as normal.
// https://github.com/facebook/react/issues/7253#issuecomment-236074326
if(node.type!=='number'||node.hasAttribute('value')===false){node.setAttribute('value',''+_value);}else if(node.validity&&!node.validity.badInput&&node.ownerDocument.activeElement!==node){// Don't assign an attribute if validation reports bad
// input. Chrome will clear the value. Additionally, don't
// operate on inputs that have focus, otherwise Chrome might
// strip off trailing decimal places and cause the user's
// cursor position to jump to the beginning of the input.
//
// In ReactDOMInput, we have an onBlur event that will trigger
// this function again when focus is lost.
node.setAttribute('value',''+_value);}}}};var HAS_STRING_BOOLEAN_VALUE$1=injection.HAS_STRING_BOOLEAN_VALUE;var NS={xlink:'http://www.w3.org/1999/xlink',xml:'http://www.w3.org/XML/1998/namespace'};/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */var ATTRS=['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','x-height','xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type','xml:base','xmlns:xlink','xml:lang','xml:space'];var SVGDOMPropertyConfig={Properties:{autoReverse:HAS_STRING_BOOLEAN_VALUE$1,externalResourcesRequired:HAS_STRING_BOOLEAN_VALUE$1,preserveAlpha:HAS_STRING_BOOLEAN_VALUE$1},DOMAttributeNames:{autoReverse:'autoReverse',externalResourcesRequired:'externalResourcesRequired',preserveAlpha:'preserveAlpha'},DOMAttributeNamespaces:{xlinkActuate:NS.xlink,xlinkArcrole:NS.xlink,xlinkHref:NS.xlink,xlinkRole:NS.xlink,xlinkShow:NS.xlink,xlinkTitle:NS.xlink,xlinkType:NS.xlink,xmlBase:NS.xml,xmlLang:NS.xml,xmlSpace:NS.xml}};var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};ATTRS.forEach(function(original){var reactName=original.replace(CAMELIZE,capitalize);SVGDOMPropertyConfig.Properties[reactName]=0;SVGDOMPropertyConfig.DOMAttributeNames[reactName]=original;});injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);var ReactErrorUtils={// Used by Fiber to simulate a try-catch.
_caughtError:null,_hasCaughtError:false,// Used by event system to capture/rethrow the first error.
_rethrowError:null,_hasRethrowError:false,injection:{injectErrorUtils:function injectErrorUtils(injectedErrorUtils){!(typeof injectedErrorUtils.invokeGuardedCallback==='function')?invariant(false,'Injected invokeGuardedCallback() must be a function.'):void 0;_invokeGuardedCallback=injectedErrorUtils.invokeGuardedCallback;}},/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallback:function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){_invokeGuardedCallback.apply(ReactErrorUtils,arguments);},/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallbackAndCatchFirstError:function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){ReactErrorUtils.invokeGuardedCallback.apply(this,arguments);if(ReactErrorUtils.hasCaughtError()){var error=ReactErrorUtils.clearCaughtError();if(!ReactErrorUtils._hasRethrowError){ReactErrorUtils._hasRethrowError=true;ReactErrorUtils._rethrowError=error;}}},/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */rethrowCaughtError:function rethrowCaughtError(){return _rethrowCaughtError.apply(ReactErrorUtils,arguments);},hasCaughtError:function hasCaughtError(){return ReactErrorUtils._hasCaughtError;},clearCaughtError:function clearCaughtError(){if(ReactErrorUtils._hasCaughtError){var error=ReactErrorUtils._caughtError;ReactErrorUtils._caughtError=null;ReactErrorUtils._hasCaughtError=false;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}};var _invokeGuardedCallback=function _invokeGuardedCallback(name,func,context,a,b,c,d,e,f){ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){ReactErrorUtils._caughtError=error;ReactErrorUtils._hasCaughtError=true;}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// untintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function onError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',onError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
var evt=document.createEvent('Event');evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}ReactErrorUtils._hasCaughtError=true;ReactErrorUtils._caughtError=error;}else{ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;}// Remove our event listeners
window.removeEventListener('error',onError);};_invokeGuardedCallback=invokeGuardedCallbackDev;}}var _rethrowCaughtError=function _rethrowCaughtError(){if(ReactErrorUtils._hasRethrowError){var error=ReactErrorUtils._rethrowError;ReactErrorUtils._rethrowError=null;ReactErrorUtils._hasRethrowError=false;throw error;}};/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 *//**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var EventPluginRegistry=Object.freeze({plugins:plugins,eventNameDispatchConfigs:eventNameDispatchConfigs,registrationNameModules:registrationNameModules,registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames,injectEventPluginOrder:injectEventPluginOrder,injectEventPluginsByName:injectEventPluginsByName});var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;var injection$2={injectComponentTree:function injectComponentTree(Injected){getFiberCurrentPropsFromNode=Injected.getFiberCurrentPropsFromNode;getInstanceFromNode=Injected.getInstanceFromNode;getNodeFromInstance=Injected.getNodeFromInstance;{warning(getNodeFromInstance&&getInstanceFromNode,'EventPluginUtils.injection.injectComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.');}}};var validateEventDispatches;{validateEventDispatches=function validateEventDispatches(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;warning(instancesIsArr===listenersIsArr&&instancesLen===listenersLen,'EventPluginUtils: Invalid `event`.');};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 *//**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 *//**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 *//**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */var executeDispatchesAndRelease=function executeDispatchesAndRelease(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function executeDispatchesAndReleaseSimulated(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function executeDispatchesAndReleaseTopLevel(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 *//**
 * Methods for injecting dependencies.
 */var injection$1={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener)):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */function enqueueEvents(events){if(events){eventQueue=accumulateInto(eventQueue,events);}}/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */function processEventQueue(simulated){// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
ReactErrorUtils.rethrowCaughtError();}var EventPluginHub=Object.freeze({injection:injection$1,getListener:getListener,extractEvents:extractEvents,enqueueEvents:enqueueEvents,processEventQueue:processEventQueue});var IndeterminateComponent=0;// Before we know whether it is functional or class
var FunctionalComponent=1;var ClassComponent=2;var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var CallComponent=7;var CallHandlerPhase=8;var ReturnComponent=9;var Fragment=10;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode$1(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}// Walk up the tree until we find an ancestor whose instance we have cached.
var parents=[];while(!node[internalInstanceKey]){parents.push(node);if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var closest=void 0;var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}for(;node&&(inst=node[internalInstanceKey]);node=parents.pop()){closest=inst;}return closest;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps$1(node,props){node[internalEventHandlersKey]=props;}var ReactDOMComponentTree=Object.freeze({precacheFiberNode:precacheFiberNode$1,getClosestInstanceFromNode:getClosestInstanceFromNode,getInstanceFromNode:getInstanceFromNode$1,getNodeFromInstance:getNodeFromInstance$1,getFiberCurrentPropsFromNode:getFiberCurrentPropsFromNode$1,updateFiberProps:updateFiberProps$1});function getParent(inst){do{inst=inst['return'];// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 *//**
 * Return the parent instance of the passed-in instance.
 */function getParentInstance(inst){return getParent(inst);}/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 *//**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{warning(inst,'Dispatching inst must not be null');}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;var parentInst=targetInst?getParentInstance(targetInst):null;traverseTwoPhase(parentInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateTwoPhaseDispatchesSkipTarget(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingleSkipTarget);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var EventPropagators=Object.freeze({accumulateTwoPhaseDispatches:accumulateTwoPhaseDispatches,accumulateTwoPhaseDispatchesSkipTarget:accumulateTwoPhaseDispatchesSkipTarget,accumulateEnterLeaveDispatches:accumulateEnterLeaveDispatches,accumulateDirectDispatches:accumulateDirectDispatches});var contentKey=null;/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */function getTextContentAccessor(){if(!contentKey&&ExecutionEnvironment.canUseDOM){// Prefer textContent to innerText because many browsers support both but
// SVG <text> elements don't support innerText even when <div> does.
contentKey='textContent'in document.documentElement?'textContent':'innerText';}return contentKey;}/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var compositionState={_root:null,_startText:null,_fallbackText:null};function initialize(nativeEventTarget){compositionState._root=nativeEventTarget;compositionState._startText=getText();return true;}function reset(){compositionState._root=null;compositionState._startText=null;compositionState._fallbackText=null;}function getData(){if(compositionState._fallbackText){return compositionState._fallbackText;}var start;var startValue=compositionState._startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;compositionState._fallbackText=endValue.slice(start,sliceTail);return compositionState._fallbackText;}function getText(){if('value'in compositionState._root){return compositionState._root.value;}return compositionState._root[getTextContentAccessor()];}/* eslint valid-typeof: 0 */var didWarnForAddedNewProperty=false;var isProxySupported=typeof Proxy==='function';var EVENT_POOL_SIZE=10;var shouldBeReleasedProperties=['dispatchConfig','_targetInst','nativeEvent','isDefaultPrevented','isPropagationStopped','_dispatchListeners','_dispatchInstances'];/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:emptyFunction.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=emptyFunction.thatReturnsTrue;}else{this.isDefaultPrevented=emptyFunction.thatReturnsFalse;}this.isPropagationStopped=emptyFunction.thatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=emptyFunction.thatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=emptyFunction.thatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function persist(){this.isPersistent=emptyFunction.thatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:emptyFunction.thatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function destructor(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}for(var i=0;i<shouldBeReleasedProperties.length;i++){this[shouldBeReleasedProperties[i]]=null;}{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',emptyFunction));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',emptyFunction));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */SyntheticEvent.augmentClass=function(Class,Interface){var Super=this;var E=function E(){};E.prototype=Super.prototype;var prototype=new E();_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.augmentClass=Super.augmentClass;addEventPoolingTo(Class);};/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */{if(isProxySupported){/*eslint-disable no-func-assign */SyntheticEvent=new Proxy(SyntheticEvent,{construct:function construct(target,args){return this.apply(target,Object.create(target.prototype),args);},apply:function apply(constructor,that,args){return new Proxy(constructor.apply(that,args),{set:function set(target,prop,value){if(prop!=='isPersistent'&&!target.constructor.Interface.hasOwnProperty(prop)&&shouldBeReleasedProperties.indexOf(prop)===-1){warning(didWarnForAddedNewProperty||target.isPersistent(),"This synthetic event is reused for performance reasons. If you're "+"seeing this, you're adding a new property in the synthetic event object. "+'The property is never released. See '+'https://fb.me/react-event-pooling for more information.');didWarnForAddedNewProperty=true;}target[prop]=value;return true;}});}});/*eslint-enable no-func-assign */}}addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;warning(warningCondition,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result);}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance  into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}var SyntheticEvent$1=SyntheticEvent;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticCompositionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticCompositionEvent,CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var InputEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticInputEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticInputEvent,InputEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=ExecutionEnvironment.canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(ExecutionEnvironment.canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=ExecutionEnvironment.canUseDOM&&'TextEvent'in window&&!documentMode&&!isPresto();// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=ExecutionEnvironment.canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */function isPresto(){var opera=window.opera;return(typeof opera==='undefined'?'undefined':_typeof(opera))==='object'&&typeof opera.version==='function'&&parseInt(opera.version(),10)<=12;}var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:['topCompositionEnd','topKeyPress','topTextInput','topPaste']},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:['topBlur','topCompositionEnd','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:['topBlur','topCompositionStart','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:['topBlur','topCompositionUpdate','topKeyDown','topKeyPress','topKeyUp','topMouseDown']}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case'topCompositionStart':return eventTypes.compositionStart;case'topCompositionEnd':return eventTypes.compositionEnd;case'topCompositionUpdate':return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType==='topKeyDown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case'topKeyUp':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'topKeyDown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'topKeyPress':case'topMouseDown':case'topBlur':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case'topCompositionEnd':return getDataFromCustomEvent(nativeEvent);case'topKeyPress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'topTextInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to blacklist it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType==='topCompositionEnd'||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case'topPaste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'topKeyPress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'topCompositionEnd':return useFallbackCompositionData?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){return[extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget),extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget)];}};// Use to restore controlled state after a change event has fired.
var fiberHostComponent=null;var ReactControlledComponentInjection={injectFiberControlledHostComponent:function injectFiberControlledHostComponent(hostComponentImpl){// The fiber implementation doesn't use dynamic dispatch so we need to
// inject the implementation.
fiberHostComponent=hostComponentImpl;}};var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(fiberHostComponent&&typeof fiberHostComponent.restoreControlledState==='function')?invariant(false,'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);fiberHostComponent.restoreControlledState(internalInstance.stateNode,internalInstance.type,props);}var injection$3=ReactControlledComponentInjection;function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var ReactControlledComponent=Object.freeze({injection:injection$3,enqueueStateRestore:enqueueStateRestore,restoreStateIfNeeded:restoreStateIfNeeded});// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var fiberBatchedUpdates=function fiberBatchedUpdates(fn,bookkeeping){return fn(bookkeeping);};var isNestingBatched=false;function batchedUpdates(fn,bookkeeping){if(isNestingBatched){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state. Therefore, we add the target to
// a queue of work.
return fiberBatchedUpdates(fn,bookkeeping);}isNestingBatched=true;try{return fiberBatchedUpdates(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isNestingBatched=false;restoreStateIfNeeded();}}var ReactGenericBatchingInjection={injectFiberBatchedUpdates:function injectFiberBatchedUpdates(_batchedUpdates){fiberBatchedUpdates=_batchedUpdates;}};var injection$4=ReactGenericBatchingInjection;/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var useHasFeature;if(ExecutionEnvironment.canUseDOM){useHasFeature=document.implementation&&document.implementation.hasFeature&&// always returns true in newer browsers as per the standard.
// @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
document.implementation.hasFeature('','')!==true;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix,capture){if(!ExecutionEnvironment.canUseDOM||capture&&!('addEventListener'in document)){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}if(!isSupported&&useHasFeature&&eventNameSuffix==='wheel'){// This is the only way to test support for the `wheel` event in IE9+.
isSupported=document.implementation.hasFeature('Events.wheel','3.0');}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable,configurable:true,get:function get(){return descriptor.get.call(this);},set:function set(value){currentValue=''+value;descriptor.set.call(this,value);}});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:['topBlur','topChange','topClick','topFocus','topInput','topKeyDown','topKeyUp','topSelectionChange']}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent$1.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){enqueueEvents(event);processEventQueue(false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType==='topChange'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(ExecutionEnvironment.canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType==='topFocus'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType==='topBlur'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType==='topSelectionChange'||topLevelType==='topKeyUp'||topLevelType==='topKeyDown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType==='topClick'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType==='topInput'||topLevelType==='topChange'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(inst,node){// TODO: In IE, inst is occasionally null. Why?
if(inst==null){return;}// Fiber and ReactDOM keep wrapper state in separate places
var state=inst._wrapperState||node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}// If controlled, assign the value attribute to the current value on blur
var value=''+node.value;if(node.getAttribute('value')!==value){node.setAttribute('value',value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType==='topBlur'){handleControlledInputBlur(targetInst,targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','TapEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var UIEventInterface={view:null,detail:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticUIEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticUIEvent,UIEventInterface);/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface={screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function relatedTarget(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticMouseEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticMouseEvent,MouseEventInterface);var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:['topMouseOut','topMouseOver']},mouseLeave:{registrationName:'onMouseLeave',dependencies:['topMouseOut','topMouseOver']}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){if(topLevelType==='topMouseOver'&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(topLevelType!=='topMouseOut'&&topLevelType!=='topMouseOver'){// Must not be a mouse in or mouse out - ignoring.
return null;}var win;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(topLevelType==='topMouseOut'){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave,from,nativeEvent,nativeEventTarget);leave.type='mouseleave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter,to,nativeEvent,nativeEventTarget);enter.type='mouseenter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 *//**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}var ReactInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var ReactCurrentOwner=ReactInternals.ReactCurrentOwner;var ReactDebugCurrentFrame=ReactInternals.ReactDebugCurrentFrame;function getComponentName(fiber){var type=fiber.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name;}return null;}// Don't change these two values:
var NoEffect=0;//           0b00000000
var PerformedWork=1;//      0b00000001
// You can change the rest (and add more).
var Placement=2;//          0b00000010
var Update=4;//             0b00000100
var PlacementAndUpdate=6;// 0b00000110
var Deletion=8;//           0b00001000
var ContentReset=16;//      0b00010000
var Callback=32;//          0b00100000
var Err=64;//               0b01000000
var Ref=128;//              0b10000000
var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node['return']){node=node['return'];if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node['return']){node=node['return'];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;warning(instance._warnedAboutRefsInRender,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber)||'A component');instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a['return'];var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a['return']!==b['return']){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst['return']){inst=inst['return'];}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevelImpl(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];_handleTopLevel(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;var _handleTopLevel=void 0;function setHandleTopLevel(handleTopLevel){_handleTopLevel=handleTopLevel;}function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.listen(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.capture(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevelImpl,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}var ReactDOMEventListener=Object.freeze({get _enabled(){return _enabled;},get _handleTopLevel(){return _handleTopLevel;},setHandleTopLevel:setHandleTopLevel,setEnabled:setEnabled,isEnabled:isEnabled,trapBubbledEvent:trapBubbledEvent,trapCapturedEvent:trapCapturedEvent,dispatchEvent:dispatchEvent});/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;prefixes['ms'+styleProp]='MS'+eventName;prefixes['O'+styleProp]='o'+eventName.toLowerCase();return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(ExecutionEnvironment.canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return'';}/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */var topLevelTypes$1={topAbort:'abort',topAnimationEnd:getVendorPrefixedEventName('animationend')||'animationend',topAnimationIteration:getVendorPrefixedEventName('animationiteration')||'animationiteration',topAnimationStart:getVendorPrefixedEventName('animationstart')||'animationstart',topBlur:'blur',topCancel:'cancel',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topChange:'change',topClick:'click',topClose:'close',topCompositionEnd:'compositionend',topCompositionStart:'compositionstart',topCompositionUpdate:'compositionupdate',topContextMenu:'contextmenu',topCopy:'copy',topCut:'cut',topDoubleClick:'dblclick',topDrag:'drag',topDragEnd:'dragend',topDragEnter:'dragenter',topDragExit:'dragexit',topDragLeave:'dragleave',topDragOver:'dragover',topDragStart:'dragstart',topDrop:'drop',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topFocus:'focus',topInput:'input',topKeyDown:'keydown',topKeyPress:'keypress',topKeyUp:'keyup',topLoadedData:'loadeddata',topLoad:'load',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topMouseDown:'mousedown',topMouseMove:'mousemove',topMouseOut:'mouseout',topMouseOver:'mouseover',topMouseUp:'mouseup',topPaste:'paste',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topScroll:'scroll',topSeeked:'seeked',topSeeking:'seeking',topSelectionChange:'selectionchange',topStalled:'stalled',topSuspend:'suspend',topTextInput:'textInput',topTimeUpdate:'timeupdate',topToggle:'toggle',topTouchCancel:'touchcancel',topTouchEnd:'touchend',topTouchMove:'touchmove',topTouchStart:'touchstart',topTransitionEnd:getVendorPrefixedEventName('transitionend')||'transitionend',topVolumeChange:'volumechange',topWaiting:'waiting',topWheel:'wheel'};var BrowserEventConstants={topLevelTypes:topLevelTypes$1};function runEventQueueInBatch(events){enqueueEvents(events);processEventQueue(false);}/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */function handleTopLevel(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventQueueInBatch(events);}var topLevelTypes=BrowserEventConstants.topLevelTypes;/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */function listenTo(registrationName,contentDocumentHandle){var mountAt=contentDocumentHandle;var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){if(dependency==='topScroll'){trapCapturedEvent('topScroll','scroll',mountAt);}else if(dependency==='topFocus'||dependency==='topBlur'){trapCapturedEvent('topFocus','focus',mountAt);trapCapturedEvent('topBlur','blur',mountAt);// to make sure blur and focus event listeners are only attached once
isListening.topBlur=true;isListening.topFocus=true;}else if(dependency==='topCancel'){if(isEventSupported('cancel',true)){trapCapturedEvent('topCancel','cancel',mountAt);}isListening.topCancel=true;}else if(dependency==='topClose'){if(isEventSupported('close',true)){trapCapturedEvent('topClose','close',mountAt);}isListening.topClose=true;}else if(topLevelTypes.hasOwnProperty(dependency)){trapBubbledEvent(dependency,topLevelTypes[dependency],mountAt);}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var selection=window.getSelection&&window.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode$$1=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode$$1.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode$$1&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode$$1&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){if(!window.getSelection){return;}var selection=window.getSelection();var length=node[getTextContentAccessor()].length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=document.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isInDocument(node){return containsNode(document.documentElement,node);}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&elem.type==='text'||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElement();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElement();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}focusNode(priorFocusedElem);for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=ExecutionEnvironment.canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:['topBlur','topContextMenu','topFocus','topKeyDown','topKeyUp','topMouseDown','topMouseUp','topSelectionChange']}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else if(window.getSelection){var selection=window.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement()){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent$1.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:nativeEventTarget.nodeType===DOCUMENT_NODE?nativeEventTarget:nativeEventTarget.ownerDocument;// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case'topFocus':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'topBlur':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'topMouseDown':mouseDown=true;break;case'topContextMenu':case'topMouseUp':mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'topSelectionChange':if(skipSelectionChangeEvent){break;}// falls through
case'topKeyDown':case'topKeyUp':return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface={animationName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticAnimationEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticAnimationEvent,AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface={clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticClipboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticClipboardEvent,ClipboardEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface={relatedTarget:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticFocusEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticFocusEvent,FocusEventInterface);/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface={key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticKeyboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent,KeyboardEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface={dataTransfer:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticDragEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticDragEvent,DragEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface={touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticTouchEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticTouchEvent,TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface={propertyName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticTransitionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticTransitionEvent,TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface={deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticWheelEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticWheelEvent,WheelEventInterface);/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */var eventTypes$4={};var topLevelEventsToDispatchConfig={};['abort','animationEnd','animationIteration','animationStart','blur','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','doubleClick','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','focus','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','progress','rateChange','reset','scroll','seeked','seeking','stalled','submit','suspend','timeUpdate','toggle','touchCancel','touchEnd','touchMove','touchStart','transitionEnd','volumeChange','waiting','wheel'].forEach(function(event){var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var topEvent='top'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent]};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=['topAbort','topCancel','topCanPlay','topCanPlayThrough','topClose','topDurationChange','topEmptied','topEncrypted','topEnded','topError','topInput','topInvalid','topLoad','topLoadedData','topLoadedMetadata','topLoadStart','topPause','topPlay','topPlaying','topProgress','topRateChange','topReset','topSeeked','topSeeking','topStalled','topSubmit','topSuspend','topTimeUpdate','topToggle','topVolumeChange','topWaiting'];var SimpleEventPlugin={eventTypes:eventTypes$4,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor;switch(topLevelType){case'topKeyPress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case'topKeyDown':case'topKeyUp':EventConstructor=SyntheticKeyboardEvent;break;case'topBlur':case'topFocus':EventConstructor=SyntheticFocusEvent;break;case'topClick':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case'topDoubleClick':case'topMouseDown':case'topMouseMove':case'topMouseUp':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'topMouseOut':case'topMouseOver':case'topContextMenu':EventConstructor=SyntheticMouseEvent;break;case'topDrag':case'topDragEnd':case'topDragEnter':case'topDragExit':case'topDragLeave':case'topDragOver':case'topDragStart':case'topDrop':EventConstructor=SyntheticDragEvent;break;case'topTouchCancel':case'topTouchEnd':case'topTouchMove':case'topTouchStart':EventConstructor=SyntheticTouchEvent;break;case'topAnimationEnd':case'topAnimationIteration':case'topAnimationStart':EventConstructor=SyntheticAnimationEvent;break;case'topTransitionEnd':EventConstructor=SyntheticTransitionEvent;break;case'topScroll':EventConstructor=SyntheticUIEvent;break;case'topWheel':EventConstructor=SyntheticWheelEvent;break;case'topCopy':case'topCut':case'topPaste':EventConstructor=SyntheticClipboardEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warning(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent$1;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};setHandleTopLevel(handleTopLevel);/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection$1.injectEventPluginOrder(DOMEventPluginOrder);injection$2.injectComponentTree(ReactDOMComponentTree);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection$1.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var enableAsyncSubtreeAPI=true;var enableAsyncSchedulingByDefaultInReactDOM=false;// Exports ReactDOM.createRoot
var enableCreateRoot=false;var enableUserTimingAPI=true;// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler=true;// Experimental noop mode (currently unused):
var enableNoopReconciler=false;// Experimental persistent mode (CS):
var enablePersistentReconciler=false;// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects=false;// Only used in www builds.
var valueStack=[];{var fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warning(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warning(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function reset$1(){while(index>-1){valueStack[index]=null;{fiberStack[index]=null;}index--;}}var describeComponentFrame=function describeComponentFrame(name,source,ownerName){return'\n    in '+(name||'Unknown')+(source?' (at '+source.fileName.replace(/^.*[\\\/]/,'')+':'+source.lineNumber+')':ownerName?' (created by '+ownerName+')':'');};function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case ClassComponent:case HostComponent:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber);var ownerName=null;if(owner){ownerName=getComponentName(owner);}return describeComponentFrame(name,source,ownerName);default:return'';}}// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);// Otherwise this return pointer might point to the wrong tree:
node=node['return'];}while(node);return info;}function getCurrentFiberOwnerName(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}var owner=fiber._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner);}}return null;}function getCurrentFiberStackAddendum(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackAddendumByWorkInProgressFiber(fiber);}return null;}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null;ReactDebugCurrentFiber.current=null;ReactDebugCurrentFiber.phase=null;}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackAddendum;ReactDebugCurrentFiber.current=fiber;ReactDebugCurrentFiber.phase=null;}function setCurrentPhase(phase){ReactDebugCurrentFiber.phase=phase;}var ReactDebugCurrentFiber={current:null,phase:null,resetCurrentFiber:resetCurrentFiber,setCurrentFiber:setCurrentFiber,setCurrentPhase:setCurrentPhase,getCurrentFiberOwnerName:getCurrentFiberOwnerName,getCurrentFiberStackAddendum:getCurrentFiberStackAddendum};// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;var isWaitingForCallback=false;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function formatMarkName(markName){return reactEmoji+' '+markName;};var formatLabel=function formatLabel(label,warning$$1){var prefix=warning$$1?warningEmoji+' ':reactEmoji+' ';var suffix=warning$$1?' Warning: '+warning$$1:'';return''+prefix+label+suffix;};var beginMark=function beginMark(markName){performance.mark(formatMarkName(markName));};var clearMark=function clearMark(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function endMark(label,markName,warning$$1){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning$$1);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function getFiberMarkName(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function getFiberLabel(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function beginFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function clearFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function endFiberMark(fiber,phase,warning$$1){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning$$1);};var shouldIgnoreFiber=function shouldIgnoreFiber(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case ReturnComponent:case Fragment:return true;default:return false;}};var clearPendingPhaseMeasurement=function clearPendingPhaseMeasurement(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function pauseTimers(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber['return'];}};var resumeTimersRecursively=function resumeTimersRecursively(fiber){if(fiber['return']!==null){resumeTimersRecursively(fiber['return']);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function resumeTimers(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startRequestCallbackTimer(){if(enableUserTimingAPI){if(supportsUserTiming&&!isWaitingForCallback){isWaitingForCallback=true;beginMark('(Waiting for async callback...)');}}}function stopRequestCallbackTimer(didExpire){if(enableUserTimingAPI){if(supportsUserTiming){isWaitingForCallback=false;var warning$$1=didExpire?'React was blocked by main thread':null;endMark('(Waiting for async callback...)','(Waiting for async callback...)',warning$$1);}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning$$1='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning$$1);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning$$1=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning$$1);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning$$1='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy)||'Unknown';warning$$1='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning$$1='There were cascading updates';}commitCountInCurrentWorkLoop=0;// Pause any measurements until the next loop.
pauseTimers();endMark('(React Tree Reconciliation)','(React Tree Reconciliation)',warning$$1);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(hasScheduledUpdateInCurrentCommit){warning$$1='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning$$1='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning$$1);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}{var warnedAboutMissingGetChildContext={};}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyObject;function getUnmaskedContext(workInProgress){var hasOwnContext=isContextProvider(workInProgress);if(hasOwnContext){// If the fiber is a context provider itself, when we read its context
// we have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name,ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextConsumer(fiber){return fiber.tag===ClassComponent&&fiber.type.contextTypes!=null;}function isContextProvider(fiber){return fiber.tag===ClassComponent&&fiber.type.childContextTypes!=null;}function popContextProvider(fiber){if(!isContextProvider(fiber)){return;}pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.cursor==null)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,parentContext){var instance=fiber.stateNode;var childContextTypes=fiber.type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warning(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{ReactDebugCurrentFiber.setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{ReactDebugCurrentFiber.setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(fiber)||'Unknown',contextKey):void 0;}{var name=getComponentName(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){if(!isContextProvider(workInProgress)){return false;}var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function resetContext(){previousContext=emptyObject;contextStackCursor.current=emptyObject;didPerformWorkStackCursor.current=false;}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;while(node.tag!==HostRoot){if(isContextProvider(node)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}var parent=node['return'];!parent?invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;node=parent;}return node.stateNode.context;}var NoWork=0;// TODO: Use an opaque type once ESLint et al support the syntax
var Sync=1;var Never=2147483647;// Max int32: Math.pow(2, 31) - 1
var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function expirationTimeToMs(expirationTime){return(expirationTime-MAGIC_NUMBER_OFFSET)*UNIT_SIZE;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return ceiling(currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var NoContext=0;var AsyncUpdates=1;{var hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new *//* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
{var debugCounter=1;}function FiberNode(tag,key,internalContextTag){// Instance
this.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber
this['return']=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=null;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.internalContextTag=internalContextTag;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.alternate=null;{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,key,internalContextTag){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,key,internalContextTag);};function shouldConstruct(Component){return!!(Component.prototype&&Component.prototype.isReactComponent);}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,current.key,current.internalContextTag);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;}workInProgress.expirationTime=expirationTime;workInProgress.pendingProps=pendingProps;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;return workInProgress;}function createHostRootFiber(){var fiber=createFiber(HostRoot,null,NoContext);return fiber;}function createFiberFromElement(element,internalContextTag,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type,key=element.key;if(typeof type==='function'){fiber=shouldConstruct(type)?createFiber(ClassComponent,key,internalContextTag):createFiber(IndeterminateComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if(typeof type==='string'){fiber=createFiber(HostComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&typeof type.tag==='number'){// Currently assumed to be a continuation and therefore is a fiber already.
// TODO: The yield system is currently broken for updates in some cases.
// The reified yield stores a fiber, but we don't know which fiber that is;
// the current or a workInProgress? When the continuation gets rendered here
// we don't know if we can reuse that fiber or if we need to clone it.
// There is probably a clever way to restructure this.
fiber=type;fiber.pendingProps=element.props;}else{var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and named imports.";}var ownerName=owner?getComponentName(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type==='undefined'?'undefined':_typeof(type),info);}{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}fiber.expirationTime=expirationTime;return fiber;}function createFiberFromFragment(elements,internalContextTag,expirationTime,key){var fiber=createFiber(Fragment,key,internalContextTag);fiber.pendingProps=elements;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,internalContextTag,expirationTime){var fiber=createFiber(HostText,null,internalContextTag);fiber.pendingProps=content;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromCall(call,internalContextTag,expirationTime){var fiber=createFiber(CallComponent,call.key,internalContextTag);fiber.type=call.handler;fiber.pendingProps=call;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromReturn(returnNode,internalContextTag,expirationTime){var fiber=createFiber(ReturnComponent,null,internalContextTag);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromPortal(portal,internalContextTag,expirationTime){var fiber=createFiber(HostPortal,portal.key,internalContextTag);fiber.pendingProps=portal.children||[];fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}function createFiberRoot(containerInfo,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber();var root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,remainingExpirationTime:NoWork,isReadyForCommit:false,finishedWork:null,context:null,pendingContext:null,hydrate:hydrate,nextScheduledRoot:null};uninitializedFiber.stateNode=root;return root;}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warning(false,'React DevTools encountered an error: %s',err);}}};}function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warning(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warning(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}{var didWarnUpdateInsideUpdate=false;}// Callbacks are not validated until invocation
// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.
function createUpdateQueue(baseState){var queue={baseState:baseState,expirationTime:NoWork,first:null,last:null,callbackList:null,hasForceUpdate:false,isInitialized:false};{queue.isProcessing=false;}return queue;}function insertUpdateIntoQueue(queue,update){// Append the update to the end of the list.
if(queue.last===null){// Queue is empty
queue.first=queue.last=update;}else{queue.last.next=update;queue.last=update;}if(queue.expirationTime===NoWork||queue.expirationTime>update.expirationTime){queue.expirationTime=update.expirationTime;}}function insertUpdateIntoFiber(fiber,update){// We'll have at least one and at most two distinct update queues.
var alternateFiber=fiber.alternate;var queue1=fiber.updateQueue;if(queue1===null){// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
queue1=fiber.updateQueue=createUpdateQueue(null);}var queue2=void 0;if(alternateFiber!==null){queue2=alternateFiber.updateQueue;if(queue2===null){queue2=alternateFiber.updateQueue=createUpdateQueue(null);}}else{queue2=null;}queue2=queue2!==queue1?queue2:null;// Warn if an update is scheduled from inside an updater function.
{if((queue1.isProcessing||queue2!==null&&queue2.isProcessing)&&!didWarnUpdateInsideUpdate){warning(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}// If there's only one queue, add the update to that queue and exit.
if(queue2===null){insertUpdateIntoQueue(queue1,update);return;}// If either queue is empty, we need to add to both queues.
if(queue1.last===null||queue2.last===null){insertUpdateIntoQueue(queue1,update);insertUpdateIntoQueue(queue2,update);return;}// If both lists are not empty, the last update is the same for both lists
// because of structural sharing. So, we should only append to one of
// the lists.
insertUpdateIntoQueue(queue1,update);// But we still need to update the `last` pointer of queue2.
queue2.last=update;}function getUpdateExpirationTime(fiber){if(fiber.tag!==ClassComponent&&fiber.tag!==HostRoot){return NoWork;}var updateQueue=fiber.updateQueue;if(updateQueue===null){return NoWork;}return updateQueue.expirationTime;}function getStateFromUpdate(update,instance,prevState,props){var partialState=update.partialState;if(typeof partialState==='function'){var updateFn=partialState;// Invoke setState callback an extra time to help detect side-effects.
if(debugRenderPhaseSideEffects){updateFn.call(instance,prevState,props);}return updateFn.call(instance,prevState,props);}else{return partialState;}}function processUpdateQueue(current,workInProgress,queue,instance,props,renderExpirationTime){if(current!==null&&current.updateQueue===queue){// We need to create a work-in-progress queue, by cloning the current queue.
var currentQueue=queue;queue=workInProgress.updateQueue={baseState:currentQueue.baseState,expirationTime:currentQueue.expirationTime,first:currentQueue.first,last:currentQueue.last,isInitialized:currentQueue.isInitialized,// These fields are no longer valid because they were already committed.
// Reset them.
callbackList:null,hasForceUpdate:false};}{// Set this flag so we can warn if setState is called inside the update
// function of another setState.
queue.isProcessing=true;}// Reset the remaining expiration time. If we skip over any updates, we'll
// increase this accordingly.
queue.expirationTime=NoWork;// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
var state=void 0;if(queue.isInitialized){state=queue.baseState;}else{state=queue.baseState=workInProgress.memoizedState;queue.isInitialized=true;}var dontMutatePrevState=true;var update=queue.first;var didSkip=false;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
var remainingExpirationTime=queue.expirationTime;if(remainingExpirationTime===NoWork||remainingExpirationTime>updateExpirationTime){// Update the remaining expiration time.
queue.expirationTime=updateExpirationTime;}if(!didSkip){didSkip=true;queue.baseState=state;}// Continue to the next update.
update=update.next;continue;}// This update does have sufficient priority.
// If no previous updates were skipped, drop this update from the queue by
// advancing the head of the list.
if(!didSkip){queue.first=update.next;if(queue.first===null){queue.last=null;}}// Process the update
var _partialState=void 0;if(update.isReplace){state=getStateFromUpdate(update,instance,state,props);dontMutatePrevState=true;}else{_partialState=getStateFromUpdate(update,instance,state,props);if(_partialState){if(dontMutatePrevState){// $FlowFixMe: Idk how to type this properly.
state=_assign({},state,_partialState);}else{state=_assign(state,_partialState);}dontMutatePrevState=false;}}if(update.isForced){queue.hasForceUpdate=true;}if(update.callback!==null){// Append to list of callbacks.
var _callbackList=queue.callbackList;if(_callbackList===null){_callbackList=queue.callbackList=[];}_callbackList.push(update);}update=update.next;}if(queue.callbackList!==null){workInProgress.effectTag|=Callback;}else if(queue.first===null&&!queue.hasForceUpdate){// The queue is empty. We can reset it.
workInProgress.updateQueue=null;}if(!didSkip){didSkip=true;queue.baseState=state;}{// No longer processing.
queue.isProcessing=false;}return state;}function commitCallbacks(queue,context){var callbackList=queue.callbackList;if(callbackList===null){return;}// Set the list to null to make sure they don't get called more than once.
queue.callbackList=null;for(var i=0;i<callbackList.length;i++){var update=callbackList[i];var _callback=update.callback;// This update might be processed again. Clear the callback so it's only
// called once.
update.callback=null;!(typeof _callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback):void 0;_callback.call(context);}}var fakeInternalInstance={};var isArray=Array.isArray;{var didWarnAboutStateAssignmentForComponent={};var warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){warning(callback===null||typeof callback==='function','%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}var ReactFiberClassComponent=function ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState){// Class component state updater
var updater={isMounted:isMounted,enqueueSetState:function enqueueSetState(instance,partialState,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'setState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:partialState,callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function enqueueReplaceState(instance,state,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'replaceState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:state,callback:callback,isReplace:true,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function enqueueForceUpdate(instance,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'forceUpdate');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:null,callback:callback,isReplace:false,isForced:true,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext){if(oldProps===null||workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate){// If the workInProgress already has an Update effect, return true
return true;}var instance=workInProgress.stateNode;var type=workInProgress.type;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.shouldComponentUpdate(newProps,newState,newContext);}{warning(shouldUpdate!==undefined,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(workInProgress)||'Unknown');}return shouldUpdate;}if(type.prototype&&type.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress){var instance=workInProgress.stateNode;var type=workInProgress.type;{var name=getComponentName(workInProgress);var renderPresent=instance.render;if(!renderPresent){if(type.prototype&&typeof type.prototype.render==='function'){warning(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warning(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;warning(noGetInitialStateOnES6,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;warning(noGetDefaultPropsOnES6,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);var noInstancePropTypes=!instance.propTypes;warning(noInstancePropTypes,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);var noInstanceContextTypes=!instance.contextTypes;warning(noInstanceContextTypes,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';warning(noComponentShouldUpdate,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);if(type.prototype&&type.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warning(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(workInProgress)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';warning(noComponentDidUnmount,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';warning(noComponentDidReceiveProps,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';warning(noComponentWillRecieveProps,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);var hasMutatedProps=instance.props!==workInProgress.pendingProps;warning(instance.props===undefined||!hasMutatedProps,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);var noInstanceDefaultProps=!instance.defaultProps;warning(noInstanceDefaultProps,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}var state=instance.state;if(state&&((typeof state==='undefined'?'undefined':_typeof(state))!=='object'||isArray(state))){warning(false,'%s.state: must be set to an object or null',getComponentName(workInProgress));}if(typeof instance.getChildContext==='function'){warning(_typeof(workInProgress.type.childContextTypes)==='object','%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',getComponentName(workInProgress));}}function resetInputPointers(workInProgress,instance){instance.props=workInProgress.memoizedProps;instance.state=workInProgress.memoizedState;}function adoptClassInstance(workInProgress,instance){instance.updater=updater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,props){var ctor=workInProgress.type;var unmaskedContext=getUnmaskedContext(workInProgress);var needsContext=isContextConsumer(workInProgress);var context=needsContext?getMaskedContext(workInProgress,unmaskedContext):emptyObject;var instance=new ctor(props,context);adoptClassInstance(workInProgress,instance);// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(needsContext){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;instance.componentWillMount();stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillMount();}if(oldState!==instance.state){{warning(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress));}updater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,newContext){startPhaseTimer(workInProgress,'componentWillReceiveProps');var oldState=instance.state;instance.componentWillReceiveProps(newProps,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillReceiveProps(newProps,newContext);}if(instance.state!==oldState){{var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent[componentName]){warning(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);didWarnAboutStateAssignmentForComponent[componentName]=true;}}updater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,renderExpirationTime){var current=workInProgress.alternate;{checkClassInstance(workInProgress);}var instance=workInProgress.stateNode;var state=instance.state||null;var props=workInProgress.pendingProps;!props?invariant(false,'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'):void 0;var unmaskedContext=getUnmaskedContext(workInProgress);instance.props=props;instance.state=workInProgress.memoizedState=state;instance.refs=emptyObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);if(enableAsyncSubtreeAPI&&workInProgress.type!=null&&workInProgress.type.prototype!=null&&workInProgress.type.prototype.unstable_isAsyncReactComponent===true){workInProgress.internalContextTag|=AsyncUpdates;}if(typeof instance.componentWillMount==='function'){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){instance.state=processUpdateQueue(current,workInProgress,updateQueue,instance,props,renderExpirationTime);}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}// Called on a preexisting class instance. Returns false if a resumed render
// could be reused.
// function resumeMountClassInstance(
//   workInProgress: Fiber,
//   priorityLevel: PriorityLevel,
// ): boolean {
//   const instance = workInProgress.stateNode;
//   resetInputPointers(workInProgress, instance);
//   let newState = workInProgress.memoizedState;
//   let newProps = workInProgress.pendingProps;
//   if (!newProps) {
//     // If there isn't any new props, then we'll reuse the memoized props.
//     // This could be from already completed work.
//     newProps = workInProgress.memoizedProps;
//     invariant(
//       newProps != null,
//       'There should always be pending or memoized props. This error is ' +
//         'likely caused by a bug in React. Please file an issue.',
//     );
//   }
//   const newUnmaskedContext = getUnmaskedContext(workInProgress);
//   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
//   const oldContext = instance.context;
//   const oldProps = workInProgress.memoizedProps;
//   if (
//     typeof instance.componentWillReceiveProps === 'function' &&
//     (oldProps !== newProps || oldContext !== newContext)
//   ) {
//     callComponentWillReceiveProps(
//       workInProgress,
//       instance,
//       newProps,
//       newContext,
//     );
//   }
//   // Process the update queue before calling shouldComponentUpdate
//   const updateQueue = workInProgress.updateQueue;
//   if (updateQueue !== null) {
//     newState = processUpdateQueue(
//       workInProgress,
//       updateQueue,
//       instance,
//       newState,
//       newProps,
//       priorityLevel,
//     );
//   }
//   // TODO: Should we deal with a setState that happened after the last
//   // componentWillMount and before this componentWillMount? Probably
//   // unsupported anyway.
//   if (
//     !checkShouldComponentUpdate(
//       workInProgress,
//       workInProgress.memoizedProps,
//       newProps,
//       workInProgress.memoizedState,
//       newState,
//       newContext,
//     )
//   ) {
//     // Update the existing instance's state, props, and context pointers even
//     // though we're bailing out.
//     instance.props = newProps;
//     instance.state = newState;
//     instance.context = newContext;
//     return false;
//   }
//   // Update the input pointers now so that they are correct when we call
//   // componentWillMount
//   instance.props = newProps;
//   instance.state = newState;
//   instance.context = newContext;
//   if (typeof instance.componentWillMount === 'function') {
//     callComponentWillMount(workInProgress, instance);
//     // componentWillMount may have called setState. Process the update queue.
//     const newUpdateQueue = workInProgress.updateQueue;
//     if (newUpdateQueue !== null) {
//       newState = processUpdateQueue(
//         workInProgress,
//         newUpdateQueue,
//         instance,
//         newState,
//         newProps,
//         priorityLevel,
//       );
//     }
//   }
//   if (typeof instance.componentDidMount === 'function') {
//     workInProgress.effectTag |= Update;
//   }
//   instance.state = newState;
//   return true;
// }
// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,renderExpirationTime){var instance=workInProgress.stateNode;resetInputPointers(workInProgress,instance);var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;if(!newProps){// If there aren't any new props, then we'll reuse the memoized props.
// This could be from already completed work.
newProps=oldProps;!(newProps!=null)?invariant(false,'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
if(typeof instance.componentWillReceiveProps==='function'&&(oldProps!==newProps||oldContext!==newContext)){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}// Compute the next state using the memoized state and the update queue.
var oldState=workInProgress.memoizedState;// TODO: Previous state can be null.
var newState=void 0;if(workInProgress.updateQueue!==null){newState=processUpdateQueue(current,workInProgress,workInProgress.updateQueue,instance,newProps,renderExpirationTime);}else{newState=oldState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!(workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate)){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}return false;}var shouldUpdate=checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){if(typeof instance.componentWillUpdate==='function'){startPhaseTimer(workInProgress,'componentWillUpdate');instance.componentWillUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillUpdate(newProps,newState,newContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
memoizeProps(workInProgress,newProps);memoizeState(workInProgress,newState);}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}return{adoptClassInstance:adoptClassInstance,constructClassInstance:constructClassInstance,mountClassInstance:mountClassInstance,// resumeMountClassInstance,
updateClassInstance:updateClassInstance};};// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol=typeof Symbol==='function'&&Symbol['for'];var REACT_ELEMENT_TYPE=hasSymbol?Symbol['for']('react.element'):0xeac7;var REACT_CALL_TYPE=hasSymbol?Symbol['for']('react.call'):0xeac8;var REACT_RETURN_TYPE=hasSymbol?Symbol['for']('react.return'):0xeac9;var REACT_PORTAL_TYPE=hasSymbol?Symbol['for']('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol['for']('react.fragment'):0xeacb;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable==='undefined'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var getCurrentFiberStackAddendum$1=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnAboutMaps=false;/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */var ownerHasKeyUseWarning={};var ownerHasFunctionTypeWarning={};var warnForMissingKey=function warnForMissingKey(child){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(_typeof(child._store)==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning(false,'Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.%s',getCurrentFiberStackAddendum$1());};}var isArray$1=Array.isArray;function coerceRef(current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'){if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function or a string.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+(getCurrentFiberStackAddendum$1()||'');}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.%s',getCurrentFiberStackAddendum$1()||'');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent,expirationTime);existing['return']=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null&&current.type===element.type){// Move based on index
var existing=useFiber(current,element.props,expirationTime);existing.ref=coerceRef(current,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);created.ref=coerceRef(current,element);created['return']=returnFiber;return created;}}function updateCall(returnFiber,current,call,expirationTime){// TODO: Should this also compare handler to determine whether to reuse?
if(current===null||current.tag!==CallComponent){// Insert
var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,call,expirationTime);existing['return']=returnFiber;return existing;}}function updateReturn(returnFiber,current,returnNode,expirationTime){if(current===null||current.tag!==ReturnComponent){// Insert
var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.internalContextTag,expirationTime,key);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment,expirationTime);existing['return']=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.type===REACT_FRAGMENT_TYPE){var _created=createFiberFromFragment(newChild.props.children,returnFiber.internalContextTag,expirationTime,newChild.key);_created['return']=returnFiber;return _created;}else{var _created2=createFiberFromElement(newChild,returnFiber.internalContextTag,expirationTime);_created2.ref=coerceRef(null,newChild);_created2['return']=returnFiber;return _created2;}}case REACT_CALL_TYPE:{var _created3=createFiberFromCall(newChild,returnFiber.internalContextTag,expirationTime);_created3['return']=returnFiber;return _created3;}case REACT_RETURN_TYPE:{var _created4=createFiberFromReturn(newChild,returnFiber.internalContextTag,expirationTime);_created4.type=newChild.value;_created4['return']=returnFiber;return _created4;}case REACT_PORTAL_TYPE:{var _created5=createFiberFromPortal(newChild,returnFiber.internalContextTag,expirationTime);_created5['return']=returnFiber;return _created5;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created6=createFiberFromFragment(newChild,returnFiber.internalContextTag,expirationTime,null);_created6['return']=returnFiber;return _created6;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_CALL_TYPE:{if(newChild.key===key){return updateCall(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_RETURN_TYPE:{// Returns don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a
// yield.
if(key===null){return updateReturn(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_CALL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateCall(returnFiber,_matchedFiber2,newChild,expirationTime);}case REACT_RETURN_TYPE:{// Returns don't have keys, so we neither have to check the old nor
// new node for the key. If both are returns, they match.
var _matchedFiber3=existingChildren.get(newIdx)||null;return updateReturn(returnFiber,_matchedFiber3,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber4=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber4,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber5=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber5,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_CALL_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.%s',key,getCurrentFiberStackAddendum$1());break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// Warn about using Maps as children
if(typeof newChildrenIterable.entries==='function'){var possibleMap=newChildrenIterable;if(possibleMap.entries===iteratorFn){warning(didWarnAboutMaps,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.%s',getCurrentFiberStackAddendum$1());didWarnAboutMaps=true;}}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing['return']=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(child,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.internalContextTag,expirationTime,element.key);created['return']=returnFiber;return created;}else{var _created7=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);_created7.ref=coerceRef(currentFirstChild,element);_created7['return']=returnFiber;return _created7;}}function reconcileSingleCall(returnFiber,currentFirstChild,call,expirationTime){var key=call.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===CallComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,call,expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleReturn(returnFiber,currentFirstChild,returnNode,expirationTime){// There's no need to check for keys on yields since they're stateless.
var child=currentFirstChild;if(child!==null){if(child.tag===ReturnComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);}}var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null){newChild=newChild.props.children;}// Handle object types
var isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_CALL_TYPE:return placeSingleChild(reconcileSingleCall(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_RETURN_TYPE:return placeSingleChild(reconcileSingleReturn(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){!(current===null||workInProgress.child===current.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild['return']=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild['return']=workInProgress;}newChild.sibling=null;}{var warnedAboutStatelessRefs={};}var ReactFiberBeginWork=function ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber){var shouldSetTextContent=config.shouldSetTextContent,useSyncScheduling=config.useSyncScheduling,shouldDeprioritizeSubtree=config.shouldDeprioritizeSubtree;var pushHostContext=hostContext.pushHostContext,pushHostContainer=hostContext.pushHostContainer;var enterHydrationState=hydrationContext.enterHydrationState,resetHydrationState=hydrationContext.resetHydrationState,tryToClaimNextHydratableInstance=hydrationContext.tryToClaimNextHydratableInstance;var _ReactFiberClassCompo=ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState),adoptClassInstance=_ReactFiberClassCompo.adoptClassInstance,constructClassInstance=_ReactFiberClassCompo.constructClassInstance,mountClassInstance=_ReactFiberClassCompo.mountClassInstance,updateClassInstance=_ReactFiberClassCompo.updateClassInstance;// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.
function reconcileChildren(current,workInProgress,nextChildren){reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,workInProgress.expirationTime);}function reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime);}}function updateFragment(current,workInProgress){var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=workInProgress.memoizedProps;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(ref!==null&&(!current||current.ref!==ref)){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current,workInProgress){var fn=workInProgress.type;var nextProps=workInProgress.pendingProps;var memoizedProps=workInProgress.memoizedProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextProps===null){nextProps=memoizedProps;}}else{if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// TODO: consider bringing fn.shouldComponentUpdate() back.
// It used to be here.
}var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=fn(nextProps,context);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current,workInProgress,renderExpirationTime){// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);var shouldUpdate=void 0;if(current===null){if(!workInProgress.stateNode){// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,workInProgress.pendingProps);mountClassInstance(workInProgress,renderExpirationTime);shouldUpdate=true;}else{invariant(false,'Resuming work not yet implemented.');// In a resume, we'll already have an instance we can reuse.
// shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
}}else{shouldUpdate=updateClassInstance(current,workInProgress,renderExpirationTime);}return finishClassComponent(current,workInProgress,shouldUpdate,hasContext);}function finishClassComponent(current,workInProgress,shouldUpdate,hasContext){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);if(!shouldUpdate){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner.current=workInProgress;var nextChildren=void 0;{ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=instance.render();if(debugRenderPhaseSideEffects){instance.render();}ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);// Memoize props and state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
memoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){var prevState=workInProgress.memoizedState;var state=processUpdateQueue(current,workInProgress,updateQueue,null,null,renderExpirationTime);if(prevState===state){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress);}var element=state.element;var root=workInProgress.stateNode;if((current===null||current.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibers(workInProgress,null,element,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
resetHydrationState();reconcileChildren(current,workInProgress,element);}memoizeState(workInProgress,state);return workInProgress.child;}resetHydrationState();// If there is no update queue, that's a bailout because the root has no props.
return bailoutOnAlreadyFinishedWork(current,workInProgress);}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var memoizedProps=workInProgress.memoizedProps;var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=memoizedProps;!(nextProps!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var prevProps=current!==null?current.memoizedProps:null;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
}else if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&!useSyncScheduling&&shouldDeprioritizeSubtree(type,nextProps)){// Down-prioritize the children.
workInProgress.expirationTime=Never;// Bailout and come back to this fiber later.
return null;}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=workInProgress.memoizedProps;}memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountIndeterminateComponent(current,workInProgress,renderExpirationTime){!(current===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var fn=workInProgress.type;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var value;{if(fn.prototype&&typeof fn.prototype.render==='function'){var componentName=getComponentName(workInProgress);warning(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);}ReactCurrentOwner.current=workInProgress;value=fn(props,context);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,renderExpirationTime);return finishClassComponent(current,workInProgress,true,hasContext);}else{// Proceed under the assumption that this is a functional component
workInProgress.tag=FunctionalComponent;{var Component=workInProgress.type;if(Component){warning(!Component.childContextTypes,'%s(...): childContextTypes cannot be defined on a functional component.',Component.displayName||Component.name||'Component');}if(workInProgress.ref!==null){var info='';var ownerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!warnedAboutStatelessRefs[warningKey]){warnedAboutStatelessRefs[warningKey]=true;warning(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s%s',info,ReactDebugCurrentFiber.getCurrentFiberStackAddendum());}}}reconcileChildren(current,workInProgress,value);memoizeProps(workInProgress,props);return workInProgress.child;}}function updateCallComponent(current,workInProgress,renderExpirationTime){var nextCall=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextCall===null){nextCall=current&&current.memoizedProps;!(nextCall!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextCall===null||workInProgress.memoizedProps===nextCall){nextCall=workInProgress.memoizedProps;// TODO: When bailing out, we might need to return the stateNode instead
// of the child. To check it for work.
// return bailoutOnAlreadyFinishedWork(current, workInProgress);
}var nextChildren=nextCall.children;// The following is a fork of reconcileChildrenAtExpirationTime but using
// stateNode to store the child.
if(current===null){workInProgress.stateNode=mountChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else{workInProgress.stateNode=reconcileChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}memoizeProps(workInProgress,nextCall);// This doesn't take arbitrary time so we could synchronously just begin
// eagerly do the work of workInProgress.child as an optimization.
return workInProgress.stateNode;}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=current&&current.memoizedProps;!(nextChildren!=null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */function bailoutOnAlreadyFinishedWork(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: We should ideally be able to bail out early if the children have no
// more work to do. However, since we don't have a separation of this
// Fiber's priority and its children yet - we don't know without doing lots
// of the same work we do anyway. Once we have that separation we can just
// bail out here if the children has no more work at this priority level.
// if (workInProgress.priorityOfChildren <= priorityLevel) {
//   // If there are side-effects in these children that have not yet been
//   // committed we need to ensure that they get properly transferred up.
//   if (current && current.child !== workInProgress.child) {
//     reuseChildrenEffects(workInProgress, child);
//   }
//   return null;
// }
cloneChildFibers(current,workInProgress);return workInProgress.child;}function bailoutOnLowPriority(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: Handle HostComponent tags here as well and call pushHostContext()?
// See PR 8590 discussion for context
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);break;case ClassComponent:pushContextProvider(workInProgress);break;case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;}// TODO: What if this is currently in progress?
// How can that happen? How is this not being cloned?
return null;}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting
// is handled by processUpdateQueue.
}function beginWork(current,workInProgress,renderExpirationTime){if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}switch(workInProgress.tag){case IndeterminateComponent:return mountIndeterminateComponent(current,workInProgress,renderExpirationTime);case FunctionalComponent:return updateFunctionalComponent(current,workInProgress);case ClassComponent:return updateClassComponent(current,workInProgress,renderExpirationTime);case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case CallHandlerPhase:// This is a restart. Reset the tag to the initial phase.
workInProgress.tag=CallComponent;// Intentionally fall through since this is now the same.
case CallComponent:return updateCallComponent(current,workInProgress,renderExpirationTime);case ReturnComponent:// A return component is just a placeholder, we can just run through the
// next one immediately.
return null;case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case Fragment:return updateFragment(current,workInProgress);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function beginFailedWork(current,workInProgress,renderExpirationTime){// Push context providers here to avoid a push/pop context mismatch.
switch(workInProgress.tag){case ClassComponent:pushContextProvider(workInProgress);break;case HostRoot:pushHostRootContext(workInProgress);break;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}// Add an error effect so we can handle the error during the commit phase
workInProgress.effectTag|=Err;// This is a weird case where we do "resume" work — work that failed on
// our first attempt. Because we no longer have a notion of "progressed
// deletions," reset the child to the current child to make sure we delete
// it again. TODO: Find a better way to handle this, perhaps during a more
// general overhaul of error handling.
if(current===null){workInProgress.child=null;}else if(workInProgress.child!==current.child){workInProgress.child=current.child;}if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}// If we don't bail out, we're going be recomputing our children so we need
// to drop our effect list.
workInProgress.firstEffect=null;workInProgress.lastEffect=null;// Unmount the current children as if the component rendered null
var nextChildren=null;reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime);if(workInProgress.tag===ClassComponent){var instance=workInProgress.stateNode;workInProgress.memoizedProps=instance.props;workInProgress.memoizedState=instance.state;}return workInProgress.child;}return{beginWork:beginWork,beginFailedWork:beginFailedWork};};var ReactFiberCompleteWork=function ReactFiberCompleteWork(config,hostContext,hydrationContext){var createInstance=config.createInstance,createTextInstance=config.createTextInstance,appendInitialChild=config.appendInitialChild,finalizeInitialChildren=config.finalizeInitialChildren,prepareUpdate=config.prepareUpdate,mutation=config.mutation,persistence=config.persistence;var getRootHostContainer=hostContext.getRootHostContainer,popHostContext=hostContext.popHostContext,getHostContext=hostContext.getHostContext,popHostContainer=hostContext.popHostContainer;var prepareToHydrateHostInstance=hydrationContext.prepareToHydrateHostInstance,prepareToHydrateHostTextInstance=hydrationContext.prepareToHydrateHostTextInstance,popHydrationState=hydrationContext.popHydrationState;function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// an UpdateAndPlacement.
workInProgress.effectTag|=Update;}function markRef(workInProgress){workInProgress.effectTag|=Ref;}function appendAllReturns(returns,workInProgress){var node=workInProgress.stateNode;if(node){node['return']=workInProgress;}while(node!==null){if(node.tag===HostComponent||node.tag===HostText||node.tag===HostPortal){invariant(false,'A call cannot have host component children.');}else if(node.tag===ReturnComponent){returns.push(node.type);}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function moveCallToHandlerPhase(current,workInProgress,renderExpirationTime){var call=workInProgress.memoizedProps;!call?invariant(false,'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.'):void 0;// First step of the call has completed. Now we need to do the second.
// TODO: It would be nice to have a multi stage call represented by a
// single component, or at least tail call optimize nested ones. Currently
// that requires additional fields that we don't want to add to the fiber.
// So this requires nested handlers.
// Note: This doesn't mutate the alternate node. I don't think it needs to
// since this stage is reset for every pass.
workInProgress.tag=CallHandlerPhase;// Build up the returns.
// TODO: Compare this to a generator or opaque helpers like Children.
var returns=[];appendAllReturns(returns,workInProgress);var fn=call.handler;var props=call.props;var nextChildren=fn(props,returns);var currentFirstChild=current!==null?current.child:null;workInProgress.child=reconcileChildFibers(workInProgress,currentFirstChild,nextChildren,renderExpirationTime);return workInProgress.child;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent=void 0;var updateHostText=void 0;if(mutation){if(enableMutatingReconciler){// Mutation mode
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else{invariant(false,'Mutating reconciler is disabled.');}}else if(persistence){if(enablePersistentReconciler){// Persistent host tree mode
var cloneInstance=persistence.cloneInstance,createContainerChildSet=persistence.createContainerChildSet,appendChildToContainerChildSet=persistence.appendChildToContainerChildSet,finalizeContainerChildren=persistence.finalizeContainerChildren;// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function appendAllChildrenToContainer(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);if(finalizeContainerChildren(container,newChildSet)){markUpdate(workInProgress);}portalOrRoot.pendingChildren=newChildSet;// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress);// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);}};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;var currentInstance=current.stateNode;if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;}else{var recyclableInstance=workInProgress.stateNode;var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress);}}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{invariant(false,'Persistent reconciler is disabled.');}}else{if(enableNoopReconciler){// No host operations
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// Noop
};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// Noop
};}else{invariant(false,'Noop reconciler is disabled.');}}function completeWork(current,workInProgress,renderExpirationTime){// Get the latest props.
var newProps=workInProgress.pendingProps;if(newProps===null){newProps=workInProgress.memoizedProps;}else if(workInProgress.expirationTime!==Never||renderExpirationTime===Never){// Reset the pending props, unless this was a down-prioritization.
workInProgress.pendingProps=null;}switch(workInProgress.tag){case FunctionalComponent:return null;case ClassComponent:{// We are leaving this subtree, so pop context if any.
popContextProvider(workInProgress);return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,_currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var _instance=createInstance(type,newProps,rootContainerInstance,_currentHostContext,workInProgress);appendAllChildren(_instance,workInProgress);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(_instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=_instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _rootContainerInstance=getRootHostContainer();var _currentHostContext2=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext2,workInProgress);}}return null;}case CallComponent:return moveCallToHandlerPhase(current,workInProgress,renderExpirationTime);case CallHandlerPhase:// Reset the tag to now be a first phase call.
workInProgress.tag=CallComponent;return null;case ReturnComponent:// Does nothing.
return null;case Fragment:return null;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;// Error cases
case IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough
default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}return{completeWork:completeWork};};var invokeGuardedCallback$2=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError$1=ReactErrorUtils.hasCaughtError;var clearCaughtError$1=ReactErrorUtils.clearCaughtError;var ReactFiberCommitWork=function ReactFiberCommitWork(config,captureError){var getPublicInstance=config.getPublicInstance,mutation=config.mutation,persistence=config.persistence;var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback$2(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError$1()){var unmountError=clearCaughtError$1();captureError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){{invokeGuardedCallback$2(null,ref,null,null);if(hasCaughtError$1()){var refError=clearCaughtError$1();captureError(current,refError);}}}}function commitLifeCycles(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){commitCallbacks(updateQueue,instance);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=finishedWork.child!==null?finishedWork.child.stateNode:null;commitCallbacks(_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;switch(finishedWork.tag){case HostComponent:ref(getPublicInstance(instance));break;default:ref(instance);}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){currentRef(null);}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current){if(typeof onCommitUnmount==='function'){onCommitUnmount(current);}switch(current.tag){case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case CallComponent:{commitNestedUnmounts(current.stateNode);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(enableMutatingReconciler&&mutation){unmountHostComponents(current);}else if(enablePersistentReconciler&&persistence){emptyPortalContainer(current);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!mutation||node.tag!==HostPortal)){node.child['return']=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node['return']===null||node['return']===root){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function detachFiber(current){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current['return']=null;current.child=null;if(current.alternate){current.alternate.child=null;current.alternate['return']=null;}}if(!mutation){var commitContainer=void 0;if(persistence){var replaceContainerChildren=persistence.replaceContainerChildren,createContainerChildSet=persistence.createContainerChildSet;var emptyPortalContainer=function emptyPortalContainer(current){var portal=current.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);};commitContainer=function commitContainer(finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}};}else{commitContainer=function commitContainer(finishedWork){// Noop
};}if(enablePersistentReconciler||enableNoopReconciler){return{commitResetTextContent:function commitResetTextContent(finishedWork){},commitPlacement:function commitPlacement(finishedWork){},commitDeletion:function commitDeletion(current){// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current);detachFiber(current);},commitWork:function commitWork(current,finishedWork){commitContainer(finishedWork);},commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else if(persistence){invariant(false,'Persistent reconciler is disabled.');}else{invariant(false,'Noop reconciler is disabled.');}}var commitMount=mutation.commitMount,commitUpdate=mutation.commitUpdate,resetTextContent=mutation.resetTextContent,commitTextUpdate=mutation.commitTextUpdate,appendChild=mutation.appendChild,appendChildToContainer=mutation.appendChildToContainer,insertBefore=mutation.insertBefore,insertInContainerBefore=mutation.insertInContainerBefore,removeChild=mutation.removeChild,removeChildFromContainer=mutation.removeChildFromContainer;function getHostParentFiber(fiber){var parent=fiber['return'];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent['return'];}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node['return']===null||isHostParent(node['return'])){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child['return']=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node['return']===null||node['return']===finishedWork){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function unmountHostComponents(current){// We only have the top Fiber that was inserted but we need recurse down its
var node=current;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node['return'];findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent['return'];}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;// Visit children because portals might contain host components.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node['return']===null||node['return']===current){return;}node=node['return'];if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling['return']=node['return'];node=node.sibling;}}function commitDeletion(current){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current);detachFiber(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current){resetTextContent(current.stateNode);}if(enableMutatingReconciler){return{commitResetTextContent:commitResetTextContent,commitPlacement:commitPlacement,commitDeletion:commitDeletion,commitWork:commitWork,commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else{invariant(false,'Mutating reconciler is disabled.');}};var NO_CONTEXT={};var ReactFiberHostContext=function ReactFiberHostContext(config){var getChildHostContext=config.getChildHostContext,getRootHostContext=config.getRootHostContext;var contextStackCursor=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);}function resetHostContainer(){contextStackCursor.current=NO_CONTEXT;rootInstanceStackCursor.current=NO_CONTEXT;}return{getHostContext:getHostContext,getRootHostContainer:getRootHostContainer,popHostContainer:popHostContainer,popHostContext:popHostContext,pushHostContainer:pushHostContainer,pushHostContext:pushHostContext,resetHostContainer:resetHostContainer};};var ReactFiberHydrationContext=function ReactFiberHydrationContext(config){var shouldSetTextContent=config.shouldSetTextContent,hydration=config.hydration;// If this doesn't have hydration mode.
if(!hydration){return{enterHydrationState:function enterHydrationState(){return false;},resetHydrationState:function resetHydrationState(){},tryToClaimNextHydratableInstance:function tryToClaimNextHydratableInstance(){},prepareToHydrateHostInstance:function prepareToHydrateHostInstance(){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},prepareToHydrateHostTextInstance:function prepareToHydrateHostTextInstance(){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},popHydrationState:function popHydrationState(fiber){return false;}};}var canHydrateInstance=hydration.canHydrateInstance,canHydrateTextInstance=hydration.canHydrateTextInstance,getNextHydratableSibling=hydration.getNextHydratableSibling,getFirstHydratableChild=hydration.getFirstHydratableChild,hydrateInstance=hydration.hydrateInstance,hydrateTextInstance=hydration.hydrateTextInstance,didNotMatchHydratedContainerTextInstance=hydration.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=hydration.didNotMatchHydratedTextInstance,didNotHydrateContainerInstance=hydration.didNotHydrateContainerInstance,didNotHydrateInstance=hydration.didNotHydrateInstance,didNotFindHydratableContainerInstance=hydration.didNotFindHydratableContainerInstance,didNotFindHydratableContainerTextInstance=hydration.didNotFindHydratableContainerTextInstance,didNotFindHydratableInstance=hydration.didNotFindHydratableInstance,didNotFindHydratableTextInstance=hydration.didNotFindHydratableTextInstance;// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete['return']=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type,props);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(nextInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,nextHydratableInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber['return'];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent['return'];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}return{enterHydrationState:enterHydrationState,resetHydrationState:resetHydrationState,tryToClaimNextHydratableInstance:tryToClaimNextHydratableInstance,prepareToHydrateHostInstance:prepareToHydrateHostInstance,prepareToHydrateHostTextInstance:prepareToHydrateHostTextInstance,popHydrationState:popHydrationState};};// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;var defaultShowDialog=function defaultShowDialog(capturedError){return true;};var showDialog=defaultShowDialog;function logCapturedError(capturedError){var logError=showDialog(capturedError);// Allow injected showDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=capturedError.error;var suppressLogging=error&&error.suppressReactErrorLogging;if(suppressLogging){return;}{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var invokeGuardedCallback$1=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError=ReactErrorUtils.hasCaughtError;var clearCaughtError=ReactErrorUtils.clearCaughtError;{var didWarnAboutStateTransition=false;var didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};var warnAboutUpdateOnUnmounted=function warnAboutUpdateOnUnmounted(fiber){var componentName=getComponentName(fiber)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warning(false,'Can only update a mounted or mounting '+'component. This usually means you called setState, replaceState, '+'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease '+'check the code for the %s component.',componentName);didWarnStateUpdateForUnmountedComponent[componentName]=true;};var warnAboutInvalidUpdates=function warnAboutInvalidUpdates(instance){switch(ReactDebugCurrentFiber.phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warning(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warning(false,'Cannot update during an existing state transition (such as within '+"`render` or another component's constructor). Render methods should "+'be a pure function of props and state; constructor side-effects are '+'an anti-pattern, but can be moved to `componentWillMount`.');didWarnAboutStateTransition=true;break;}};}var ReactFiberScheduler=function ReactFiberScheduler(config){var hostContext=ReactFiberHostContext(config);var hydrationContext=ReactFiberHydrationContext(config);var popHostContainer=hostContext.popHostContainer,popHostContext=hostContext.popHostContext,resetHostContainer=hostContext.resetHostContainer;var _ReactFiberBeginWork=ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber),beginWork=_ReactFiberBeginWork.beginWork,beginFailedWork=_ReactFiberBeginWork.beginFailedWork;var _ReactFiberCompleteWo=ReactFiberCompleteWork(config,hostContext,hydrationContext),completeWork=_ReactFiberCompleteWo.completeWork;var _ReactFiberCommitWork=ReactFiberCommitWork(config,captureError),commitResetTextContent=_ReactFiberCommitWork.commitResetTextContent,commitPlacement=_ReactFiberCommitWork.commitPlacement,commitDeletion=_ReactFiberCommitWork.commitDeletion,commitWork=_ReactFiberCommitWork.commitWork,commitLifeCycles=_ReactFiberCommitWork.commitLifeCycles,commitAttachRef=_ReactFiberCommitWork.commitAttachRef,commitDetachRef=_ReactFiberCommitWork.commitDetachRef;var now=config.now,scheduleDeferredCallback=config.scheduleDeferredCallback,cancelDeferredCallback=config.cancelDeferredCallback,useSyncScheduling=config.useSyncScheduling,prepareForCommit=config.prepareForCommit,resetAfterCommit=config.resetAfterCommit;// Represents the current time in ms.
var startTime=now();var mostRecentCurrentTime=msToExpirationTime(0);// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;// The next fiber with an effect that we're currently committing.
var nextEffect=null;// Keep track of which fibers have captured an error that need to be handled.
// Work is removed from this collection after componentDidCatch is called.
var capturedErrors=null;// Keep track of which fibers have failed during the current batch of work.
// This is a different set than capturedErrors, because it is not reset until
// the end of the batch. This is needed to propagate errors correctly if a
// subtree fails more than once.
var failedBoundaries=null;// Error boundaries that captured an error during the current commit.
var commitPhaseBoundaries=null;var firstUncaughtError=null;var didFatal=false;var isCommitting=false;var isUnmounting=false;// Used for performance tracking.
var interruptedBy=null;function resetContextStack(){// Reset the stack
reset$1();// Reset the cursors
resetContext();resetHostContainer();}function commitAllHostEffects(){while(nextEffect!==null){{ReactDebugCurrentFiber.setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&~(Callback|Err|ContentReset|Ref|PerformedWork);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{isUnmounting=true;commitDeletion(nextEffect);isUnmounting=false;break;}}nextEffect=nextEffect.nextEffect;}{ReactDebugCurrentFiber.resetCurrentFiber();}}function commitAllLifeCycles(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(current,nextEffect);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}if(effectTag&Err){recordEffect();commitErrorHandling(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.
// I'm not actually sure this matters because we can't reset firstEffect
// and lastEffect since they're on every node, not just the effectful
// ones. So we have to clean everything as we reuse nodes anyway.
nextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect
// tags to reason about the current life-cycle.
nextEffect=next;}}function commitRoot(finishedWork){// We keep track of this so that captureError can collect any boundaries
// that capture an error during the commit phase. The reason these aren't
// local to this function is because errors that occur during cWU are
// captured elsewhere, to prevent the unmount from being interrupted.
isWorking=true;isCommitting=true;startCommitTimer();var root=finishedWork.stateNode;!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.isReadyForCommit=false;// Reset this to null before calling lifecycles
ReactCurrentOwner.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit();// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var didError=false;var _error=void 0;{invokeGuardedCallback$1(null,commitAllHostEffects,null);if(hasCaughtError()){didError=true;_error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit();// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError=false;var _error2=void 0;{invokeGuardedCallback$1(null,commitAllLifeCycles,null);if(hasCaughtError()){_didError=true;_error2=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}isCommitting=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();if(typeof onCommitRoot==='function'){onCommitRoot(finishedWork.stateNode);}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}// If we caught any errors during this commit, schedule their boundaries
// to update.
if(commitPhaseBoundaries){commitPhaseBoundaries.forEach(scheduleErrorRecovery);commitPhaseBoundaries=null;}if(firstUncaughtError!==null){var _error3=firstUncaughtError;firstUncaughtError=null;onUncaughtError(_error3);}var remainingTime=root.current.expirationTime;if(remainingTime===NoWork){capturedErrors=null;failedBoundaries=null;}return remainingTime;}function resetExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.expirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}// Check for pending updates.
var newExpirationTime=getUpdateExpirationTime(workInProgress);// TODO: Calls need to visit stateNode
// Bubble up the earliest expiration time.
var child=workInProgress.child;while(child!==null){if(child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>child.expirationTime)){newExpirationTime=child.expirationTime;}child=child.sibling;}workInProgress.expirationTime=newExpirationTime;}function completeUnitOfWork(workInProgress){while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=completeWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}var returnFiber=workInProgress['return'];var siblingFiber=workInProgress.sibling;resetExpirationTime(workInProgress,nextRenderExpirationTime);if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
return next;}if(returnFiber!==null){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
var root=workInProgress.stateNode;root.isReadyForCommit=true;return null;}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function performFailedUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginFailedWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function workLoop(expirationTime){if(capturedErrors!==null){// If there are unhandled errors, switch to the slow work loop.
// TODO: How to avoid this check in the fast path? Maybe the renderer
// could keep track of which roots have unhandled errors and call a
// forked version of renderRoot.
slowWorkLoopThatChecksForFailedWork(expirationTime);return;}if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function slowWorkLoopThatChecksForFailedWork(expirationTime){if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}}function renderRootCatchBlock(root,failedWork,boundary,expirationTime){// We're going to restart the error boundary that captured the error.
// Conceptually, we're unwinding the stack. We need to unwind the
// context stack, too.
unwindContexts(failedWork,boundary);// Restart the error boundary using a forked version of
// performUnitOfWork that deletes the boundary's children. The entire
// failed subree will be unmounted. During the commit phase, a special
// lifecycle method is called on the error boundary, which triggers
// a re-render.
nextUnitOfWork=performFailedUnitOfWork(boundary);// Continue working.
workLoop(expirationTime);}function renderRoot(root,expirationTime){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;// We're about to mutate the work-in-progress tree. If the root was pending
// commit, it no longer is: we'll need to complete it again.
root.isReadyForCommit=false;// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(root!==nextRoot||expirationTime!==nextRenderExpirationTime||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetContextStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,expirationTime);}startWorkLoopTimer(nextUnitOfWork);var didError=false;var error=null;{invokeGuardedCallback$1(null,workLoop,null,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();}}// An error was thrown during the render phase.
while(didError){if(didFatal){// This was a fatal error. Don't attempt to recover from it.
firstUncaughtError=error;break;}var failedWork=nextUnitOfWork;if(failedWork===null){// An error was thrown but there's no current unit of work. This can
// happen during the commit phase if there's a bug in the renderer.
didFatal=true;continue;}// "Capture" the error by finding the nearest boundary. If there is no
// error boundary, we use the root.
var boundary=captureError(failedWork,error);!(boundary!==null)?invariant(false,'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didFatal){// The error we just captured was a fatal error. This happens
// when the error propagates to the root more than once.
continue;}didError=false;error=null;{invokeGuardedCallback$1(null,renderRootCatchBlock,null,root,failedWork,boundary,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();continue;}}// We're finished working. Exit the error loop.
break;}var uncaughtError=firstUncaughtError;// We're done performing work. Time to clean up.
stopWorkLoopTimer(interruptedBy);interruptedBy=null;isWorking=false;didFatal=false;firstUncaughtError=null;if(uncaughtError!==null){onUncaughtError(uncaughtError);}return root.isReadyForCommit?root.current.alternate:null;}// Returns the boundary that captured the error, or null if the error is ignored
function captureError(failedWork,error){// It is no longer valid because we exited the user code.
ReactCurrentOwner.current=null;{ReactDebugCurrentFiber.resetCurrentFiber();}// Search for the nearest error boundary.
var boundary=null;// Passed to logCapturedError()
var errorBoundaryFound=false;var willRetry=false;var errorBoundaryName=null;// Host containers are a special case. If the failed work itself is a host
// container, then it acts as its own boundary. In all other cases, we
// ignore the work itself and only search through the parents.
if(failedWork.tag===HostRoot){boundary=failedWork;if(isFailedBoundary(failedWork)){// If this root already failed, there must have been an error when
// attempting to unmount it. This is a worst-case scenario and
// should only be possible if there's a bug in the renderer.
didFatal=true;}}else{var node=failedWork['return'];while(node!==null&&boundary===null){if(node.tag===ClassComponent){var instance=node.stateNode;if(typeof instance.componentDidCatch==='function'){errorBoundaryFound=true;errorBoundaryName=getComponentName(node);// Found an error boundary!
boundary=node;willRetry=true;}}else if(node.tag===HostRoot){// Treat the root like a no-op error boundary
boundary=node;}if(isFailedBoundary(node)){// This boundary is already in a failed state.
// If we're currently unmounting, that means this error was
// thrown while unmounting a failed subtree. We should ignore
// the error.
if(isUnmounting){return null;}// If we're in the commit phase, we should check to see if
// this boundary already captured an error during this commit.
// This case exists because multiple errors can be thrown during
// a single commit without interruption.
if(commitPhaseBoundaries!==null&&(commitPhaseBoundaries.has(node)||node.alternate!==null&&commitPhaseBoundaries.has(node.alternate))){// If so, we should ignore this error.
return null;}// The error should propagate to the next boundary -— we keep looking.
boundary=null;willRetry=false;}node=node['return'];}}if(boundary!==null){// Add to the collection of failed boundaries. This lets us know that
// subsequent errors in this subtree should propagate to the next boundary.
if(failedBoundaries===null){failedBoundaries=new Set();}failedBoundaries.add(boundary);// This method is unsafe outside of the begin and complete phases.
// We might be in the commit phase when an error is captured.
// The risk is that the return path from this Fiber may not be accurate.
// That risk is acceptable given the benefit of providing users more context.
var _componentStack=getStackAddendumByWorkInProgressFiber(failedWork);var _componentName=getComponentName(failedWork);// Add to the collection of captured errors. This is stored as a global
// map of errors and their component stack location keyed by the boundaries
// that capture them. We mostly use this Map as a Set; it's a Map only to
// avoid adding a field to Fiber to store the error.
if(capturedErrors===null){capturedErrors=new Map();}var capturedError={componentName:_componentName,componentStack:_componentStack,error:error,errorBoundary:errorBoundaryFound?boundary.stateNode:null,errorBoundaryFound:errorBoundaryFound,errorBoundaryName:errorBoundaryName,willRetry:willRetry};capturedErrors.set(boundary,capturedError);try{logCapturedError(capturedError);}catch(e){// Prevent cycle if logCapturedError() throws.
// A cycle may still occur if logCapturedError renders a component that throws.
var suppressLogging=e&&e.suppressReactErrorLogging;if(!suppressLogging){console.error(e);}}// If we're in the commit phase, defer scheduling an update on the
// boundary until after the commit is complete
if(isCommitting){if(commitPhaseBoundaries===null){commitPhaseBoundaries=new Set();}commitPhaseBoundaries.add(boundary);}else{// Otherwise, schedule an update now.
// TODO: Is this actually necessary during the render phase? Is it
// possible to unwind and continue rendering at the same priority,
// without corrupting internal state?
scheduleErrorRecovery(boundary);}return boundary;}else if(firstUncaughtError===null){// If no boundary is found, we'll need to throw the error
firstUncaughtError=error;}return null;}function hasCapturedError(fiber){// TODO: capturedErrors should store the boundary instance, to avoid needing
// to check the alternate.
return capturedErrors!==null&&(capturedErrors.has(fiber)||fiber.alternate!==null&&capturedErrors.has(fiber.alternate));}function isFailedBoundary(fiber){// TODO: failedBoundaries should store the boundary instance, to avoid
// needing to check the alternate.
return failedBoundaries!==null&&(failedBoundaries.has(fiber)||fiber.alternate!==null&&failedBoundaries.has(fiber.alternate));}function commitErrorHandling(effectfulFiber){var capturedError=void 0;if(capturedErrors!==null){capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);if(capturedError==null){if(effectfulFiber.alternate!==null){effectfulFiber=effectfulFiber.alternate;capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);}}}!(capturedError!=null)?invariant(false,'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(effectfulFiber.tag){case ClassComponent:var instance=effectfulFiber.stateNode;var info={componentStack:capturedError.componentStack};// Allow the boundary to handle the error, usually by scheduling
// an update to itself
instance.componentDidCatch(capturedError.error,info);return;case HostRoot:if(firstUncaughtError===null){firstUncaughtError=capturedError.error;}return;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}}function unwindContexts(from,to){var node=from;while(node!==null){switch(node.tag){case ClassComponent:popContextProvider(node);break;case HostComponent:popHostContext(node);break;case HostRoot:popHostContainer(node);break;case HostPortal:popHostContainer(node);break;}if(node===to||node.alternate===to){stopFailedWorkTimer(node);break;}else{stopWorkTimer(node);}node=node['return'];}}function computeAsyncExpiration(){// Given the current clock time, returns an expiration time. We use rounding
// to batch like updates together.
// Should complete within ~1000ms. 1200ms max.
var currentTime=recalculateCurrentTime();var expirationMs=1000;var bucketSizeMs=200;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}function computeExpirationForFiber(fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;
expirationTime=expirationContext;}else if(isWorking){if(isCommitting){// Updates that occur during the commit phase should have sync priority
// by default.
expirationTime=Sync;}else{// Updates during the render phase should expire at the same time as
// the work that is being rendered.
expirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently
// performing work. Calculate a new expiration time.
if(useSyncScheduling&&!(fiber.internalContextTag&AsyncUpdates)){// This is a sync update
expirationTime=Sync;}else{// This is an async update
expirationTime=computeAsyncExpiration();}}return expirationTime;}function scheduleWork(fiber,expirationTime){return scheduleWorkImpl(fiber,expirationTime,false);}function checkRootNeedsClearing(root,fiber,expirationTime){if(!isWorking&&root===nextRoot&&expirationTime<nextRenderExpirationTime){// Restart the root from the top.
if(nextUnitOfWork!==null){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;}nextRoot=null;nextUnitOfWork=null;nextRenderExpirationTime=NoWork;}}function scheduleWorkImpl(fiber,expirationTime,isErrorRecovery){recordScheduleUpdate();{if(!isErrorRecovery&&fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var node=fiber;while(node!==null){// Walk the parent path to the root and update each node's
// expiration time.
if(node.expirationTime===NoWork||node.expirationTime>expirationTime){node.expirationTime=expirationTime;}if(node.alternate!==null){if(node.alternate.expirationTime===NoWork||node.alternate.expirationTime>expirationTime){node.alternate.expirationTime=expirationTime;}}if(node['return']===null){if(node.tag===HostRoot){var root=node.stateNode;checkRootNeedsClearing(root,fiber,expirationTime);requestWork(root,expirationTime);checkRootNeedsClearing(root,fiber,expirationTime);}else{{if(!isErrorRecovery&&fiber.tag===ClassComponent){warnAboutUpdateOnUnmounted(fiber);}}return;}}node=node['return'];}}function scheduleErrorRecovery(fiber){scheduleWorkImpl(fiber,Sync,true);}function recalculateCurrentTime(){// Subtract initial time so it fits inside 32bits
var ms=now()-startTime;mostRecentCurrentTime=msToExpirationTime(ms);return mostRecentCurrentTime;}function deferredUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=computeAsyncExpiration();try{return fn();}finally{expirationContext=previousExpirationContext;}}function syncUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn();}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var callbackExpirationTime=NoWork;var callbackID=-1;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=1000;var nestedUpdateCount=0;var timeHeuristicForUnitOfWork=1;function scheduleCallbackWithExpiration(expirationTime){if(callbackExpirationTime!==NoWork){// A callback is already scheduled. Check its expiration time (timeout).
if(expirationTime>callbackExpirationTime){// Existing callback has sufficient timeout. Exit.
return;}else{// Existing callback has insufficient timeout. Cancel and schedule a
// new one.
cancelDeferredCallback(callbackID);}// The request callback timer is already running. Don't start a new one.
}else{startRequestCallbackTimer();}// Compute a timeout for the given expiration time.
var currentMs=now()-startTime;var expirationMs=expirationTimeToMs(expirationTime);var timeout=expirationMs-currentMs;callbackExpirationTime=expirationTime;callbackID=scheduleDeferredCallback(performAsyncWork,{timeout:timeout});}// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.remainingExpirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.
root.remainingExpirationTime=expirationTime;}}if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
nextFlushedRoot=root;nextFlushedExpirationTime=Sync;performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performWork(Sync,null);}else{scheduleCallbackWithExpiration(expirationTime);}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
var previousFlushedRoot=nextFlushedRoot;if(previousFlushedRoot!==null&&previousFlushedRoot===highestPriorityRoot){nestedUpdateCount++;}else{// Reset whenever we switch roots.
nestedUpdateCount=0;}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){performWork(NoWork,dl);}function performWork(minExpirationTime,dl){deadline=dl;// Keep working on roots until there's no more work, or until the we reach
// the deadline.
findHighestPriorityRoot();if(enableUserTimingAPI&&deadline!==null){var didExpire=nextFlushedExpirationTime<recalculateCurrentTime();stopRequestCallbackTimer(didExpire);}while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||nextFlushedExpirationTime<=minExpirationTime)&&!deadlineDidExpire){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);// Find the next highest priority work.
findHighestPriorityRoot();}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(deadline!==null){callbackExpirationTime=NoWork;callbackID=-1;}// If there's work left over, schedule a new callback.
if(nextFlushedExpirationTime!==NoWork){scheduleCallbackWithExpiration(nextFlushedExpirationTime);}// Clean-up.
deadline=null;deadlineDidExpire=false;nestedUpdateCount=0;if(hasUnhandledError){var _error4=unhandledError;unhandledError=null;hasUnhandledError=false;throw _error4;}}function performWorkOnRoot(root,expirationTime){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
// TODO: Pass current time as argument to renderRoot, commitRoot
if(expirationTime<=recalculateCurrentTime()){// Flush sync work.
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(finishedWork);}else{root.finishedWork=null;finishedWork=renderRoot(root,expirationTime);if(finishedWork!==null){// We've completed the root. Commit it.
root.remainingExpirationTime=commitRoot(finishedWork);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(_finishedWork);}else{root.finishedWork=null;_finishedWork=renderRoot(root,expirationTime);if(_finishedWork!==null){// We've completed the root. Check the deadline one more time
// before committing.
if(!shouldYield()){// Still time left. Commit the root.
root.remainingExpirationTime=commitRoot(_finishedWork);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield(){if(deadline===null){return false;}if(deadline.timeRemaining()>timeHeuristicForUnitOfWork){// Disregard deadline.didTimeout. Only expired work should be flushed
// during a timeout. This path is only hit for non-expired work.
return false;}deadlineDidExpire=true;return true;}// TODO: Not happy about this hook. Conceptually, renderRoot should return a
// tuple of (isReadyForCommit, didError, error)
function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.remainingExpirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performWork(Sync,null);}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn();}finally{isUnbatchingUpdates=false;}}return fn();}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;performWork(Sync,null);}}return{computeAsyncExpiration:computeAsyncExpiration,computeExpirationForFiber:computeExpirationForFiber,scheduleWork:scheduleWork,batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,flushSync:flushSync,deferredUpdates:deferredUpdates};};{var didWarnAboutNestedUpdates=false;}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
function getContextForSubtree(parentComponent){if(!parentComponent){return emptyObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);return isContextProvider(fiber)?processChildContext(fiber,parentContext):parentContext;}var ReactFiberReconciler$1=function ReactFiberReconciler$1(config){var getPublicInstance=config.getPublicInstance;var _ReactFiberScheduler=ReactFiberScheduler(config),computeAsyncExpiration=_ReactFiberScheduler.computeAsyncExpiration,computeExpirationForFiber=_ReactFiberScheduler.computeExpirationForFiber,scheduleWork=_ReactFiberScheduler.scheduleWork,batchedUpdates=_ReactFiberScheduler.batchedUpdates,unbatchedUpdates=_ReactFiberScheduler.unbatchedUpdates,flushSync=_ReactFiberScheduler.flushSync,deferredUpdates=_ReactFiberScheduler.deferredUpdates;function scheduleTopLevelUpdate(current,element,callback){{if(ReactDebugCurrentFiber.phase==='render'&&ReactDebugCurrentFiber.current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warning(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(ReactDebugCurrentFiber.current)||'Unknown');}}callback=callback===undefined?null:callback;{warning(callback===null||typeof callback==='function','render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}var expirationTime=void 0;// Check if the top-level element is an async wrapper component. If so,
// treat updates to the root as async. This is a bit weird but lets us
// avoid a separate `renderAsync` API.
if(enableAsyncSubtreeAPI&&element!=null&&element.type!=null&&element.type.prototype!=null&&element.type.prototype.unstable_isAsyncReactComponent===true){expirationTime=computeAsyncExpiration();}else{expirationTime=computeExpirationForFiber(current);}var update={expirationTime:expirationTime,partialState:{element:element},callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(current,update);scheduleWork(current,expirationTime);}function findHostInstance(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}return{createContainer:function createContainer(containerInfo,hydrate){return createFiberRoot(containerInfo,hydrate);},updateContainer:function updateContainer(element,container,parentComponent,callback){// TODO: If this is a nested container, this won't be the root.
var current=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}scheduleTopLevelUpdate(current,element,callback);},batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,deferredUpdates:deferredUpdates,flushSync:flushSync,getPublicRootInstance:function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}},findHostInstance:findHostInstance,findHostInstanceWithNoPortals:function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},injectIntoDevTools:function injectIntoDevTools(devToolsConfig){var _findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function findHostInstanceByFiber(fiber){return findHostInstance(fiber);},findFiberByHostInstance:function findFiberByHostInstance(instance){if(!_findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return _findFiberByHostInstance(instance);}}));}};};var ReactFiberReconciler$2=Object.freeze({default:ReactFiberReconciler$1});var ReactFiberReconciler$3=ReactFiberReconciler$2&&ReactFiberReconciler$1||ReactFiberReconciler$2;// TODO: bundle Flow types with the package.
// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler=ReactFiberReconciler$3['default']?ReactFiberReconciler$3['default']:ReactFiberReconciler$3;function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}// TODO: this is special because it gets imported during build.
var ReactVersion='16.2.0';// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.
{if(ExecutionEnvironment.canUseDOM&&typeof requestAnimationFrame!=='function'){warning(false,'React depends on requestAnimationFrame. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}var hasNativePerformanceNow=(typeof performance==='undefined'?'undefined':_typeof(performance))==='object'&&typeof performance.now==='function';var now=void 0;if(hasNativePerformanceNow){now=function now(){return performance.now();};}else{now=function now(){return Date.now();};}// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC=void 0;var cIC=void 0;if(!ExecutionEnvironment.canUseDOM){rIC=function rIC(frameCallback){return setTimeout(function(){frameCallback({timeRemaining:function timeRemaining(){return Infinity;}});});};cIC=function cIC(timeoutID){clearTimeout(timeoutID);};}else if(typeof requestIdleCallback!=='function'||typeof cancelIdleCallback!=='function'){// Polyfill requestIdleCallback and cancelIdleCallback
var scheduledRICCallback=null;var isIdleScheduled=false;var timeoutTime=-1;var isAnimationFrameScheduled=false;var frameDeadline=0;// We start out assuming that we run at 30fps but then the heuristic tracking
// will adjust this value to a faster fps if we get more frequent animation
// frames.
var previousFrameTime=33;var activeFrameTime=33;var frameDeadlineObject;if(hasNativePerformanceNow){frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){// We assume that if we have a performance timer that the rAF callback
// gets a performance timer value. Not sure if this is always true.
var remaining=frameDeadline-performance.now();return remaining>0?remaining:0;}};}else{frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){// Fallback to Date.now()
var remaining=frameDeadline-Date.now();return remaining>0?remaining:0;}};}// We use the postMessage trick to defer idle work until after the repaint.
var messageKey='__reactIdleCallback$'+Math.random().toString(36).slice(2);var idleTick=function idleTick(event){if(event.source!==window||event.data!==messageKey){return;}isIdleScheduled=false;var currentTime=now();if(frameDeadline-currentTime<=0){// There's no time left in this idle period. Check if the callback has
// a timeout and whether it's been exceeded.
if(timeoutTime!==-1&&timeoutTime<=currentTime){// Exceeded the timeout. Invoke the callback even though there's no
// time left.
frameDeadlineObject.didTimeout=true;}else{// No timeout.
if(!isAnimationFrameScheduled){// Schedule another animation callback so we retry later.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}// Exit without invoking the callback.
return;}}else{// There's still time left in this idle period.
frameDeadlineObject.didTimeout=false;}timeoutTime=-1;var callback=scheduledRICCallback;scheduledRICCallback=null;if(callback!==null){callback(frameDeadlineObject);}};// Assumes that we have addEventListener in this environment. Might need
// something better for old IE.
window.addEventListener('message',idleTick,false);var animationTick=function animationTick(rafTime){isAnimationFrameScheduled=false;var nextFrameTime=rafTime-frameDeadline+activeFrameTime;if(nextFrameTime<activeFrameTime&&previousFrameTime<activeFrameTime){if(nextFrameTime<8){// Defensive coding. We don't support higher frame rates than 120hz.
// If we get lower than that, it is probably a bug.
nextFrameTime=8;}// If one frame goes long, then the next one can be short to catch up.
// If two frames are short in a row, then that's an indication that we
// actually have a higher frame rate than what we're currently optimizing.
// We adjust our heuristic dynamically accordingly. For example, if we're
// running on 120hz display or 90hz VR display.
// Take the max of the two in case one of them was an anomaly due to
// missed frame deadlines.
activeFrameTime=nextFrameTime<previousFrameTime?previousFrameTime:nextFrameTime;}else{previousFrameTime=nextFrameTime;}frameDeadline=rafTime+activeFrameTime;if(!isIdleScheduled){isIdleScheduled=true;window.postMessage(messageKey,'*');}};rIC=function rIC(callback,options){// This assumes that we only schedule one callback at a time because that's
// how Fiber uses it.
scheduledRICCallback=callback;if(options!=null&&typeof options.timeout==='number'){timeoutTime=now()+options.timeout;}if(!isAnimationFrameScheduled){// If rAF didn't already schedule one, we need to schedule a frame.
// TODO: If this rAF doesn't materialize because the browser throttles, we
// might want to still have setTimeout trigger rIC as a backup to ensure
// that we keep performing work.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}return 0;};cIC=function cIC(){scheduledRICCallback=null;isIdleScheduled=false;timeoutTime=-1;};}else{rIC=window.requestIdleCallback;cIC=window.cancelIdleCallback;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function lowPriorityWarning(){};{var printWarning=function printWarning(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function lowPriorityWarning(condition,format){if(format===undefined){throw new Error('`warning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(validatedAttributeNameCache.hasOwnProperty(attributeName)){return true;}if(illegalAttributeNameCache.hasOwnProperty(attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning(false,'Invalid attribute name: `%s`',attributeName);}return false;}// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo,value){return value==null||propertyInfo.hasBooleanValue&&!value||propertyInfo.hasNumericValue&&isNaN(value)||propertyInfo.hasPositiveNumericValue&&value<1||propertyInfo.hasOverloadedBooleanValue&&value===false;}/**
 * Operations for dealing with DOM properties.
 *//**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected){{var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod||propertyInfo.mustUseProperty){return node[propertyInfo.propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.hasOverloadedBooleanValue){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldIgnoreValue(propertyInfo,expected)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldIgnoreValue(propertyInfo,expected)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.hasBooleanValue){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldIgnoreValue(propertyInfo,expected)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value){var propertyInfo=getPropertyInfo(name);if(propertyInfo&&shouldSetAttribute(name,value)){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,value);}else if(shouldIgnoreValue(propertyInfo,value)){deleteValueForProperty(node,name);return;}else if(propertyInfo.mustUseProperty){// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyInfo.propertyName]=value;}else{var attributeName=propertyInfo.attributeName;var namespace=propertyInfo.attributeNamespace;// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
if(namespace){node.setAttributeNS(namespace,attributeName,''+value);}else if(propertyInfo.hasBooleanValue||propertyInfo.hasOverloadedBooleanValue&&value===true){node.setAttribute(attributeName,'');}else{node.setAttribute(attributeName,''+value);}}}else{setValueForAttribute(node,name,shouldSetAttribute(name,value)?value:null);return;}{}}function setValueForAttribute(node,name,value){if(!isAttributeNameSafe(name)){return;}if(value==null){node.removeAttribute(name);}else{node.setAttribute(name,''+value);}{}}/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForAttribute(node,name){node.removeAttribute(name);}/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForProperty(node,name){var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,undefined);}else if(propertyInfo.mustUseProperty){var propName=propertyInfo.propertyName;if(propertyInfo.hasBooleanValue){node[propName]=false;}else{node[propName]='';}}else{node.removeAttribute(propertyInfo.attributeName);}}else{node.removeAttribute(name);}}var ReactControlledValuePropTypes={checkPropTypes:null};{var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function value(props,propName,componentName){if(!props[propName]||hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function checked(props,propName,componentName){if(!props[propName]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props,getStack){checkPropTypes(propTypes,props,'prop',tagName,getStack);};}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$3=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var value=props.value;var checked=props.checked;var hostProps=_assign({// Make sure we set .type before any other properties (setting .value
// before .type means .value is lost in IE11 and below)
type:undefined,// Make sure we set .step before .value (setting .value before .step
// means .value is rounded on mount, based upon step precision)
step:undefined,// Make sure we set .min & .max before .value (to ensure proper order
// in corner cases such as min or max deriving from value, e.g. Issue #7170)
min:undefined,max:undefined},props,{defaultChecked:undefined,defaultValue:undefined,value:value!=null?value:node._wrapperState.initialValue,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props,getCurrentFiberStackAddendum$3);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnValueDefaultValue=true;}}var defaultValue=props.defaultValue;var node=element;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:props.value!=null?props.value:defaultValue,controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){warning(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){warning(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=props.value;if(value!=null){if(value===0&&node.value===''){node.value='0';// Note: IE9 reports a number inputs as 'text', so check props instead.
}else if(props.type==='number'){// Simulate `input.valueAsNumber`. IE9 does not support it
var valueAsNumber=parseFloat(node.value)||0;if(// eslint-disable-next-line
value!=valueAsNumber||// eslint-disable-next-line
value==valueAsNumber&&node.value!=value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else if(node.value!==''+value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else{if(props.value==null&&props.defaultValue!=null){// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
if(node.defaultValue!==''+props.defaultValue){node.defaultValue=''+props.defaultValue;}}if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props){var node=element;// Detach value from defaultValue. We won't do anything if we're working on
// submit or reset inputs as those values & defaultValues are linked. They
// are not resetable nodes so this operation doesn't matter and actually
// removes browser-default values (eg "Submit Query") when no value is
// provided.
switch(props.type){case'submit':case'reset':break;case'color':case'date':case'datetime':case'datetime-local':case'month':case'time':case'week':// This fixes the no-show issue on iOS Safari and Android Chrome:
// https://github.com/facebook/react/issues/7233
node.value='';node.value=node.defaultValue;break;default:node.value=node.value;break;}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}node.defaultChecked=!node.defaultChecked;node.defaultChecked=!node.defaultChecked;if(name!==''){node.name=name;}}function restoreControlledState$1(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}function flattenChildren(children){var content='';// Flatten children and warn if they aren't strings or numbers;
// invalid types are ignored.
// We can silently skip them because invalid DOM nesting warning
// catches these cases in Fiber.
React.Children.forEach(children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){content+=child;}});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){// TODO (yungsters): Remove support for `selected` in <option>.
{warning(props.selected==null,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',props.value);}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$4=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerName$3();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props,getCurrentFiberStackAddendum$4);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=''+propValue;var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}var value=props.value;node._wrapperState={initialValue:value!=null?value:props.defaultValue,wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;// After the initial mount, we control selected-ness manually so don't pass
// this value down
node._wrapperState.initialValue=undefined;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:''+node._wrapperState.initialValue});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props,getCurrentFiberStackAddendum$5);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning(false,'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=''+children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:''+initialValue};}function updateWrapper$1(element,props){var node=element;var value=props.value;if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=''+value;// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null){node.defaultValue=newValue;}}if(props.defaultValue!=null){node.defaultValue=props.defaultValue;}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp *//**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var warnValidStyle=emptyFunction;{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var warnHyphenatedStyleName=function warnHyphenatedStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported style property %s. Did you mean %s?%s',name,camelizeStyleName(name),getStack());};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',name,name.charAt(0).toUpperCase()+name.slice(1),getStack());};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value,getStack){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.%s',name,value.replace(badStyleValueWithSemicolonPattern,''),getStack());};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value,getStack){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning(false,'`NaN` is an invalid value for the `%s` css style property.%s',name,getStack());};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value,getStack){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning(false,'`Infinity` is an invalid value for the `%s` css style property.%s',name,getStack());};warnValidStyle=function warnValidStyle(name,value,getStack){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name,getStack);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name,getStack);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value,getStack);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value,getStack);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value,getStack);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 *//**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles,getStack){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName],getStack);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML$1='__html';function assertValidProps(tag,props,getStack){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,getStack()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{warning(props.suppressContentEditableWarning||!props.contentEditable||props.children==null,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.%s',getStack());}!(props.style==null||_typeof(props.style)==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',getStack()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;function getStackAddendum(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperty(tagName,name){if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',name,getStackAddendum());warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',name,correctName,getStackAddendum());warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum());warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}else if(invalidProps.length>1){warning(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function getStackAddendum$1(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.%s',type,getStackAddendum$1());}else{warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.%s',type,getStackAddendum$1());}}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite','class':'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime','default':'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType','for':'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2','in':'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform','typeof':'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};function getStackAddendum$2(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}{var warnedProperties$1={};var hasOwnProperty$1=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var validateProperty$1=function validateProperty$1(tagName,name,value,canUseEventSystem){if(hasOwnProperty$1.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning(false,'Invalid event handler property `%s`. Did you mean `%s`?%s',name,registrationName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){warning(false,'Unknown event handler property `%s`. It will be ignored.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){warning(false,'Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.%s',name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){warning(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.%s',typeof value==='undefined'?'undefined':_typeof(value),getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}var isReserved=isReservedProp(name);// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning(false,'Invalid DOM property `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.%s',name,lowerCasedName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&!shouldAttributeAcceptBooleanValue(name)){if(value){warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.%s',value,name,name,value,name,getStackAddendum$2());}else{warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',value,name,name,value,name,name,name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(!shouldSetAttribute(name,value)){warnedProperties$1[name]=true;return false;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,canUseEventSystem){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}else if(unknownProps.length>1){warning(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$2=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var getStack=emptyFunction.thatReturns('');{getStack=getCurrentFiberStackAddendum$2;var warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true};var validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;var normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};var warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warning(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};var warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warning(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};var warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warning(false,'Extra attributes from the server: %s',names);};var warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){warning(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',registrationName,registrationName,registrationName,getCurrentFiberStackAddendum$2());}else{warning(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener),getCurrentFiberStackAddendum$2());}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
var normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents={topAbort:'abort',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topLoadedData:'loadeddata',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topSeeked:'seeked',topSeeking:'seeking',topStalled:'stalled',topSuspend:'suspend',topTimeUpdate:'timeupdate',topVolumeChange:'volumechange',topWaiting:'waiting'};function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=emptyFunction;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We blacklist it here rather than in the property list because we emit it in SSR.
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(isCustomComponentTag){setValueForAttribute(domElement,propKey,nextProp);}else if(nextProp!=null){// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
setValueForProperty(domElement,propKey,nextProp);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else if(isCustomComponentTag){if(propValue!=null){setValueForAttribute(domElement,propKey,propValue);}else{deleteValueForAttribute(domElement,propKey);}}else if(propValue!=null){setValueForProperty(domElement,propKey,propValue);}else{// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
deleteValueForProperty(domElement,propKey);}}}function createElement$1(type,props,rootContainerElement,parentNamespace){// We create tags in the namespace of their parent container, except HTML
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{var isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
warning(isCustomComponentTag||type===type.toLowerCase(),'<%s /> is using uppercase HTML. Always use lowercase HTML tags '+'in React.',type);}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode$1(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties$1(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}props=rawProps;break;case'source':trapBubbledEvent('topError','error',domElement);props=rawProps;break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);props=rawProps;break;case'details':trapBubbledEvent('topToggle','toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props,getStack);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties$1(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps,getStack);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties$1(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function diffHydratedProperties$1(domElement,tag,rawProps,parentNamespace,rootContainerElement){{var suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;var isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}break;case'source':trapBubbledEvent('topError','error',domElement);break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);break;case'details':trapBubbledEvent('topToggle','toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps,getStack);{var extraAttributeNames=new Set();var attributes=domElement.attributes;for(var i=0;i<attributes.length;i++){var name=attributes[i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else{// Validate that the properties correspond to their expected values.
var serverValue;var propertyInfo;if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var rawHtml=nextProp?nextProp[HTML]||'':'';var serverHTML=domElement.innerHTML;var expectedHTML=normalizeHTML(domElement,rawHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(shouldSetAttribute(propKey,nextProp)){if(propertyInfo=getPropertyInfo(propKey)){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());}else{// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText$1(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText$1(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement$1(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText$1(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState(domElement,tag,props){switch(tag){case'input':restoreControlledState$1(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}var ReactDOMFiberComponent=Object.freeze({createElement:createElement$1,createTextNode:createTextNode$1,setInitialProperties:setInitialProperties$1,diffProperties:diffProperties$1,updateProperties:updateProperties$1,diffHydratedProperties:diffHydratedProperties$1,diffHydratedText:diffHydratedText$1,warnForUnmatchedText:warnForUnmatchedText$1,warnForDeletedHydratableElement:warnForDeletedHydratableElement$1,warnForDeletedHydratableText:warnForDeletedHydratableText$1,warnForInsertedHydratedElement:warnForInsertedHydratedElement$1,warnForInsertedHydratedText:warnForInsertedHydratedText$1,restoreControlledState:restoreControlledState});// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var validateDOMNesting=emptyFunction;{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};var updatedAncestorInfo$1=function updatedAncestorInfo$1(oldInfo,tag,instance){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag,instance:instance};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){warning(childTag==null,'validateDOMNesting: when childText is passed, childTag should be null');childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackAddendum$6();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warning(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warning(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};// TODO: turn this into a named export
validateDOMNesting.updatedAncestorInfo=updatedAncestorInfo$1;// For testing
validateDOMNesting.isTagValidInContext=function(tag,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;return isTagValidWithParent(tag,parentTag)&&!findInvalidAncestorForTag(tag,ancestorInfo);};}var validateDOMNesting$1=validateDOMNesting;// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement=createElement$1;var createTextNode=createTextNode$1;var setInitialProperties=setInitialProperties$1;var diffProperties=diffProperties$1;var updateProperties=updateProperties$1;var diffHydratedProperties=diffHydratedProperties$1;var diffHydratedText=diffHydratedText$1;var warnForUnmatchedText=warnForUnmatchedText$1;var warnForDeletedHydratableElement=warnForDeletedHydratableElement$1;var warnForDeletedHydratableText=warnForDeletedHydratableText$1;var warnForInsertedHydratedElement=warnForInsertedHydratedElement$1;var warnForInsertedHydratedText=warnForInsertedHydratedText$1;var updatedAncestorInfo=validateDOMNesting$1.updatedAncestorInfo;var precacheFiberNode=precacheFiberNode$1;var updateFiberProps=updateFiberProps$1;{var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';if(typeof Map!=='function'||Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warning(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);var eventsEnabled=null;var selectionInformation=null;/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}var DOMRenderer=reactReconciler({getRootHostContext:function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag,null);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;},getChildHostContext:function getChildHostContext(parentHostContext,type){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type,null);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);},getPublicInstance:function getPublicInstance(instance){return instance;},prepareForCommit:function prepareForCommit(){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);},resetAfterCommit:function resetAfterCommit(){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;},createInstance:function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting$1(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;},appendInitialChild:function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);},finalizeInitialChildren:function finalizeInitialChildren(domElement,type,props,rootContainerInstance){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);},prepareUpdate:function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);},shouldSetTextContent:function shouldSetTextContent(type,props){return type==='textarea'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&typeof props.dangerouslySetInnerHTML.__html==='string';},shouldDeprioritizeSubtree:function shouldDeprioritizeSubtree(type,props){return!!props.hidden;},createTextInstance:function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting$1(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;},now:now,mutation:{commitMount:function commitMount(domElement,type,newProps,internalInstanceHandle){domElement.focus();},commitUpdate:function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);},resetTextContent:function resetTextContent(domElement){domElement.textContent='';},commitTextUpdate:function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;},appendChild:function appendChild(parentInstance,child){parentInstance.appendChild(child);},appendChildToContainer:function appendChildToContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,container);}else{container.appendChild(child);}},insertBefore:function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);},insertInContainerBefore:function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}},removeChild:function removeChild(parentInstance,child){parentInstance.removeChild(child);},removeChildFromContainer:function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}},hydration:{canHydrateInstance:function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;},canHydrateTextInstance:function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;},getNextHydratableSibling:function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;},getFirstHydratableChild:function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;},hydrateInstance:function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);},hydrateTextInstance:function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);},didNotMatchHydratedContainerTextInstance:function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}},didNotMatchHydratedTextInstance:function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}},didNotHydrateContainerInstance:function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===1){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}},didNotHydrateInstance:function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===1){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}},didNotFindHydratableContainerInstance:function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}},didNotFindHydratableContainerTextInstance:function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}},didNotFindHydratableInstance:function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}},didNotFindHydratableTextInstance:function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}},scheduleDeferredCallback:rIC,cancelDeferredCallback:cIC,useSyncScheduling:!enableAsyncSchedulingByDefaultInReactDOM});injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);var warnedAboutHydrateAPI=false;function renderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){warning(hostInstance.parentNode===container,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));warning(!hasNonRootReactChild||isRootRenderedBySomeReact,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');warning(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY','render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}var root=container._reactRootContainer;if(!root){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warning(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}var newRoot=DOMRenderer.createContainer(container,shouldHydrate);root=container._reactRootContainer=newRoot;// Initial mount should not be batched.
DOMRenderer.unbatchedUpdates(function(){DOMRenderer.updateContainer(children,newRoot,parentComponent,callback);});}else{DOMRenderer.updateContainer(children,root,parentComponent,callback);}return DOMRenderer.getPublicRootInstance(root);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}function ReactRoot(container,hydrate){var root=DOMRenderer.createContainer(container,hydrate);this._reactRootContainer=root;}ReactRoot.prototype.render=function(children,callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(children,root,null,callback);};ReactRoot.prototype.unmount=function(callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(null,root,null,callback);};var ReactDOM={createPortal:createPortal,findDOMNode:function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;warning(warnedAboutRefsInRender,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner)||'A component');owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}var inst=get(componentOrElement);if(inst){return DOMRenderer.findHostInstance(inst);}if(typeof componentOrElement.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Element appears to be neither ReactComponent nor DOMNode. Keys: %s',Object.keys(componentOrElement));}},hydrate:function hydrate(element,container,callback){// TODO: throw or warn if we couldn't hydrate?
return renderSubtreeIntoContainer(null,element,container,true,callback);},render:function render(element,container,callback){return renderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return renderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function unmountComponentAtNode(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);warning(!renderedByDifferentReact,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}// Unmount should not be batched.
DOMRenderer.unbatchedUpdates(function(){renderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===1&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;warning(!hasNonRootReactChild,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:createPortal,unstable_batchedUpdates:batchedUpdates,unstable_deferredUpdates:DOMRenderer.deferredUpdates,flushSync:DOMRenderer.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// For TapEventPlugin which is popular in open source
EventPluginHub:EventPluginHub,// Used by test-utils
EventPluginRegistry:EventPluginRegistry,EventPropagators:EventPropagators,ReactControlledComponent:ReactControlledComponent,ReactDOMComponentTree:ReactDOMComponentTree,ReactDOMEventListener:ReactDOMEventListener}};if(enableCreateRoot){ReactDOM.createRoot=function createRoot(container,options){var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,hydrate);};}var foundDevTools=DOMRenderer.injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&ExecutionEnvironment.canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3['default']?ReactDOM$3['default']:ReactDOM$3;module.exports=reactDom;})();}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(51);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(53);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createBrowserHistory = __webpack_require__(57);

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _Router = __webpack_require__(18);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  _inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createBrowserHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { BrowserRouter as Router }`.');
  };

  BrowserRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(_react2.default.Component);

BrowserRouter.propTypes = {
  basename: _propTypes2.default.string,
  forceRefresh: _propTypes2.default.bool,
  getUserConfirmation: _propTypes2.default.func,
  keyLength: _propTypes2.default.number,
  children: _propTypes2.default.node
};

exports.default = BrowserRouter;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(6);
var invariant = __webpack_require__(8);
var warning = __webpack_require__(12);
var assign = __webpack_require__(7);

var ReactPropTypesSecret = __webpack_require__(15);
var checkPropTypes = __webpack_require__(14);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(6);
var invariant = __webpack_require__(8);
var ReactPropTypesSecret = __webpack_require__(15);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(16);

var _PathUtils = __webpack_require__(9);

var _createTransitionManager = __webpack_require__(17);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(32);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;

    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createHashHistory = __webpack_require__(59);

var _createHashHistory2 = _interopRequireDefault(_createHashHistory);

var _Router = __webpack_require__(18);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  _inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createHashHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { HashRouter as Router }`.');
  };

  HashRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(_react2.default.Component);

HashRouter.propTypes = {
  basename: _propTypes2.default.string,
  getUserConfirmation: _propTypes2.default.func,
  hashType: _propTypes2.default.oneOf(['hashbang', 'noslash', 'slash']),
  children: _propTypes2.default.node
};

exports.default = HashRouter;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(16);

var _PathUtils = __webpack_require__(9);

var _createTransitionManager = __webpack_require__(17);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(32);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MemoryRouter = __webpack_require__(61);

var _MemoryRouter2 = _interopRequireDefault(_MemoryRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _MemoryRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createMemoryHistory = __webpack_require__(62);

var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

var _Router = __webpack_require__(19);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  _inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createMemoryHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { MemoryRouter as Router }`.');
  };

  MemoryRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(_react2.default.Component);

MemoryRouter.propTypes = {
  initialEntries: _propTypes2.default.array,
  initialIndex: _propTypes2.default.number,
  getUserConfirmation: _propTypes2.default.func,
  keyLength: _propTypes2.default.number,
  children: _propTypes2.default.node
};

exports.default = MemoryRouter;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__(9);

var _LocationUtils = __webpack_require__(16);

var _createTransitionManager = __webpack_require__(17);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Route = __webpack_require__(34);

var _Route2 = _interopRequireDefault(_Route);

var _Link = __webpack_require__(33);

var _Link2 = _interopRequireDefault(_Link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref.ariaCurrent,
      rest = _objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']);

  return _react2.default.createElement(_Route2.default, {
    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return _react2.default.createElement(_Link2.default, _extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(' ') : className,
        style: isActive ? _extends({}, style, activeStyle) : style,
        'aria-current': isActive && ariaCurrent
      }, rest));
    }
  });
};

NavLink.propTypes = {
  to: _Link2.default.propTypes.to,
  exact: _propTypes2.default.bool,
  strict: _propTypes2.default.bool,
  location: _propTypes2.default.object,
  activeClassName: _propTypes2.default.string,
  className: _propTypes2.default.string,
  activeStyle: _propTypes2.default.object,
  style: _propTypes2.default.object,
  isActive: _propTypes2.default.func,
  ariaCurrent: _propTypes2.default.oneOf(['page', 'step', 'location', 'true'])
};

NavLink.defaultProps = {
  activeClassName: 'active',
  ariaCurrent: 'true'
};

exports.default = NavLink;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isarray = __webpack_require__(65);

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;
module.exports.parse = parse;
module.exports.compile = compile;
module.exports.tokensToFunction = tokensToFunction;
module.exports.tokensToRegExp = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Prompt = __webpack_require__(67);

var _Prompt2 = _interopRequireDefault(_Prompt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Prompt2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  _inherits(Prompt, _React$Component);

  function Prompt() {
    _classCallCheck(this, Prompt);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, 'You should not use <Prompt> outside a <Router>');

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(_react2.default.Component);

Prompt.propTypes = {
  when: _propTypes2.default.bool,
  message: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      block: _propTypes2.default.func.isRequired
    }).isRequired
  }).isRequired
};

exports.default = Prompt;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Redirect = __webpack_require__(69);

var _Redirect2 = _interopRequireDefault(_Redirect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Redirect2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _history = __webpack_require__(70);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  _inherits(Redirect, _React$Component);

  function Redirect() {
    _classCallCheck(this, Redirect);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, 'You should not use <Redirect> outside a <Router>');

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = (0, _history.createLocation)(prevProps.to);
    var nextTo = (0, _history.createLocation)(this.props.to);

    if ((0, _history.locationsAreEqual)(prevTo, nextTo)) {
      (0, _warning2.default)(false, 'You tried to redirect to the same route you\'re currently on: ' + ('"' + nextTo.pathname + nextTo.search + '"'));
      return;
    }

    this.perform();
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var _props = this.props,
        push = _props.push,
        to = _props.to;

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(_react2.default.Component);

Redirect.propTypes = {
  push: _propTypes2.default.bool,
  from: _propTypes2.default.string,
  to: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      push: _propTypes2.default.func.isRequired,
      replace: _propTypes2.default.func.isRequired
    }).isRequired,
    staticContext: _propTypes2.default.object
  }).isRequired
};

exports.default = Redirect;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPath = exports.parsePath = exports.locationsAreEqual = exports.createLocation = exports.createMemoryHistory = exports.createHashHistory = exports.createBrowserHistory = undefined;

var _LocationUtils = __webpack_require__(13);

Object.defineProperty(exports, 'createLocation', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.createLocation;
  }
});
Object.defineProperty(exports, 'locationsAreEqual', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.locationsAreEqual;
  }
});

var _PathUtils = __webpack_require__(10);

Object.defineProperty(exports, 'parsePath', {
  enumerable: true,
  get: function get() {
    return _PathUtils.parsePath;
  }
});
Object.defineProperty(exports, 'createPath', {
  enumerable: true,
  get: function get() {
    return _PathUtils.createPath;
  }
});

var _createBrowserHistory2 = __webpack_require__(71);

var _createBrowserHistory3 = _interopRequireDefault(_createBrowserHistory2);

var _createHashHistory2 = __webpack_require__(72);

var _createHashHistory3 = _interopRequireDefault(_createHashHistory2);

var _createMemoryHistory2 = __webpack_require__(73);

var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.createBrowserHistory = _createBrowserHistory3.default;
exports.createHashHistory = _createHashHistory3.default;
exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(13);

var _PathUtils = __webpack_require__(10);

var _createTransitionManager = __webpack_require__(21);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(36);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;

    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(13);

var _PathUtils = __webpack_require__(10);

var _createTransitionManager = __webpack_require__(21);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(36);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__(10);

var _LocationUtils = __webpack_require__(13);

var _createTransitionManager = __webpack_require__(21);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _StaticRouter = __webpack_require__(75);

var _StaticRouter2 = _interopRequireDefault(_StaticRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _StaticRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _PathUtils = __webpack_require__(9);

var _Router = __webpack_require__(19);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var normalizeLocation = function normalizeLocation(object) {
  var _object$pathname = object.pathname,
      pathname = _object$pathname === undefined ? '/' : _object$pathname,
      _object$search = object.search,
      search = _object$search === undefined ? '' : _object$search,
      _object$hash = object.hash,
      hash = _object$hash === undefined ? '' : _object$hash;

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return _extends({}, location, {
    pathname: (0, _PathUtils.addLeadingSlash)(basename) + location.pathname
  });
};

var stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = (0, _PathUtils.addLeadingSlash)(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var createLocation = function createLocation(location) {
  return typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : normalizeLocation(location);
};

var createURL = function createURL(location) {
  return typeof location === 'string' ? location : (0, _PathUtils.createPath)(location);
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    (0, _invariant2.default)(false, 'You cannot %s with <StaticRouter>', methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  _inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return (0, _PathUtils.addLeadingSlash)(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = 'PUSH';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = 'REPLACE';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { StaticRouter as Router }`.');
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ['basename', 'context', 'location']);

    var history = {
      createHref: this.createHref,
      action: 'POP',
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler('go'),
      goBack: staticHandler('goBack'),
      goForward: staticHandler('goForward'),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return _react2.default.createElement(_Router2.default, _extends({}, props, { history: history }));
  };

  return StaticRouter;
}(_react2.default.Component);

StaticRouter.propTypes = {
  basename: _propTypes2.default.string,
  context: _propTypes2.default.object.isRequired,
  location: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
};
StaticRouter.defaultProps = {
  basename: '',
  location: '/'
};
StaticRouter.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = StaticRouter;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Switch = __webpack_require__(77);

var _Switch2 = _interopRequireDefault(_Switch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Switch2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _matchPath = __webpack_require__(20);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  _inherits(Switch, _React$Component);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, 'You should not use <Switch> outside a <Router>');
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    _react2.default.Children.forEach(children, function (element) {
      if (!_react2.default.isValidElement(element)) return;

      var _element$props = element.props,
          pathProp = _element$props.path,
          exact = _element$props.exact,
          strict = _element$props.strict,
          sensitive = _element$props.sensitive,
          from = _element$props.from;

      var path = pathProp || from;

      if (match == null) {
        child = element;
        match = path ? (0, _matchPath2.default)(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }) : route.match;
      }
    });

    return match ? _react2.default.cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(_react2.default.Component);

Switch.contextTypes = {
  router: _propTypes2.default.shape({
    route: _propTypes2.default.object.isRequired
  }).isRequired
};
Switch.propTypes = {
  children: _propTypes2.default.node,
  location: _propTypes2.default.object
};

exports.default = Switch;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _matchPath = __webpack_require__(20);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _matchPath2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _withRouter = __webpack_require__(80);

var _withRouter2 = _interopRequireDefault(_withRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _withRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = __webpack_require__(81);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _Route = __webpack_require__(35);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/**
 * A public higher-order component to access the imperative API
 */
var withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutProperties(props, ['wrappedComponentRef']);

    return _react2.default.createElement(_Route2.default, { render: function render(routeComponentProps) {
        return _react2.default.createElement(Component, _extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));
      } });
  };

  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: _propTypes2.default.func
  };

  return (0, _hoistNonReactStatics2.default)(C, Component);
};

exports.default = withRouter;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(29);

var _Home = __webpack_require__(83);

var _Home2 = _interopRequireDefault(_Home);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
	this is where your routes are setup
	they are imported into the app.js file
*/

//imported the react-router
/*
	No more backend routes to connect to your front end files
	All front end routes are now done strictly on the front end, through react
*/
exports.default = _react2.default.createElement(
	_reactRouterDom.Switch,
	null,
	_react2.default.createElement(_reactRouterDom.Route, { exact: true, path: "/", component: _Home2.default })
);

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _omdb_api = __webpack_require__(103);

var _omdb_api2 = _interopRequireDefault(_omdb_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // This is the non-babel way to import
// var React = require("react");

// This is the babel way


// fetch does not work for api calls in react
// axios does
// https://medium.com/@thejasonfile/fetch-vs-axios-js-for-making-http-requests-2b261cdd3af5


var Home = function (_Component) {
  _inherits(Home, _Component);

  function Home(props) {
    _classCallCheck(this, Home);

    var _this = _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).call(this, props));

    _this.state = {
      title: undefined
    };
    return _this;
  }

  _createClass(Home, [{
    key: 'searchMovies',
    value: function searchMovies() {
      var _this2 = this;

      if (this.refs.movieSearcher.value.length > 3) {
        (0, _omdb_api2.default)(this.refs.movieSearcher.value.split(" ").join("+").toLowerCase()).then(function (res) {
          console.log(res);
          _this2.setState({
            title: res.data
          });
        });
      }
    }

    // to see your data before render...you need to wrap your request in a componentWillMount() function
    // componentWillMount() {
    //   let api_key = '1a18ddb3'
    //   // let api_url = `http://www.omdbapi.com/?apikey=${api_key}&t=${movie}`
    //   let api_url = `http://www.omdbapi.com/?apikey=${api_key}&t`
    //
    //   axios.get(api_url, {
    //     headers: {
    //       'content-type': 'application/json',
    //       'accept': 'application/json'
    //     }
    //   }).then((results) => {
    //     console.log(results)
    //     this.setState({
    //       title: results.data
    //     })
    //     this.refs.movieSearcher.value = "";
    //   });
    // }

  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      console.log(this.state.title);
      var displayMovieSearch = function displayMovieSearch() {
        if (_this3.state.title) {
          return _react2.default.createElement(
            'div',
            { className: 'movie-search-movie' },
            _react2.default.createElement(
              'div',
              { className: 'movie-poster-div' },
              _react2.default.createElement(
                'a',
                { href: "https://www.imdb.com/title/" + _this3.state.title.imdbID, target: '_blank' },
                _react2.default.createElement('img', { className: 'movie-poster', align: 'center', src: _this3.state.title.Poster }),
                _react2.default.createElement(
                  'p',
                  { className: 'imdb-page-link-tag', align: 'center' },
                  _this3.state.title.Title
                )
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'movie-search-info' },
              _react2.default.createElement(
                'div',
                { className: 'movie-title' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Title: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.Title
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'movie-year' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Year: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.Year
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'movie-plot' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Plot: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.Plot
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'movie-director' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Director: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.Director
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'movie-actors' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Actors: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.Actors
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'movie-genre' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Genre: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.Genre
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'movie-awards' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Awards: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.Awards
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'movie-budget' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Box Office: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.BoxOffice
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'movie-rated' },
                _react2.default.createElement(
                  'span',
                  null,
                  'Rated: '
                ),
                _react2.default.createElement(
                  'span',
                  { style: { color: "slategray" } },
                  _this3.state.title.Rated
                )
              )
            )
          );
        }
      };
      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'h3',
          { className: 'movie-header' },
          'React Movie Searcher'
        ),
        _react2.default.createElement(
          'form',
          null,
          _react2.default.createElement('input', {
            className: 'movie-input',
            type: 'text',
            ref: 'movieSearcher',
            placeholder: 'Type A Movie Title Here',
            onChange: this.searchMovies.bind(this)
          })
        ),
        _react2.default.createElement('br', null),
        displayMovieSearch()
      );
    }
  }]);

  return Home;
}(_react.Component);

exports.default = Home;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(85);

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);
var bind = __webpack_require__(37);
var Axios = __webpack_require__(87);
var defaults = __webpack_require__(22);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(41);
axios.CancelToken = __webpack_require__(101);
axios.isCancel = __webpack_require__(40);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(102);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(22);
var utils = __webpack_require__(4);
var InterceptorManager = __webpack_require__(96);
var dispatchRequest = __webpack_require__(97);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(39);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
  // initialize result and counter
  var block, charCode, idx = 0, map = chars;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);
var transformData = __webpack_require__(98);
var isCancel = __webpack_require__(40);
var defaults = __webpack_require__(22);
var isAbsoluteURL = __webpack_require__(99);
var combineURLs = __webpack_require__(100);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
  );
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(41);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _axios = __webpack_require__(84);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (movie) {
  var api_key = '1a18ddb3';
  var api_url = 'http://www.omdbapi.com/?apikey=' + api_key + '&t=' + movie;
  return _axios2.default.get(api_url, {
    headers: {
      'content-type': 'application/json',
      'accept': 'application/json'
    }
  }).then(function (results) {
    return results;
  });
};

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzZmNzAwYTRhYzAzMTkwMDkzNTkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL2FwcC9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0Jyb3dzZXJSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0hhc2hSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTWVtb3J5Um91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvbWF0Y2hQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy93aXRoUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvcm91dGVzLmpzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL0hvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J0b2EuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovLy8uL2FwcC9hcGkvb21kYl9hcGkuanMiXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJ3YXJuaW5nIiwiY29uZGl0aW9uIiwiZm9ybWF0IiwiYXJncyIsImxlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsIkFycmF5Iiwia2V5IiwidW5kZWZpbmVkIiwiRXJyb3IiLCJ0ZXN0IiwiYXJnSW5kZXgiLCJtZXNzYWdlIiwicmVwbGFjZSIsImNvbnNvbGUiLCJlcnJvciIsIngiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsImJpbmQiLCJpc0J1ZmZlciIsInRvU3RyaW5nIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaXNBcnJheSIsInZhbCIsImNhbGwiLCJpc0FycmF5QnVmZmVyIiwiaXNGb3JtRGF0YSIsIkZvcm1EYXRhIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJyZXN1bHQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc1VuZGVmaW5lZCIsImlzT2JqZWN0IiwiaXNEYXRlIiwiaXNGaWxlIiwiaXNCbG9iIiwiaXNGdW5jdGlvbiIsImlzU3RyZWFtIiwicGlwZSIsImlzVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidHJpbSIsInN0ciIsImlzU3RhbmRhcmRCcm93c2VyRW52IiwibmF2aWdhdG9yIiwicHJvZHVjdCIsIndpbmRvdyIsImRvY3VtZW50IiwiZm9yRWFjaCIsIm9iaiIsImZuIiwiaSIsImwiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlIiwiYXNzaWduVmFsdWUiLCJleHRlbmQiLCJhIiwiYiIsInRoaXNBcmciLCJpbnZhcmlhbnQiLCJjIiwiZCIsImUiLCJmIiwibmFtZSIsImZyYW1lc1RvUG9wIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJlbXB0eUZ1bmN0aW9uIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJsZXR0ZXIiLCJrZXlzIiwiZXJyIiwidGFyZ2V0Iiwic291cmNlIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJ2YWxpZGF0ZUZvcm1hdCIsIl9fZXNNb2R1bGUiLCJhZGRMZWFkaW5nU2xhc2giLCJwYXRoIiwiY2hhckF0Iiwic3RyaXBMZWFkaW5nU2xhc2giLCJzdWJzdHIiLCJoYXNCYXNlbmFtZSIsInByZWZpeCIsIlJlZ0V4cCIsInN0cmlwQmFzZW5hbWUiLCJzdHJpcFRyYWlsaW5nU2xhc2giLCJzbGljZSIsInBhcnNlUGF0aCIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsImhhc2hJbmRleCIsImluZGV4T2YiLCJzZWFyY2hJbmRleCIsImNyZWF0ZVBhdGgiLCJsb2NhdGlvbiIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIl9rZXkiLCJfbGVuMiIsIl9rZXkyIiwiYXBwbHkiLCJjb25jYXQiLCJfZXh0ZW5kcyIsImNyZWF0ZUxvY2F0aW9uIiwic3RhdGUiLCJjdXJyZW50TG9jYXRpb24iLCJkZWNvZGVVUkkiLCJVUklFcnJvciIsImxvY2F0aW9uc0FyZUVxdWFsIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImNvbXBvbmVudE5hbWUiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4Iiwic3RhY2siLCJfcmVzb2x2ZVBhdGhuYW1lIiwiX3Jlc29sdmVQYXRobmFtZTIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3ZhbHVlRXF1YWwiLCJfdmFsdWVFcXVhbDIiLCJfUGF0aFV0aWxzIiwiZGVmYXVsdCIsIl93YXJuaW5nIiwiX3dhcm5pbmcyIiwiY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIiLCJwcm9tcHQiLCJzZXRQcm9tcHQiLCJuZXh0UHJvbXB0IiwiY29uZmlybVRyYW5zaXRpb25UbyIsImFjdGlvbiIsImdldFVzZXJDb25maXJtYXRpb24iLCJjYWxsYmFjayIsImxpc3RlbmVycyIsImFwcGVuZExpc3RlbmVyIiwiaXNBY3RpdmUiLCJsaXN0ZW5lciIsInB1c2giLCJmaWx0ZXIiLCJpdGVtIiwibm90aWZ5TGlzdGVuZXJzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiUm91dGVyIiwiX1JlYWN0JENvbXBvbmVudCIsIl90ZW1wIiwiX3RoaXMiLCJfcmV0IiwibWF0Y2giLCJjb21wdXRlTWF0Y2giLCJwcm9wcyIsImhpc3RvcnkiLCJnZXRDaGlsZENvbnRleHQiLCJyb3V0ZXIiLCJjb250ZXh0Iiwicm91dGUiLCJ1cmwiLCJwYXJhbXMiLCJpc0V4YWN0IiwiY29tcG9uZW50V2lsbE1vdW50IiwiX3RoaXMyIiwiX3Byb3BzIiwiY2hpbGRyZW4iLCJDaGlsZHJlbiIsImNvdW50IiwidW5saXN0ZW4iLCJsaXN0ZW4iLCJzZXRTdGF0ZSIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXh0UHJvcHMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsIm9ubHkiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJpc1JlcXVpcmVkIiwibm9kZSIsImNvbnRleHRUeXBlcyIsImNoaWxkQ29udGV4dFR5cGVzIiwicGF0dGVybkNhY2hlIiwiY2FjaGVMaW1pdCIsImNhY2hlQ291bnQiLCJjb21waWxlUGF0aCIsInBhdHRlcm4iLCJvcHRpb25zIiwiY2FjaGVLZXkiLCJlbmQiLCJzdHJpY3QiLCJzZW5zaXRpdmUiLCJjYWNoZSIsInJlIiwiY29tcGlsZWRQYXR0ZXJuIiwibWF0Y2hQYXRoIiwiX29wdGlvbnMiLCJfb3B0aW9ucyRwYXRoIiwiX29wdGlvbnMkZXhhY3QiLCJleGFjdCIsIl9vcHRpb25zJHN0cmljdCIsIl9vcHRpb25zJHNlbnNpdGl2ZSIsIl9jb21waWxlUGF0aCIsImV4ZWMiLCJyZWR1Y2UiLCJtZW1vIiwiaW5kZXgiLCJ1dGlscyIsIm5vcm1hbGl6ZUhlYWRlck5hbWUiLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInNldENvbnRlbnRUeXBlSWZVbnNldCIsImhlYWRlcnMiLCJnZXREZWZhdWx0QWRhcHRlciIsImFkYXB0ZXIiLCJYTUxIdHRwUmVxdWVzdCIsImRlZmF1bHRzIiwidHJhbnNmb3JtUmVxdWVzdCIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwidHJhbnNmb3JtUmVzcG9uc2UiLCJwYXJzZSIsInRpbWVvdXQiLCJ4c3JmQ29va2llTmFtZSIsInhzcmZIZWFkZXJOYW1lIiwibWF4Q29udGVudExlbmd0aCIsInZhbGlkYXRlU3RhdHVzIiwic3RhdHVzIiwiY29tbW9uIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsIm1ldGhvZCIsImZvckVhY2hNZXRob2RXaXRoRGF0YSIsImNhblVzZURPTSIsImNyZWF0ZUVsZW1lbnQiLCJFeGVjdXRpb25FbnZpcm9ubWVudCIsImNhblVzZVdvcmtlcnMiLCJXb3JrZXIiLCJjYW5Vc2VFdmVudExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImNhblVzZVZpZXdwb3J0Iiwic2NyZWVuIiwiaXNJbldvcmtlciIsIkV2ZW50TGlzdGVuZXIiLCJldmVudFR5cGUiLCJyZW1vdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJjYXB0dXJlIiwicmVnaXN0ZXJEZWZhdWx0IiwiZ2V0QWN0aXZlRWxlbWVudCIsImRvYyIsImFjdGl2ZUVsZW1lbnQiLCJib2R5IiwiaXMiLCJ5Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiaXNUZXh0Tm9kZSIsImNvbnRhaW5zTm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsInBhcmVudE5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiZm9jdXNOb2RlIiwiZm9jdXMiLCJCcm93c2VyUm91dGVyIiwiSGFzaFJvdXRlciIsIkxpbmsiLCJNZW1vcnlSb3V0ZXIiLCJOYXZMaW5rIiwiUHJvbXB0IiwiUmVkaXJlY3QiLCJSb3V0ZSIsIlN0YXRpY1JvdXRlciIsIlN3aXRjaCIsIndpdGhSb3V0ZXIiLCJpc0Fic29sdXRlIiwic3BsaWNlT25lIiwibGlzdCIsImsiLCJwb3AiLCJyZXNvbHZlUGF0aG5hbWUiLCJ0b1BhcnRzIiwiZnJvbVBhcnRzIiwiaXNUb0FicyIsImlzRnJvbUFicyIsIm11c3RFbmRBYnMiLCJoYXNUcmFpbGluZ1NsYXNoIiwibGFzdCIsInVwIiwicGFydCIsInVuc2hpZnQiLCJfdHlwZW9mIiwiaXRlcmF0b3IiLCJ2YWx1ZUVxdWFsIiwiZXZlcnkiLCJhVHlwZSIsImJUeXBlIiwiYVZhbHVlIiwidmFsdWVPZiIsImJWYWx1ZSIsImFLZXlzIiwiYktleXMiLCJldmVudCIsImdldENvbmZpcm1hdGlvbiIsImNvbmZpcm0iLCJzdXBwb3J0c0hpc3RvcnkiLCJ1YSIsInVzZXJBZ2VudCIsInN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UiLCJzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCIsImlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJpc01vZGlmaWVkRXZlbnQiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiaGFuZGxlQ2xpY2siLCJvbkNsaWNrIiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1dHRvbiIsInByZXZlbnREZWZhdWx0IiwiX3RoaXMkcHJvcHMiLCJpbm5lclJlZiIsImhyZWYiLCJjcmVhdGVIcmVmIiwicmVmIiwiZnVuYyIsInN0cmluZyIsImJvb2wiLCJvbmVPZlR5cGUiLCJkZWZhdWx0UHJvcHMiLCJzaGFwZSIsImlzRW1wdHlDaGlsZHJlbiIsIl9yZWYiLCJjb21wdXRlZE1hdGNoIiwiY29tcG9uZW50IiwibmV4dENvbnRleHQiLCJfY29udGV4dCRyb3V0ZXIiLCJzdGF0aWNDb250ZXh0Iiwid3JhcCIsInNldHRsZSIsImJ1aWxkVVJMIiwicGFyc2VIZWFkZXJzIiwiaXNVUkxTYW1lT3JpZ2luIiwiY3JlYXRlRXJyb3IiLCJidG9hIiwieGhyQWRhcHRlciIsImNvbmZpZyIsIlByb21pc2UiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3QiLCJsb2FkRXZlbnQiLCJ4RG9tYWluIiwiWERvbWFpblJlcXVlc3QiLCJvbnByb2dyZXNzIiwiaGFuZGxlUHJvZ3Jlc3MiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJBdXRob3JpemF0aW9uIiwib3BlbiIsInRvVXBwZXJDYXNlIiwicGFyYW1zU2VyaWFsaXplciIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsInN0YXR1c1RleHQiLCJvbmVycm9yIiwiaGFuZGxlRXJyb3IiLCJjb29raWVzIiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwicmVhZCIsInNldFJlcXVlc3RIZWFkZXIiLCJ0b0xvd2VyQ2FzZSIsIm9uRG93bmxvYWRQcm9ncmVzcyIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJ1cGxvYWQiLCJjYW5jZWxUb2tlbiIsInByb21pc2UiLCJ0aGVuIiwib25DYW5jZWxlZCIsImNhbmNlbCIsImFib3J0Iiwic2VuZCIsImVuaGFuY2VFcnJvciIsImNvZGUiLCJpc0NhbmNlbCIsIl9fQ0FOQ0VMX18iLCJDYW5jZWwiLCJnZXRFbGVtZW50QnlJZCIsIm0iLCJwIiwicSIsInIiLCJ0IiwidSIsInYiLCJ3IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwieiIsImlzTW91bnRlZCIsImVucXVldWVGb3JjZVVwZGF0ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlU2V0U3RhdGUiLCJBIiwicmVmcyIsInVwZGF0ZXIiLCJpc1JlYWN0Q29tcG9uZW50IiwiZm9yY2VVcGRhdGUiLCJCIiwiQyIsIkQiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIkUiLCJGIiwidW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50IiwiRyIsImN1cnJlbnQiLCJIIiwiSSIsIl9fc2VsZiIsIl9fc291cmNlIiwiSiIsImciLCJoIiwidHlwZSIsIl9vd25lciIsIksiLCJlc2NhcGUiLCJMIiwiTSIsIk4iLCJrZXlQcmVmaXgiLCJPIiwiUCIsIlEiLCJuZXh0IiwiZG9uZSIsIlIiLCJTIiwiVCIsIlUiLCJ0b0FycmF5IiwiUHVyZUNvbXBvbmVudCIsInVuc3RhYmxlX0FzeW5jQ29tcG9uZW50IiwiRnJhZ21lbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVGYWN0b3J5IiwidmVyc2lvbiIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiUmVhY3RDdXJyZW50T3duZXIiLCJWIiwiVyIsIl9hc3NpZ24iLCJSZWFjdFZlcnNpb24iLCJoYXNTeW1ib2wiLCJSRUFDVF9DQUxMX1RZUEUiLCJSRUFDVF9SRVRVUk5fVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwibG93UHJpb3JpdHlXYXJuaW5nIiwid2FybiIsImxvd1ByaW9yaXR5V2FybmluZyQxIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50Iiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJkaXNwbGF5TmFtZSIsIndhcm5pbmdLZXkiLCJSZWFjdE5vb3BVcGRhdGVRdWV1ZSIsImNvbXBsZXRlU3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJkZXByZWNhdGVkQVBJcyIsInJlcGxhY2VTdGF0ZSIsImRlZmluZURlcHJlY2F0aW9uV2FybmluZyIsIm1ldGhvZE5hbWUiLCJpbmZvIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJmbk5hbWUiLCJDb21wb25lbnREdW1teSIsInB1cmVDb21wb25lbnRQcm90b3R5cGUiLCJBc3luY0NvbXBvbmVudCIsImFzeW5jQ29tcG9uZW50UHJvdG90eXBlIiwiUkVTRVJWRURfUFJPUFMiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiaGFzVmFsaWRSZWYiLCJnZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5IiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsIm93bmVyIiwiZWxlbWVudCIsIl9zdG9yZSIsInByb3BOYW1lIiwiY2hpbGRyZW5MZW5ndGgiLCJjaGlsZEFycmF5IiwiY2xvbmVBbmRSZXBsYWNlS2V5Iiwib2xkRWxlbWVudCIsIm5ld0tleSIsIm5ld0VsZW1lbnQiLCJfc2VsZiIsIl9zb3VyY2UiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwiZ2V0Q3VycmVudFN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImltcGwiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJlc2NhcGVSZWdleCIsImVzY2FwZXJMb29rdXAiLCJlc2NhcGVkU3RyaW5nIiwiZGlkV2FybkFib3V0TWFwcyIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwidGV4dCIsIlBPT0xfU0laRSIsInRyYXZlcnNlQ29udGV4dFBvb2wiLCJnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQiLCJtYXBSZXN1bHQiLCJtYXBGdW5jdGlvbiIsIm1hcENvbnRleHQiLCJ0cmF2ZXJzZUNvbnRleHQiLCJyZWxlYXNlVHJhdmVyc2VDb250ZXh0IiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJpbnZva2VDYWxsYmFjayIsImdldENvbXBvbmVudEtleSIsImNoaWxkIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwic3RlcCIsImlpIiwiYWRkZW5kdW0iLCJjaGlsZHJlblN0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJmb3JFYWNoU2luZ2xlQ2hpbGQiLCJib29rS2VlcGluZyIsImZvckVhY2hDaGlsZHJlbiIsImZvckVhY2hGdW5jIiwiZm9yRWFjaENvbnRleHQiLCJtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0IiwiY2hpbGRLZXkiLCJtYXBwZWRDaGlsZCIsIm1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwiLCJhcnJheSIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImNvdW50Q2hpbGRyZW4iLCJvbmx5Q2hpbGQiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0Q29tcG9uZW50TmFtZSIsImZpYmVyIiwiY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERpc3BsYXlOYW1lIiwiVkFMSURfRlJBR01FTlRfUFJPUFMiLCJNYXAiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImVsZW1lbnRQcm9wcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJjb21wb25lbnRDbGFzcyIsIlByb3BUeXBlcyIsImdldERlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZnJhZ21lbnQiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIl9zdGVwIiwiaGFzIiwiY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsImNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiIsInZhbGlkYXRlZEZhY3RvcnkiLCJjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsIlJlYWN0IiwiUmVhY3RDb21wb25lbnRUcmVlSG9vayIsIlJlYWN0JDIiLCJSZWFjdCQzIiwicmVhY3QiLCJjaGVja0RDRSIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImFhIiwiYmEiLCJkYSIsImVhIiwiZmEiLCJpYSIsIm9hIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0Q2hlY2tlZCIsImlubmVySFRNTCIsInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIsInN0eWxlIiwicGEiLCJ0YSIsIk1VU1RfVVNFX1BST1BFUlRZIiwiSEFTX0JPT0xFQU5fVkFMVUUiLCJIQVNfTlVNRVJJQ19WQUxVRSIsIkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFIiwiSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSIsIkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSIsImluamVjdERPTVByb3BlcnR5Q29uZmlnIiwiUHJvcGVydGllcyIsIkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMiLCJET01BdHRyaWJ1dGVOYW1lcyIsIkRPTU11dGF0aW9uTWV0aG9kcyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJwcm9wZXJ0eU5hbWUiLCJtdXRhdGlvbk1ldGhvZCIsIm11c3RVc2VQcm9wZXJ0eSIsImhhc0Jvb2xlYW5WYWx1ZSIsImhhc051bWVyaWNWYWx1ZSIsImhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlIiwiaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSIsImhhc1N0cmluZ0Jvb2xlYW5WYWx1ZSIsInZhIiwid2EiLCJ4YSIsInlhIiwiemEiLCJBYSIsIkJhIiwiQ2EiLCJEYSIsImFsbG93RnVsbFNjcmVlbiIsImFzeW5jIiwiYXV0b0ZvY3VzIiwiYXV0b1BsYXkiLCJjaGVja2VkIiwiY29scyIsImNvbnRlbnRFZGl0YWJsZSIsImNvbnRyb2xzIiwiZGVmZXIiLCJkaXNhYmxlZCIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZm9ybU5vVmFsaWRhdGUiLCJoaWRkZW4iLCJsb29wIiwibXVsdGlwbGUiLCJtdXRlZCIsIm5vVmFsaWRhdGUiLCJwbGF5c0lubGluZSIsInJlYWRPbmx5IiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvd3MiLCJyb3dTcGFuIiwic2NvcGVkIiwic2VhbWxlc3MiLCJzZWxlY3RlZCIsInNpemUiLCJzdGFydCIsInNwYW4iLCJzcGVsbENoZWNrIiwidGFiSW5kZXgiLCJpdGVtU2NvcGUiLCJhY2NlcHRDaGFyc2V0IiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsInJlbW92ZUF0dHJpYnV0ZSIsImhhc0F0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInZhbGlkaXR5IiwiYmFkSW5wdXQiLCJvd25lckRvY3VtZW50IiwiRWEiLCJ4bGluayIsInhtbCIsIkdhIiwiYXV0b1JldmVyc2UiLCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIiwicHJlc2VydmVBbHBoYSIsInhsaW5rQWN0dWF0ZSIsInhsaW5rQXJjcm9sZSIsInhsaW5rSHJlZiIsInhsaW5rUm9sZSIsInhsaW5rU2hvdyIsInhsaW5rVGl0bGUiLCJ4bGlua1R5cGUiLCJ4bWxCYXNlIiwieG1sTGFuZyIsInhtbFNwYWNlIiwiSGEiLCJJYSIsIl9jYXVnaHRFcnJvciIsIl9oYXNDYXVnaHRFcnJvciIsIl9yZXRocm93RXJyb3IiLCJfaGFzUmV0aHJvd0Vycm9yIiwiaW5qZWN0aW9uIiwiaW5qZWN0RXJyb3JVdGlscyIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsIkphIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yIiwiaGFzQ2F1Z2h0RXJyb3IiLCJjbGVhckNhdWdodEVycm9yIiwicmV0aHJvd0NhdWdodEVycm9yIiwiS2EiLCJMYSIsIk1hIiwiTmEiLCJPYSIsImV4dHJhY3RFdmVudHMiLCJldmVudFR5cGVzIiwiUGEiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyIsIlFhIiwicmVnaXN0cmF0aW9uTmFtZSIsIlJhIiwiU2EiLCJkZXBlbmRlbmNpZXMiLCJUYSIsIlVhIiwiVmEiLCJwbHVnaW5zIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMiLCJyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsImluamVjdEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUiLCJXYSIsIlhhIiwiWWEiLCJaYSIsImN1cnJlbnRUYXJnZXQiLCIkYSIsImFiIiwiYmIiLCJjYiIsIl9kaXNwYXRjaExpc3RlbmVycyIsIl9kaXNwYXRjaEluc3RhbmNlcyIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNQZXJzaXN0ZW50IiwicmVsZWFzZSIsImRiIiwiZ2IiLCJoYiIsImliIiwic3RhdGVOb2RlIiwiamIiLCJrYiIsImxiIiwibWIiLCJnZXRMaXN0ZW5lciIsImVucXVldWVFdmVudHMiLCJwcm9jZXNzRXZlbnRRdWV1ZSIsIm5iIiwiTWF0aCIsInJhbmRvbSIsIm9iIiwicGIiLCJ0YWciLCJxYiIsInJiIiwic2IiLCJwcmVjYWNoZUZpYmVyTm9kZSIsImdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlIiwidXBkYXRlRmliZXJQcm9wcyIsInRiIiwidWIiLCJ2YiIsImRpc3BhdGNoQ29uZmlnIiwid2IiLCJfdGFyZ2V0SW5zdCIsInhiIiwieWIiLCJ6YiIsIkFiIiwiQmIiLCJhbHRlcm5hdGUiLCJDYiIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCIsImFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzIiwiRGIiLCJFYiIsImRvY3VtZW50RWxlbWVudCIsIl9yb290IiwiX3N0YXJ0VGV4dCIsIl9mYWxsYmFja1RleHQiLCJGYiIsIkdiIiwiSGIiLCJJYiIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJpc1RydXN0ZWQiLCJuYXRpdmVFdmVudCIsIkludGVyZmFjZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsInJldHVyblZhbHVlIiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsImRlc3RydWN0b3IiLCJhdWdtZW50Q2xhc3MiLCJKYiIsIktiIiwiZXZlbnRQb29sIiwiTGIiLCJnZXRQb29sZWQiLCJNYiIsIk5iIiwiUGIiLCJWYiIsIldiIiwiZG9jdW1lbnRNb2RlIiwiWGIiLCJZYiIsIm9wZXJhIiwicGFyc2VJbnQiLCJaYiIsIiRiIiwiYWMiLCJiYyIsImJlZm9yZUlucHV0IiwiYnViYmxlZCIsImNhcHR1cmVkIiwiY29tcG9zaXRpb25FbmQiLCJjb21wb3NpdGlvblN0YXJ0IiwiY29tcG9zaXRpb25VcGRhdGUiLCJjYyIsImRjIiwia2V5Q29kZSIsImVjIiwiZGV0YWlsIiwiZmMiLCJnYyIsIndoaWNoIiwiaGMiLCJjaGFyIiwiaWMiLCJqYyIsImtjIiwibGMiLCJtYyIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUiLCJuYyIsImluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQiLCJvYyIsInBjIiwicWMiLCJlbnF1ZXVlU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJyYyIsInNjIiwidGMiLCJ1YyIsImNvbG9yIiwiZGF0ZSIsImRhdGV0aW1lIiwiZW1haWwiLCJtb250aCIsIm51bWJlciIsInJhbmdlIiwidGVsIiwidGltZSIsIndlZWsiLCJ2YyIsIm5vZGVOYW1lIiwid2MiLCJzcmNFbGVtZW50IiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJub2RlVHlwZSIsInhjIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwieWMiLCJ6YyIsIkFjIiwic2V0IiwiZ2V0VmFsdWUiLCJzZXRWYWx1ZSIsInN0b3BUcmFja2luZyIsIl92YWx1ZVRyYWNrZXIiLCJCYyIsIkNjIiwiRGMiLCJjaGFuZ2UiLCJFYyIsIkZjIiwiR2MiLCJIYyIsIkljIiwiSmMiLCJLYyIsIkxjIiwiTWMiLCJOYyIsIk9jIiwiUGMiLCIkYyIsImFkIiwiX2lzSW5wdXRFdmVudFN1cHBvcnRlZCIsIl93cmFwcGVyU3RhdGUiLCJjb250cm9sbGVkIiwiZ2V0QXR0cmlidXRlIiwiYmQiLCJ2aWV3IiwiY2QiLCJBbHQiLCJDb250cm9sIiwiTWV0YSIsIlNoaWZ0IiwiZGQiLCJnZXRNb2RpZmllclN0YXRlIiwiZWQiLCJmZCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJwYWdlWCIsInBhZ2VZIiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsImdkIiwibW91c2VFbnRlciIsIm1vdXNlTGVhdmUiLCJoZCIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiaWQiLCJqZCIsImtkIiwiZWZmZWN0VGFnIiwibGQiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwibWQiLCJuZCIsInNpYmxpbmciLCJvZCIsInBkIiwicWQiLCJyZCIsInRhcmdldEluc3QiLCJhbmNlc3RvcnMiLCJjb250YWluZXJJbmZvIiwic2QiLCJ0b3BMZXZlbFR5cGUiLCJ0ZCIsInVkIiwidmQiLCJ3ZCIsInhkIiwiX2VuYWJsZWQiLCJfaGFuZGxlVG9wTGV2ZWwiLCJzZXRIYW5kbGVUb3BMZXZlbCIsInNldEVuYWJsZWQiLCJpc0VuYWJsZWQiLCJ0cmFwQnViYmxlZEV2ZW50IiwidHJhcENhcHR1cmVkRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwieWQiLCJ6ZCIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsIkFkIiwiQmQiLCJhbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwiQ2QiLCJEZCIsInRvcEFib3J0IiwidG9wQW5pbWF0aW9uRW5kIiwidG9wQW5pbWF0aW9uSXRlcmF0aW9uIiwidG9wQW5pbWF0aW9uU3RhcnQiLCJ0b3BCbHVyIiwidG9wQ2FuY2VsIiwidG9wQ2FuUGxheSIsInRvcENhblBsYXlUaHJvdWdoIiwidG9wQ2hhbmdlIiwidG9wQ2xpY2siLCJ0b3BDbG9zZSIsInRvcENvbXBvc2l0aW9uRW5kIiwidG9wQ29tcG9zaXRpb25TdGFydCIsInRvcENvbXBvc2l0aW9uVXBkYXRlIiwidG9wQ29udGV4dE1lbnUiLCJ0b3BDb3B5IiwidG9wQ3V0IiwidG9wRG91YmxlQ2xpY2siLCJ0b3BEcmFnIiwidG9wRHJhZ0VuZCIsInRvcERyYWdFbnRlciIsInRvcERyYWdFeGl0IiwidG9wRHJhZ0xlYXZlIiwidG9wRHJhZ092ZXIiLCJ0b3BEcmFnU3RhcnQiLCJ0b3BEcm9wIiwidG9wRHVyYXRpb25DaGFuZ2UiLCJ0b3BFbXB0aWVkIiwidG9wRW5jcnlwdGVkIiwidG9wRW5kZWQiLCJ0b3BFcnJvciIsInRvcEZvY3VzIiwidG9wSW5wdXQiLCJ0b3BLZXlEb3duIiwidG9wS2V5UHJlc3MiLCJ0b3BLZXlVcCIsInRvcExvYWRlZERhdGEiLCJ0b3BMb2FkIiwidG9wTG9hZGVkTWV0YWRhdGEiLCJ0b3BMb2FkU3RhcnQiLCJ0b3BNb3VzZURvd24iLCJ0b3BNb3VzZU1vdmUiLCJ0b3BNb3VzZU91dCIsInRvcE1vdXNlT3ZlciIsInRvcE1vdXNlVXAiLCJ0b3BQYXN0ZSIsInRvcFBhdXNlIiwidG9wUGxheSIsInRvcFBsYXlpbmciLCJ0b3BQcm9ncmVzcyIsInRvcFJhdGVDaGFuZ2UiLCJ0b3BTY3JvbGwiLCJ0b3BTZWVrZWQiLCJ0b3BTZWVraW5nIiwidG9wU2VsZWN0aW9uQ2hhbmdlIiwidG9wU3RhbGxlZCIsInRvcFN1c3BlbmQiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BUaW1lVXBkYXRlIiwidG9wVG9nZ2xlIiwidG9wVG91Y2hDYW5jZWwiLCJ0b3BUb3VjaEVuZCIsInRvcFRvdWNoTW92ZSIsInRvcFRvdWNoU3RhcnQiLCJ0b3BUcmFuc2l0aW9uRW5kIiwidG9wVm9sdW1lQ2hhbmdlIiwidG9wV2FpdGluZyIsInRvcFdoZWVsIiwiRWQiLCJGZCIsIkdkIiwiSGQiLCJJZCIsImZpcnN0Q2hpbGQiLCJKZCIsInRleHRDb250ZW50Iiwib2Zmc2V0IiwibmV4dFNpYmxpbmciLCJLZCIsIkxkIiwiTWQiLCJzZWxlY3QiLCJOZCIsIk9kIiwiUGQiLCJRZCIsIlJkIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJnZXRTZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJTZCIsIm9uU2VsZWN0IiwiVGQiLCJhbmltYXRpb25OYW1lIiwiZWxhcHNlZFRpbWUiLCJwc2V1ZG9FbGVtZW50IiwiVWQiLCJjbGlwYm9hcmREYXRhIiwiVmQiLCJXZCIsImNoYXJDb2RlIiwiWGQiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwiWWQiLCJaZCIsInJlcGVhdCIsImxvY2FsZSIsIiRkIiwiZGF0YVRyYW5zZmVyIiwiYWUiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiYmUiLCJjZSIsImRlbHRhWCIsIndoZWVsRGVsdGFYIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwiZGVsdGFaIiwiZGVsdGFNb2RlIiwiZGUiLCJlZSIsImZlIiwiU2ltcGxlRXZlbnRQbHVnaW4iLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJDaGFuZ2VFdmVudFBsdWdpbiIsIlNlbGVjdEV2ZW50UGx1Z2luIiwiQmVmb3JlSW5wdXRFdmVudFBsdWdpbiIsImdlIiwiaGUiLCJTZXQiLCJpZSIsIlgiLCJqZSIsImtlIiwibGUiLCJtZSIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsIm5lIiwib2UiLCJjdXJzb3IiLCJwZSIsInFlIiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJZIiwibWVtb2l6ZWRTdGF0ZSIsInVwZGF0ZVF1ZXVlIiwibWVtb2l6ZWRQcm9wcyIsInBlbmRpbmdQcm9wcyIsImludGVybmFsQ29udGV4dFRhZyIsImxhc3RFZmZlY3QiLCJmaXJzdEVmZmVjdCIsIm5leHRFZmZlY3QiLCJleHBpcmF0aW9uVGltZSIsInNlIiwidGUiLCJ1ZSIsInZlIiwid2UiLCJoYW5kbGVyIiwieGUiLCJ5ZSIsInBlbmRpbmdDaGlsZHJlbiIsInplIiwiQWUiLCJCZSIsIkNlIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJpbmplY3QiLCJvbkNvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0RmliZXJVbm1vdW50IiwiRGUiLCJFZSIsIkZlIiwiYmFzZVN0YXRlIiwiZmlyc3QiLCJjYWxsYmFja0xpc3QiLCJoYXNGb3JjZVVwZGF0ZSIsImlzSW5pdGlhbGl6ZWQiLCJHZSIsIkhlIiwiSWUiLCJKZSIsImlzUmVwbGFjZSIsImlzRm9yY2VkIiwiS2UiLCJMZSIsIm5leHRDYWxsYmFjayIsImFkb3B0Q2xhc3NJbnN0YW5jZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJtb3VudENsYXNzSW5zdGFuY2UiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZUNsYXNzSW5zdGFuY2UiLCJjb21wb25lbnREaWRVcGRhdGUiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiUWUiLCJSZSIsIlNlIiwiVGUiLCJVZSIsIlZlIiwiV2UiLCJYZSIsIlllIiwiWmUiLCJfc3RyaW5nUmVmIiwiJGUiLCJhZiIsImJmIiwiY2YiLCJkZiIsInBlbmRpbmdDb250ZXh0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJ1c2VTeW5jU2NoZWR1bGluZyIsInNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUiLCJwdXNoSG9zdENvbnRleHQiLCJwdXNoSG9zdENvbnRhaW5lciIsImVudGVySHlkcmF0aW9uU3RhdGUiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJPYiIsImJlZ2luV29yayIsImh5ZHJhdGUiLCJiZWdpbkZhaWxlZFdvcmsiLCJlZiIsImNyZWF0ZUluc3RhbmNlIiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJwcmVwYXJlVXBkYXRlIiwicGVyc2lzdGVuY2UiLCJnZXRSb290SG9zdENvbnRhaW5lciIsInBvcEhvc3RDb250ZXh0IiwiZ2V0SG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGFpbmVyIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIiwicG9wSHlkcmF0aW9uU3RhdGUiLCJtdXRhdGlvbiIsImNvbXBsZXRlV29yayIsImZmIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRUZXh0VXBkYXRlIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImNvbW1pdFJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRQbGFjZW1lbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRMaWZlQ3ljbGVzIiwiY29tbWl0QXR0YWNoUmVmIiwiY29tbWl0RGV0YWNoUmVmIiwiZ2YiLCJoZiIsImdldENoaWxkSG9zdENvbnRleHQiLCJnZXRSb290SG9zdENvbnRleHQiLCJyZXNldEhvc3RDb250YWluZXIiLCJqZiIsImh5ZHJhdGlvbiIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCIsImh5ZHJhdGVJbnN0YW5jZSIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJrZiIsIlFiIiwiamEiLCJpc1JlYWR5Rm9yQ29tbWl0IiwieWciLCJ6ZyIsIkFnIiwiTmUiLCJPZSIsIlNjIiwiQmciLCJUYyIsIkRnIiwiRWciLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudFN0YWNrIiwiY2EiLCJRYyIsImhhIiwicWEiLCJGZyIsInJnIiwiR2ciLCJVYyIsInJhIiwiUmMiLCJlYiIsInFnIiwiYWRkIiwiX2RlYnVnT3duZXIiLCJfZGVidWdTb3VyY2UiLCJlcnJvckJvdW5kYXJ5IiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJ3aWxsUmV0cnkiLCJzdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nIiwiVmMiLCJrYSIsIkhnIiwiUmIiLCJJZyIsIm5leHRTY2hlZHVsZWRSb290IiwicmVtYWluaW5nRXhwaXJhdGlvblRpbWUiLCJzYSIsImxhIiwiU2IiLCJtYSIsIm5hIiwiV2MiLCJQZSIsIlRiIiwiSmciLCJYYyIsIktnIiwiZmIiLCJZYyIsIlViIiwiWmMiLCJGYSIsImZpbmlzaGVkV29yayIsInRpbWVSZW1haW5pbmciLCJMZyIsIk1lIiwic2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrIiwiY2FuY2VsRGVmZXJyZWRDYWxsYmFjayIsInByZXBhcmVGb3JDb21taXQiLCJDZyIsInJlc2V0QWZ0ZXJDb21taXQiLCJjb21wdXRlQXN5bmNFeHBpcmF0aW9uIiwiY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciIsInNjaGVkdWxlV29yayIsImJhdGNoZWRVcGRhdGVzIiwidW5iYXRjaGVkVXBkYXRlcyIsImZsdXNoU3luYyIsImRlZmVycmVkVXBkYXRlcyIsImxmIiwiY3JlYXRlQ29udGFpbmVyIiwidXBkYXRlQ29udGFpbmVyIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsIm1mIiwibmYiLCJvZiIsInBmIiwicWYiLCJwZXJmb3JtYW5jZSIsInJmIiwic2YiLCJ0ZiIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJ1ZiIsInZmIiwid2YiLCJ4ZiIsInlmIiwiemYiLCJBZiIsIkJmIiwiZGlkVGltZW91dCIsIkNmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiRGYiLCJwb3N0TWVzc2FnZSIsInNldFRpbWVvdXQiLCJJbmZpbml0eSIsImNsZWFyVGltZW91dCIsIkVmIiwiRmYiLCJHZiIsIkhmIiwiSWYiLCJpc05hTiIsIkpmIiwic2V0QXR0cmlidXRlTlMiLCJLZiIsIkxmIiwibWluIiwibWF4IiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbENoZWNrZWQiLCJNZiIsIk5mIiwiT2YiLCJwYXJzZUZsb2F0IiwiUGYiLCJRZiIsIlJmIiwiU2YiLCJkZWZhdWx0U2VsZWN0ZWQiLCJUZiIsIndhc011bHRpcGxlIiwiVWYiLCJWZiIsIldmIiwiWGYiLCJZZiIsImh0bWwiLCJtYXRobWwiLCJzdmciLCJaZiIsIiRmIiwiYWciLCJiZyIsIk1TQXBwIiwiZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24iLCJuYW1lc3BhY2VVUkkiLCJjZyIsImxhc3RDaGlsZCIsIm5vZGVWYWx1ZSIsImRnIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3JkZXJJbWFnZU91dHNldCIsImJvcmRlckltYWdlU2xpY2UiLCJib3JkZXJJbWFnZVdpZHRoIiwiYm94RmxleCIsImJveEZsZXhHcm91cCIsImJveE9yZGluYWxHcm91cCIsImNvbHVtbkNvdW50IiwiY29sdW1ucyIsImZsZXgiLCJmbGV4R3JvdyIsImZsZXhQb3NpdGl2ZSIsImZsZXhTaHJpbmsiLCJmbGV4TmVnYXRpdmUiLCJmbGV4T3JkZXIiLCJncmlkUm93IiwiZ3JpZFJvd0VuZCIsImdyaWRSb3dTcGFuIiwiZ3JpZFJvd1N0YXJ0IiwiZ3JpZENvbHVtbiIsImdyaWRDb2x1bW5FbmQiLCJncmlkQ29sdW1uU3BhbiIsImdyaWRDb2x1bW5TdGFydCIsImZvbnRXZWlnaHQiLCJsaW5lQ2xhbXAiLCJsaW5lSGVpZ2h0Iiwib3BhY2l0eSIsIm9yZGVyIiwib3JwaGFucyIsInRhYlNpemUiLCJ3aWRvd3MiLCJ6SW5kZXgiLCJ6b29tIiwiZmlsbE9wYWNpdHkiLCJmbG9vZE9wYWNpdHkiLCJzdG9wT3BhY2l0eSIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwiZWciLCJzdWJzdHJpbmciLCJmZyIsInNldFByb3BlcnR5IiwiZ2ciLCJtZW51aXRlbSIsImFyZWEiLCJiYXNlIiwiYnIiLCJjb2wiLCJlbWJlZCIsImhyIiwiaW1nIiwiaW5wdXQiLCJrZXlnZW4iLCJsaW5rIiwibWV0YSIsInBhcmFtIiwidHJhY2siLCJ3YnIiLCJoZyIsImlnIiwiamciLCJrZyIsImxnIiwibWciLCJuZyIsImNyZWF0ZUVsZW1lbnROUyIsIm9nIiwiY3JlYXRlVGV4dE5vZGUiLCJwZyIsIl9faHRtbCIsIm9uY2xpY2siLCJzZyIsInRnIiwidWciLCJ2ZyIsIndnIiwic2V0SW5pdGlhbFByb3BlcnRpZXMiLCJkaWZmUHJvcGVydGllcyIsInVwZGF0ZVByb3BlcnRpZXMiLCJkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzIiwiZGlmZkh5ZHJhdGVkVGV4dCIsIndhcm5Gb3JVbm1hdGNoZWRUZXh0Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9ybSIsInhnIiwiTWciLCJOZyIsIk9nIiwiWiIsInRhZ05hbWUiLCJyYW5nZUNvdW50IiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInNldEVuZCIsImxlZnQiLCJzY3JvbGxMZWZ0IiwidG9wIiwic2Nyb2xsVG9wIiwiZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJQZyIsIl9yZWFjdFJvb3RDb250YWluZXIiLCJRZyIsIlJnIiwidW5tb3VudCIsIlNnIiwiY3JlYXRlUG9ydGFsIiwiZmluZERPTU5vZGUiLCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJ1bnN0YWJsZV9jcmVhdGVQb3J0YWwiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX2RlZmVycmVkVXBkYXRlcyIsIkV2ZW50UGx1Z2luSHViIiwiRXZlbnRQbHVnaW5SZWdpc3RyeSIsIkV2ZW50UHJvcGFnYXRvcnMiLCJSZWFjdENvbnRyb2xsZWRDb21wb25lbnQiLCJSZWFjdERPTUNvbXBvbmVudFRyZWUiLCJSZWFjdERPTUV2ZW50TGlzdGVuZXIiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsIlRnIiwiVWciLCJpc05vZGUiLCJOb2RlIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwiY2FtZWxpemVTdHlsZU5hbWUiLCJjaGVja01hc2siLCJiaXRtYXNrIiwiRE9NUHJvcGVydHlJbmplY3Rpb24iLCJkb21Qcm9wZXJ0eUNvbmZpZyIsIkluamVjdGlvbiIsInByb3BlcnRpZXMiLCJsb3dlckNhc2VkIiwicHJvcENvbmZpZyIsInByb3BlcnR5SW5mbyIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiUk9PVF9BVFRSSUJVVEVfTkFNRSIsInNob3VsZFNldEF0dHJpYnV0ZSIsImlzUmVzZXJ2ZWRQcm9wIiwic2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlIiwiZ2V0UHJvcGVydHlJbmZvIiwiSFRNTERPTVByb3BlcnR5Q29uZmlnIiwiSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEiLCJOUyIsIkFUVFJTIiwiU1ZHRE9NUHJvcGVydHlDb25maWciLCJDQU1FTElaRSIsImNhcGl0YWxpemUiLCJ0b2tlbiIsIm9yaWdpbmFsIiwicmVhY3ROYW1lIiwiUmVhY3RFcnJvclV0aWxzIiwiaW5qZWN0ZWRFcnJvclV0aWxzIiwiZnVuY0FyZ3MiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2IiwiZGlkRXJyb3IiLCJjYWxsQ2FsbGJhY2siLCJldnRUeXBlIiwiZGlkU2V0RXJyb3IiLCJpc0Nyb3NzT3JpZ2luRXJyb3IiLCJvbkVycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJldnQiLCJpbml0RXZlbnQiLCJldmVudFBsdWdpbk9yZGVyIiwibmFtZXNUb1BsdWdpbnMiLCJyZWNvbXB1dGVQbHVnaW5PcmRlcmluZyIsInBsdWdpbk5hbWUiLCJwbHVnaW5Nb2R1bGUiLCJwbHVnaW5JbmRleCIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50TmFtZSIsInB1Ymxpc2hFdmVudEZvclBsdWdpbiIsInBoYXNlTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUiLCJwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZSIsImxvd2VyQ2FzZWROYW1lIiwib25kYmxjbGljayIsImluamVjdGVkRXZlbnRQbHVnaW5PcmRlciIsImluamVjdGVkTmFtZXNUb1BsdWdpbnMiLCJpc09yZGVyaW5nRGlydHkiLCJpbmplY3Rpb24kMiIsImluamVjdENvbXBvbmVudFRyZWUiLCJJbmplY3RlZCIsInZhbGlkYXRlRXZlbnREaXNwYXRjaGVzIiwiZGlzcGF0Y2hMaXN0ZW5lcnMiLCJkaXNwYXRjaEluc3RhbmNlcyIsImxpc3RlbmVyc0lzQXJyIiwibGlzdGVuZXJzTGVuIiwiaW5zdGFuY2VzSXNBcnIiLCJpbnN0YW5jZXNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJzaW11bGF0ZWQiLCJpbnN0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJhcnIiLCJzY29wZSIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImluamVjdGlvbiQxIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJldmVudHMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkNhbGxDb21wb25lbnQiLCJDYWxsSGFuZGxlclBoYXNlIiwiUmV0dXJuQ29tcG9uZW50IiwicmFuZG9tS2V5IiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsImludGVybmFsRXZlbnRIYW5kbGVyc0tleSIsInByZWNhY2hlRmliZXJOb2RlJDEiLCJob3N0SW5zdCIsInBhcmVudHMiLCJjbG9zZXN0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSQxIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyQxIiwiZ2V0UGFyZW50IiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiYXJnRnJvbSIsImFyZ1RvIiwicGF0aEZyb20iLCJwYXRoVG8iLCJfYWx0ZXJuYXRlIiwiX2kiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0IiwicGFyZW50SW5zdCIsImFjY3VtdWxhdGVEaXNwYXRjaGVzIiwiaWdub3JlZERpcmVjdGlvbiIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlIiwibGVhdmUiLCJlbnRlciIsImNvbnRlbnRLZXkiLCJnZXRUZXh0Q29udGVudEFjY2Vzc29yIiwiY29tcG9zaXRpb25TdGF0ZSIsImluaXRpYWxpemUiLCJnZXRUZXh0IiwicmVzZXQiLCJnZXREYXRhIiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSIsImlzUHJveHlTdXBwb3J0ZWQiLCJQcm94eSIsIkVWRU5UX1BPT0xfU0laRSIsInNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzIiwiRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNFdmVudCIsIm5vcm1hbGl6ZSIsImdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24iLCJDbGFzcyIsIlN1cGVyIiwiYWRkRXZlbnRQb29saW5nVG8iLCJjb25zdHJ1Y3QiLCJ0aGF0IiwicHJvcCIsImdldFZhbCIsIndhcm5pbmdDb25kaXRpb24iLCJnZXRQb29sZWRFdmVudCIsIm5hdGl2ZUluc3QiLCJFdmVudENvbnN0cnVjdG9yIiwicmVsZWFzZVBvb2xlZEV2ZW50IiwiU3ludGhldGljRXZlbnQkMSIsIkNvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50IiwiZGlzcGF0Y2hNYXJrZXIiLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljSW5wdXRFdmVudCIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJpc1ByZXN0byIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwiU1BBQ0VCQVJfQ09ERSIsIlNQQUNFQkFSX0NIQVIiLCJoYXNTcGFjZUtleXByZXNzIiwiaXNLZXlwcmVzc0NvbW1hbmQiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0IiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kIiwiZ2V0RGF0YUZyb21DdXN0b21FdmVudCIsImlzQ29tcG9zaW5nIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJmYWxsYmFja0RhdGEiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJmaWJlckhvc3RDb21wb25lbnQiLCJSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24iLCJob3N0Q29tcG9uZW50SW1wbCIsInJlc3RvcmVUYXJnZXQiLCJyZXN0b3JlUXVldWUiLCJyZXN0b3JlU3RhdGVPZlRhcmdldCIsImludGVybmFsSW5zdGFuY2UiLCJpbmplY3Rpb24kMyIsInF1ZXVlZFRhcmdldHMiLCJmaWJlckJhdGNoZWRVcGRhdGVzIiwiYm9va2tlZXBpbmciLCJpc05lc3RpbmdCYXRjaGVkIiwiUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb24iLCJpbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzIiwiX2JhdGNoZWRVcGRhdGVzIiwiaW5qZWN0aW9uJDQiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiZWxlbSIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkNPTU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiZ2V0RXZlbnRUYXJnZXQiLCJ1c2VIYXNGZWF0dXJlIiwiaXNFdmVudFN1cHBvcnRlZCIsImV2ZW50TmFtZVN1ZmZpeCIsImlzU3VwcG9ydGVkIiwiaXNDaGVja2FibGUiLCJnZXRUcmFja2VyIiwiZGV0YWNoVHJhY2tlciIsImdldFZhbHVlRnJvbU5vZGUiLCJ0cmFja1ZhbHVlT25Ob2RlIiwidmFsdWVGaWVsZCIsImRlc2NyaXB0b3IiLCJjdXJyZW50VmFsdWUiLCJ0cmFja2VyIiwidXBkYXRlVmFsdWVJZkNoYW5nZWQiLCJsYXN0VmFsdWUiLCJuZXh0VmFsdWUiLCJldmVudFR5cGVzJDEiLCJjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsImdldEluc3RJZlZhbHVlQ2hhbmdlZCIsInRhcmdldE5vZGUiLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJET01FdmVudFBsdWdpbk9yZGVyIiwiVUlFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1VJRXZlbnQiLCJtb2RpZmllcktleVRvUHJvcCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljTW91c2VFdmVudCIsImV2ZW50VHlwZXMkMiIsIndpbiIsInJlbGF0ZWQiLCJmcm9tTm9kZSIsInRvTm9kZSIsIlJlYWN0SW50ZXJuYWxzIiwiTm9FZmZlY3QiLCJQZXJmb3JtZWRXb3JrIiwiUGxhY2VtZW50IiwiVXBkYXRlIiwiUGxhY2VtZW50QW5kVXBkYXRlIiwiRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkVyciIsIlJlZiIsIk1PVU5USU5HIiwiTU9VTlRFRCIsIlVOTU9VTlRFRCIsImlzRmliZXJNb3VudGVkSW1wbCIsImlzRmliZXJNb3VudGVkIiwib3duZXJGaWJlciIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwicGFyZW50QSIsInBhcmVudEIiLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsInBhcmVudCIsImN1cnJlbnRQYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMiLCJDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUiLCJjYWxsYmFja0Jvb2trZWVwaW5nUG9vbCIsImZpbmRSb290Q29udGFpbmVyTm9kZSIsImdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyIsInJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJoYW5kbGVUb3BMZXZlbEltcGwiLCJhbmNlc3RvciIsInJvb3QiLCJoYW5kbGVUb3BMZXZlbCIsImVuYWJsZWQiLCJoYW5kbGVyQmFzZU5hbWUiLCJtYWtlUHJlZml4TWFwIiwic3R5bGVQcm9wIiwicHJlZml4ZXMiLCJ2ZW5kb3JQcmVmaXhlcyIsInByZWZpeGVkRXZlbnROYW1lcyIsImdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lIiwicHJlZml4TWFwIiwidG9wTGV2ZWxUeXBlcyQxIiwiQnJvd3NlckV2ZW50Q29uc3RhbnRzIiwidG9wTGV2ZWxUeXBlcyIsInJ1bkV2ZW50UXVldWVJbkJhdGNoIiwiYWxyZWFkeUxpc3RlbmluZ1RvIiwicmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyIiwidG9wTGlzdGVuZXJzSURLZXkiLCJnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudCIsIm1vdW50QXQiLCJsaXN0ZW5UbyIsImNvbnRlbnREb2N1bWVudEhhbmRsZSIsImlzTGlzdGVuaW5nIiwiZGVwZW5kZW5jeSIsImlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMiLCJnZXRMZWFmTm9kZSIsImdldFNpYmxpbmdOb2RlIiwiZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCIsIm5vZGVTdGFydCIsIm5vZGVFbmQiLCJnZXRPZmZzZXRzIiwic2VsZWN0aW9uIiwiZm9jdXNOb2RlJCQxIiwiZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMiLCJpbmRleFdpdGhpbkFuY2hvciIsImluZGV4V2l0aGluRm9jdXMiLCJvdXRlciIsInNldE9mZnNldHMiLCJvZmZzZXRzIiwidGVtcCIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwiaXNJbkRvY3VtZW50IiwiaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzIiwiZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24iLCJnZXRTZWxlY3Rpb24kMSIsInJlc3RvcmVTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsImV2ZW50VHlwZXMkMyIsImFjdGl2ZUVsZW1lbnQkMSIsImFjdGl2ZUVsZW1lbnRJbnN0JDEiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNBbmltYXRpb25FdmVudCIsIkNsaXBib2FyZEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsImdldEV2ZW50Q2hhckNvZGUiLCJub3JtYWxpemVLZXkiLCJ0cmFuc2xhdGVUb0tleSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljVG91Y2hFdmVudCIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwiZXZlbnRUeXBlcyQ0IiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiY2FwaXRhbGl6ZWRFdmVudCIsIm9uRXZlbnQiLCJ0b3BFdmVudCIsImtub3duSFRNTFRvcExldmVsVHlwZXMiLCJlbmFibGVBc3luY1N1YnRyZWVBUEkiLCJlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NIiwiZW5hYmxlQ3JlYXRlUm9vdCIsImVuYWJsZVVzZXJUaW1pbmdBUEkiLCJlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIiLCJlbmFibGVOb29wUmVjb25jaWxlciIsImVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyIiwiZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJjcmVhdGVDdXJzb3IiLCJyZXNldCQxIiwiZGVzY3JpYmVGaWJlciIsImdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIiLCJ3b3JrSW5Qcm9ncmVzcyIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSIsIlJlYWN0RGVidWdDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtIiwicmVzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50UGhhc2UiLCJyZWFjdEVtb2ppIiwid2FybmluZ0Vtb2ppIiwic3VwcG9ydHNVc2VyVGltaW5nIiwibWFyayIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsImN1cnJlbnRGaWJlciIsImN1cnJlbnRQaGFzZSIsImN1cnJlbnRQaGFzZUZpYmVyIiwiaXNDb21taXR0aW5nIiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0IiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UiLCJjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wIiwiZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQiLCJpc1dhaXRpbmdGb3JDYWxsYmFjayIsImxhYmVsc0luQ3VycmVudENvbW1pdCIsImZvcm1hdE1hcmtOYW1lIiwibWFya05hbWUiLCJmb3JtYXRMYWJlbCIsImxhYmVsIiwid2FybmluZyQkMSIsInN1ZmZpeCIsImJlZ2luTWFyayIsImNsZWFyTWFyayIsImVuZE1hcmsiLCJmb3JtYXR0ZWRNYXJrTmFtZSIsImZvcm1hdHRlZExhYmVsIiwiZ2V0RmliZXJNYXJrTmFtZSIsImRlYnVnSUQiLCJnZXRGaWJlckxhYmVsIiwiYmVnaW5GaWJlck1hcmsiLCJfZGVidWdJRCIsImNsZWFyRmliZXJNYXJrIiwiZW5kRmliZXJNYXJrIiwic2hvdWxkSWdub3JlRmliZXIiLCJjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50IiwicGF1c2VUaW1lcnMiLCJfZGVidWdJc0N1cnJlbnRseVRpbWluZyIsInJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5IiwicmVzdW1lVGltZXJzIiwicmVjb3JkRWZmZWN0IiwicmVjb3JkU2NoZWR1bGVVcGRhdGUiLCJzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyIiwic3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyIiwiZGlkRXhwaXJlIiwic3RhcnRXb3JrVGltZXIiLCJjYW5jZWxXb3JrVGltZXIiLCJzdG9wV29ya1RpbWVyIiwic3RvcEZhaWxlZFdvcmtUaW1lciIsInN0YXJ0UGhhc2VUaW1lciIsInN0b3BQaGFzZVRpbWVyIiwic3RhcnRXb3JrTG9vcFRpbWVyIiwibmV4dFVuaXRPZldvcmsiLCJzdG9wV29ya0xvb3BUaW1lciIsImludGVycnVwdGVkQnkiLCJzdGFydENvbW1pdFRpbWVyIiwiY2xlYXIiLCJzdG9wQ29tbWl0VGltZXIiLCJzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIiLCJzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwic3RvcENvbW1pdExpZmVDeWNsZXNUaW1lciIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJoYXNPd25Db250ZXh0IiwiaXNDb250ZXh0UHJvdmlkZXIiLCJjYWNoZUNvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiZ2V0TWFza2VkQ29udGV4dCIsImhhc0NvbnRleHRDaGFuZ2VkIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJwb3BDb250ZXh0UHJvdmlkZXIiLCJwb3BUb3BMZXZlbENvbnRleHRPYmplY3QiLCJwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwiZGlkQ2hhbmdlIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicHVzaENvbnRleHRQcm92aWRlciIsIm1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJyZXNldENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIk5vV29yayIsIlN5bmMiLCJOZXZlciIsIlVOSVRfU0laRSIsIk1BR0lDX05VTUJFUl9PRkZTRVQiLCJtc1RvRXhwaXJhdGlvblRpbWUiLCJtcyIsImV4cGlyYXRpb25UaW1lVG9NcyIsImNlaWxpbmciLCJudW0iLCJwcmVjaXNpb24iLCJjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldCIsImN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkluTXMiLCJidWNrZXRTaXplTXMiLCJOb0NvbnRleHQiLCJBc3luY1VwZGF0ZXMiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImRlYnVnQ291bnRlciIsIkZpYmVyTm9kZSIsImNyZWF0ZUZpYmVyIiwic2hvdWxkQ29uc3RydWN0IiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiZWxlbWVudHMiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiY29udGVudCIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiY3JlYXRlRmliZXJGcm9tQ2FsbCIsImNyZWF0ZUZpYmVyRnJvbVJldHVybiIsInJldHVybk5vZGUiLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJwb3J0YWwiLCJjcmVhdGVGaWJlclJvb3QiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJoYXNMb2dnZWRFcnJvciIsImNhdGNoRXJyb3JzIiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsInJlbmRlcmVySUQiLCJvbkNvbW1pdFJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3JlYXRlVXBkYXRlUXVldWUiLCJxdWV1ZSIsImlzUHJvY2Vzc2luZyIsImluc2VydFVwZGF0ZUludG9RdWV1ZSIsInVwZGF0ZSIsImluc2VydFVwZGF0ZUludG9GaWJlciIsImFsdGVybmF0ZUZpYmVyIiwicXVldWUxIiwicXVldWUyIiwiZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJ1cGRhdGVGbiIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsInJlbmRlckV4cGlyYXRpb25UaW1lIiwiY3VycmVudFF1ZXVlIiwiZG9udE11dGF0ZVByZXZTdGF0ZSIsImRpZFNraXAiLCJ1cGRhdGVFeHBpcmF0aW9uVGltZSIsIl9wYXJ0aWFsU3RhdGUiLCJfY2FsbGJhY2tMaXN0IiwiY29tbWl0Q2FsbGJhY2tzIiwiX2NhbGxiYWNrIiwiZmFrZUludGVybmFsSW5zdGFuY2UiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQiLCJtZW1vaXplUHJvcHMiLCJtZW1vaXplU3RhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJvbGRTdGF0ZSIsIm5ld1N0YXRlIiwibmV3Q29udGV4dCIsInNob3VsZFVwZGF0ZSIsImNoZWNrQ2xhc3NJbnN0YW5jZSIsInJlbmRlclByZXNlbnQiLCJub0dldEluaXRpYWxTdGF0ZU9uRVM2IiwiZ2V0SW5pdGlhbFN0YXRlIiwibm9HZXREZWZhdWx0UHJvcHNPbkVTNiIsIm5vSW5zdGFuY2VQcm9wVHlwZXMiLCJub0luc3RhbmNlQ29udGV4dFR5cGVzIiwibm9Db21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJub0NvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRVbm1vdW50Iiwibm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiaGFzTXV0YXRlZFByb3BzIiwibm9JbnN0YW5jZURlZmF1bHRQcm9wcyIsInJlc2V0SW5wdXRQb2ludGVycyIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJjdG9yIiwibmVlZHNDb250ZXh0IiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwib2xkQ29udGV4dCIsIm5ld1VubWFza2VkQ29udGV4dCIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5Gb3JNaXNzaW5nS2V5IiwiaXNBcnJheSQxIiwiY29lcmNlUmVmIiwibWl4ZWRSZWYiLCJzdHJpbmdSZWYiLCJ0aHJvd09uSW52YWxpZE9iamVjdFR5cGUiLCJyZXR1cm5GaWJlciIsIm5ld0NoaWxkIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwiQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjbG9uZSIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlQ2FsbCIsInVwZGF0ZVJldHVybiIsInVwZGF0ZVBvcnRhbCIsInVwZGF0ZUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsIl9jcmVhdGVkNCIsIl9jcmVhdGVkNSIsIl9jcmVhdGVkNiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIl9tYXRjaGVkRmliZXI0IiwiX21hdGNoZWRGaWJlcjUiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbmV3RmliZXIyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsIm5ld0NoaWxkcmVuSXRlcmFibGUiLCJwb3NzaWJsZU1hcCIsIl9uZXdDaGlsZHJlbiIsIl9uZXdGaWJlcjMiLCJfbmV3RmliZXI0IiwicmVjb25jaWxlU2luZ2xlVGV4dE5vZGUiLCJyZWNvbmNpbGVTaW5nbGVFbGVtZW50IiwiX2NyZWF0ZWQ3IiwicmVjb25jaWxlU2luZ2xlQ2FsbCIsInJlY29uY2lsZVNpbmdsZVJldHVybiIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiX2lzTW9ja0Z1bmN0aW9uIiwibW91bnRDaGlsZEZpYmVycyIsImNsb25lQ2hpbGRGaWJlcnMiLCJjdXJyZW50Q2hpbGQiLCJ3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnMiLCJSZWFjdEZpYmVyQmVnaW5Xb3JrIiwiaG9zdENvbnRleHQiLCJoeWRyYXRpb25Db250ZXh0IiwiX1JlYWN0RmliZXJDbGFzc0NvbXBvIiwicmVjb25jaWxlQ2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJyZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUiLCJiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrIiwibWFya1JlZiIsInVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJ1cGRhdGVDbGFzc0NvbXBvbmVudCIsImhhc0NvbnRleHQiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJ1cGRhdGVIb3N0Um9vdCIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJwcmV2UHJvcHMiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0IiwibW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50IiwiZGVidWdTb3VyY2UiLCJ1cGRhdGVDYWxsQ29tcG9uZW50IiwibmV4dENhbGwiLCJ1cGRhdGVQb3J0YWxDb21wb25lbnQiLCJiYWlsb3V0T25Mb3dQcmlvcml0eSIsIm5leHRTdGF0ZSIsIlJlYWN0RmliZXJDb21wbGV0ZVdvcmsiLCJtYXJrVXBkYXRlIiwiYXBwZW5kQWxsUmV0dXJucyIsInJldHVybnMiLCJtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwidXBkYXRlUGF5bG9hZCIsInJvb3RDb250YWluZXJJbnN0YW5jZSIsIm9sZFRleHQiLCJuZXdUZXh0IiwiY2xvbmVJbnN0YW5jZSIsImNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0IiwiZmluYWxpemVDb250YWluZXJDaGlsZHJlbiIsImFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIiLCJjb250YWluZXJDaGlsZFNldCIsInBvcnRhbE9yUm9vdCIsImNoaWxkcmVuVW5jaGFuZ2VkIiwiY29udGFpbmVyIiwibmV3Q2hpbGRTZXQiLCJjdXJyZW50SW5zdGFuY2UiLCJyZWN5Y2xhYmxlSW5zdGFuY2UiLCJuZXdJbnN0YW5jZSIsImN1cnJlbnRIb3N0Q29udGV4dCIsImZpYmVyUm9vdCIsIl9jdXJyZW50SG9zdENvbnRleHQiLCJ3YXNIeWRyYXRlZCIsIl9pbnN0YW5jZSIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfY3VycmVudEhvc3RDb250ZXh0MiIsIl93YXNIeWRyYXRlZCIsImludm9rZUd1YXJkZWRDYWxsYmFjayQyIiwiaGFzQ2F1Z2h0RXJyb3IkMSIsImNsZWFyQ2F1Z2h0RXJyb3IkMSIsIlJlYWN0RmliZXJDb21taXRXb3JrIiwiY2FwdHVyZUVycm9yIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwidW5tb3VudEVycm9yIiwic2FmZWx5RGV0YWNoUmVmIiwicmVmRXJyb3IiLCJfdXBkYXRlUXVldWUiLCJfaW5zdGFuY2UyIiwiY3VycmVudFJlZiIsImNvbW1pdFVubW91bnQiLCJjb21taXROZXN0ZWRVbm1vdW50cyIsInVubW91bnRIb3N0Q29tcG9uZW50cyIsImVtcHR5UG9ydGFsQ29udGFpbmVyIiwiZGV0YWNoRmliZXIiLCJjb21taXRDb250YWluZXIiLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJlbXB0eUNoaWxkU2V0IiwiX3BlbmRpbmdDaGlsZHJlbiIsImdldEhvc3RQYXJlbnRGaWJlciIsImlzSG9zdFBhcmVudCIsImdldEhvc3RTaWJsaW5nIiwic2libGluZ3MiLCJwYXJlbnRGaWJlciIsImlzQ29udGFpbmVyIiwiYmVmb3JlIiwiY3VycmVudFBhcmVudElzVmFsaWQiLCJjdXJyZW50UGFyZW50SXNDb250YWluZXIiLCJmaW5kUGFyZW50IiwidGV4dEluc3RhbmNlIiwiTk9fQ09OVEVYVCIsIlJlYWN0RmliZXJIb3N0Q29udGV4dCIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJyZXF1aXJlZENvbnRleHQiLCJyb290SW5zdGFuY2UiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwiUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJpc0h5ZHJhdGluZyIsInBhcmVudEluc3RhbmNlIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsInBhcmVudENvbnRhaW5lciIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfdGV4dCIsInRyeUh5ZHJhdGUiLCJuZXh0SW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiIsImRlYnVnVG9vbCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSIsImRlZmF1bHRTaG93RGlhbG9nIiwiY2FwdHVyZWRFcnJvciIsInNob3dEaWFsb2ciLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJzdXBwcmVzc0xvZ2dpbmciLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tYmluZWRNZXNzYWdlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDEiLCJkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24iLCJkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQiLCJ3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCIsIndhcm5BYm91dEludmFsaWRVcGRhdGVzIiwiUmVhY3RGaWJlclNjaGVkdWxlciIsIl9SZWFjdEZpYmVyQmVnaW5Xb3JrIiwiX1JlYWN0RmliZXJDb21wbGV0ZVdvIiwiX1JlYWN0RmliZXJDb21taXRXb3JrIiwic3RhcnRUaW1lIiwibW9zdFJlY2VudEN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkNvbnRleHQiLCJpc1dvcmtpbmciLCJuZXh0Um9vdCIsIm5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSIsImNhcHR1cmVkRXJyb3JzIiwiZmFpbGVkQm91bmRhcmllcyIsImNvbW1pdFBoYXNlQm91bmRhcmllcyIsImZpcnN0VW5jYXVnaHRFcnJvciIsImRpZEZhdGFsIiwiaXNVbm1vdW50aW5nIiwicmVzZXRDb250ZXh0U3RhY2siLCJjb21taXRBbGxIb3N0RWZmZWN0cyIsInByaW1hcnlFZmZlY3RUYWciLCJfY3VycmVudCIsIl9jdXJyZW50MiIsImNvbW1pdEFsbExpZmVDeWNsZXMiLCJjb21taXRFcnJvckhhbmRsaW5nIiwiY29tbWl0Um9vdCIsIl9lcnJvciIsIl9kaWRFcnJvciIsIl9lcnJvcjIiLCJvbkNvbW1pdFdvcmsiLCJzY2hlZHVsZUVycm9yUmVjb3ZlcnkiLCJfZXJyb3IzIiwib25VbmNhdWdodEVycm9yIiwicmVtYWluaW5nVGltZSIsInJlc2V0RXhwaXJhdGlvblRpbWUiLCJyZW5kZXJUaW1lIiwibmV3RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJvbkNvbXBsZXRlV29yayIsInBlcmZvcm1Vbml0T2ZXb3JrIiwib25CZWdpbldvcmsiLCJwZXJmb3JtRmFpbGVkVW5pdE9mV29yayIsIndvcmtMb29wIiwic2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsiLCJzaG91bGRZaWVsZCIsImhhc0NhcHR1cmVkRXJyb3IiLCJyZW5kZXJSb290Q2F0Y2hCbG9jayIsImZhaWxlZFdvcmsiLCJib3VuZGFyeSIsInVud2luZENvbnRleHRzIiwicmVuZGVyUm9vdCIsInVuY2F1Z2h0RXJyb3IiLCJpc0ZhaWxlZEJvdW5kYXJ5IiwiX2NvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudE5hbWUiLCJlZmZlY3RmdWxGaWJlciIsInJlY2FsY3VsYXRlQ3VycmVudFRpbWUiLCJleHBpcmF0aW9uTXMiLCJzY2hlZHVsZVdvcmtJbXBsIiwiY2hlY2tSb290TmVlZHNDbGVhcmluZyIsImlzRXJyb3JSZWNvdmVyeSIsInJlcXVlc3RXb3JrIiwicHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCIsInN5bmNVcGRhdGVzIiwiZmlyc3RTY2hlZHVsZWRSb290IiwibGFzdFNjaGVkdWxlZFJvb3QiLCJjYWxsYmFja0V4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tJRCIsImlzUmVuZGVyaW5nIiwibmV4dEZsdXNoZWRSb290IiwibmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSIsImRlYWRsaW5lRGlkRXhwaXJlIiwiaGFzVW5oYW5kbGVkRXJyb3IiLCJ1bmhhbmRsZWRFcnJvciIsImRlYWRsaW5lIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJpc1VuYmF0Y2hpbmdVcGRhdGVzIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50IiwidGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsiLCJzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24iLCJjdXJyZW50TXMiLCJwZXJmb3JtQXN5bmNXb3JrIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtV29yayIsImZpbmRIaWdoZXN0UHJpb3JpdHlSb290IiwiaGlnaGVzdFByaW9yaXR5V29yayIsImhpZ2hlc3RQcmlvcml0eVJvb3QiLCJwcmV2aW91c1NjaGVkdWxlZFJvb3QiLCJwcmV2aW91c0ZsdXNoZWRSb290IiwiZGwiLCJtaW5FeHBpcmF0aW9uVGltZSIsIl9lcnJvcjQiLCJfZmluaXNoZWRXb3JrIiwicHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDEiLCJfUmVhY3RGaWJlclNjaGVkdWxlciIsInNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUiLCJob3N0RmliZXIiLCJvbk1vdW50Q29udGFpbmVyIiwib25Vbm1vdW50Q29udGFpbmVyIiwib25VcGRhdGVDb250YWluZXIiLCJjb250YWluZXJGaWJlciIsImRldlRvb2xzQ29uZmlnIiwiUmVhY3RGaWJlclJlY29uY2lsZXIkMiIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDMiLCJyZWFjdFJlY29uY2lsZXIiLCJjcmVhdGVQb3J0YWwkMSIsImhhc05hdGl2ZVBlcmZvcm1hbmNlTm93IiwicklDIiwiY0lDIiwiZnJhbWVDYWxsYmFjayIsInRpbWVvdXRJRCIsInNjaGVkdWxlZFJJQ0NhbGxiYWNrIiwiaXNJZGxlU2NoZWR1bGVkIiwidGltZW91dFRpbWUiLCJpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkIiwiZnJhbWVEZWFkbGluZSIsInByZXZpb3VzRnJhbWVUaW1lIiwiYWN0aXZlRnJhbWVUaW1lIiwiZnJhbWVEZWFkbGluZU9iamVjdCIsInJlbWFpbmluZyIsIm1lc3NhZ2VLZXkiLCJpZGxlVGljayIsImFuaW1hdGlvblRpY2siLCJyYWZUaW1lIiwibmV4dEZyYW1lVGltZSIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImdldFZhbHVlRm9yUHJvcGVydHkiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5hbWVzcGFjZSIsInNldFZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUiLCJSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyIsImhhc1JlYWRPbmx5VmFsdWUiLCJjaGVja2JveCIsImltYWdlIiwicmFkaW8iLCJzdWJtaXQiLCJvbkNoYW5nZSIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJnZXRIb3N0UHJvcHMiLCJob3N0UHJvcHMiLCJpbml0V3JhcHBlclN0YXRlIiwidXBkYXRlQ2hlY2tlZCIsInVwZGF0ZVdyYXBwZXIiLCJ2YWx1ZUFzTnVtYmVyIiwicG9zdE1vdW50V3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMSIsInVwZGF0ZU5hbWVkQ291c2lucyIsInJvb3ROb2RlIiwicXVlcnlSb290IiwiZ3JvdXAiLCJvdGhlck5vZGUiLCJvdGhlclByb3BzIiwiZmxhdHRlbkNoaWxkcmVuIiwidmFsaWRhdGVQcm9wcyIsInBvc3RNb3VudFdyYXBwZXIkMSIsImdldEhvc3RQcm9wcyQxIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJ1cGRhdGVPcHRpb25zIiwicHJvcFZhbHVlIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiX3NlbGVjdGVkVmFsdWUiLCJfaTIiLCJnZXRIb3N0UHJvcHMkMiIsImluaXRXcmFwcGVyU3RhdGUkMSIsInBvc3RNb3VudFdyYXBwZXIkMiIsInBvc3RVcGRhdGVXcmFwcGVyIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1IiwiZGlkV2FyblZhbERlZmF1bHRWYWwiLCJnZXRIb3N0UHJvcHMkMyIsImluaXRXcmFwcGVyU3RhdGUkMiIsInVwZGF0ZVdyYXBwZXIkMSIsIm5ld1ZhbHVlIiwicG9zdE1vdW50V3JhcHBlciQzIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzIiwiSFRNTF9OQU1FU1BBQ0UkMSIsIk1BVEhfTkFNRVNQQUNFIiwiU1ZHX05BTUVTUEFDRSIsIk5hbWVzcGFjZXMiLCJnZXRJbnRyaW5zaWNOYW1lc3BhY2UiLCJnZXRDaGlsZE5hbWVzcGFjZSIsInBhcmVudE5hbWVzcGFjZSIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJhcmcwIiwiYXJnMSIsImFyZzIiLCJhcmczIiwicmV1c2FibGVTVkdDb250YWluZXIiLCJzZXRJbm5lckhUTUwiLCJzdmdOb2RlIiwic2V0VGV4dENvbnRlbnQiLCJpc1VuaXRsZXNzTnVtYmVyIiwicHJlZml4S2V5IiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImlzQ3VzdG9tUHJvcGVydHkiLCJpc0VtcHR5Iiwid2FyblZhbGlkU3R5bGUiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwiZGVsaW1pdGVyIiwic3R5bGVOYW1lIiwic3R5bGVWYWx1ZSIsInNldFZhbHVlRm9yU3R5bGVzIiwib21pdHRlZENsb3NlVGFncyIsInZvaWRFbGVtZW50VGFncyIsIkhUTUwkMSIsImFzc2VydFZhbGlkUHJvcHMiLCJpc0N1c3RvbUNvbXBvbmVudCIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwic3RhbmRhcmROYW1lIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJkaWRXYXJuVmFsdWVOdWxsIiwiZ2V0U3RhY2tBZGRlbmR1bSQxIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2l0ZSIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzcGFuIiwiY29udGVudGVkaXRhYmxlIiwiY29udGV4dG1lbnUiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGVmYXVsdGNoZWNrZWQiLCJkZWZhdWx0dmFsdWUiLCJkaXIiLCJlbmN0eXBlIiwiZm9ybW1ldGhvZCIsImZvcm1hY3Rpb24iLCJmb3JtZW5jdHlwZSIsImZvcm1ub3ZhbGlkYXRlIiwiZm9ybXRhcmdldCIsImZyYW1lYm9yZGVyIiwiaGVpZ2h0IiwiaGlnaCIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpbm5lcmh0bWwiLCJpbnB1dG1vZGUiLCJpbnRlZ3JpdHkiLCJpdGVtaWQiLCJpdGVtcHJvcCIsIml0ZW1yZWYiLCJpdGVtc2NvcGUiLCJpdGVtdHlwZSIsImtleXBhcmFtcyIsImtleXR5cGUiLCJraW5kIiwibGFuZyIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1lZGlhZ3JvdXAiLCJtaW5sZW5ndGgiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcHRpbXVtIiwicGxhY2Vob2xkZXIiLCJwbGF5c2lubGluZSIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9ncm91cCIsInJlYWRvbmx5IiwicmVmZXJyZXJwb2xpY3kiLCJyZWwiLCJyb2xlIiwicm93c3BhbiIsInNhbmRib3giLCJzY3JvbGxpbmciLCJzaXplcyIsInNwZWxsY2hlY2siLCJzcmMiLCJzcmNkb2MiLCJzcmNsYW5nIiwic3Jjc2V0Iiwic3VtbWFyeSIsInRhYmluZGV4IiwidGl0bGUiLCJ1c2VtYXAiLCJ3aWR0aCIsIndtb2RlIiwiYWJvdXQiLCJhY2NlbnRoZWlnaHQiLCJhY2N1bXVsYXRlIiwiYWRkaXRpdmUiLCJhbGlnbm1lbnRiYXNlbGluZSIsImFsbG93cmVvcmRlciIsImFscGhhYmV0aWMiLCJhbXBsaXR1ZGUiLCJhcmFiaWNmb3JtIiwiYXNjZW50IiwiYXR0cmlidXRlbmFtZSIsImF0dHJpYnV0ZXR5cGUiLCJhdXRvcmV2ZXJzZSIsImF6aW11dGgiLCJiYXNlZnJlcXVlbmN5IiwiYmFzZWxpbmVzaGlmdCIsImJhc2Vwcm9maWxlIiwiYmJveCIsImJlZ2luIiwiYmlhcyIsImJ5IiwiY2FsY21vZGUiLCJjYXBoZWlnaHQiLCJjbGlwIiwiY2xpcHBhdGgiLCJjbGlwcGF0aHVuaXRzIiwiY2xpcHJ1bGUiLCJjb2xvcmludGVycG9sYXRpb24iLCJjb2xvcmludGVycG9sYXRpb25maWx0ZXJzIiwiY29sb3Jwcm9maWxlIiwiY29sb3JyZW5kZXJpbmciLCJjb250ZW50c2NyaXB0dHlwZSIsImNvbnRlbnRzdHlsZXR5cGUiLCJjeCIsImN5IiwiZGF0YXR5cGUiLCJkZWNlbGVyYXRlIiwiZGVzY2VudCIsImRpZmZ1c2Vjb25zdGFudCIsImRpcmVjdGlvbiIsImRpc3BsYXkiLCJkaXZpc29yIiwiZG9taW5hbnRiYXNlbGluZSIsImR1ciIsImR4IiwiZHkiLCJlZGdlbW9kZSIsImVsZXZhdGlvbiIsImVuYWJsZWJhY2tncm91bmQiLCJleHBvbmVudCIsImV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQiLCJmaWxsIiwiZmlsbG9wYWNpdHkiLCJmaWxscnVsZSIsImZpbHRlcnJlcyIsImZpbHRlcnVuaXRzIiwiZmxvb2RvcGFjaXR5IiwiZmxvb2Rjb2xvciIsImZvY3VzYWJsZSIsImZvbnRmYW1pbHkiLCJmb250c2l6ZSIsImZvbnRzaXplYWRqdXN0IiwiZm9udHN0cmV0Y2giLCJmb250c3R5bGUiLCJmb250dmFyaWFudCIsImZvbnR3ZWlnaHQiLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImlubGlzdCIsImludGVyY2VwdCIsImsxIiwiazIiLCJrMyIsIms0Iiwia2VybmVsbWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsZW5ndGhhZGp1c3QiLCJsZXR0ZXJzcGFjaW5nIiwibGlnaHRpbmdjb2xvciIsImxpbWl0aW5nY29uZWFuZ2xlIiwibG9jYWwiLCJtYXJrZXJlbmQiLCJtYXJrZXJoZWlnaHQiLCJtYXJrZXJtaWQiLCJtYXJrZXJzdGFydCIsIm1hcmtlcnVuaXRzIiwibWFya2Vyd2lkdGgiLCJtYXNrIiwibWFza2NvbnRlbnR1bml0cyIsIm1hc2t1bml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1vY3RhdmVzIiwib3BlcmF0b3IiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInByb3BlcnR5IiwicmFkaXVzIiwicmVmeCIsInJlZnkiLCJyZW5kZXJpbmdpbnRlbnQiLCJyZXBlYXRjb3VudCIsInJlcGVhdGR1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiLCJyZXNvdXJjZSIsInJlc3RhcnQiLCJyZXN1bHRzIiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VjdXJpdHkiLCJzZWVkIiwic2hhcGVyZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhcmNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCIsInNwZWVkIiwic3ByZWFkbWV0aG9kIiwic3RhcnRvZmZzZXQiLCJzdGRkZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNodGlsZXMiLCJzdG9wY29sb3IiLCJzdG9wb3BhY2l0eSIsInN0cmlrZXRocm91Z2hwb3NpdGlvbiIsInN0cmlrZXRocm91Z2h0aGlja25lc3MiLCJzdHJva2UiLCJzdHJva2VkYXNoYXJyYXkiLCJzdHJva2VkYXNob2Zmc2V0Iiwic3Ryb2tlbGluZWNhcCIsInN0cm9rZWxpbmVqb2luIiwic3Ryb2tlbWl0ZXJsaW1pdCIsInN0cm9rZXdpZHRoIiwic3Ryb2tlb3BhY2l0eSIsInN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZyIsInN1cHByZXNzaHlkcmF0aW9ud2FybmluZyIsInN1cmZhY2VzY2FsZSIsInN5c3RlbWxhbmd1YWdlIiwidGFibGV2YWx1ZXMiLCJ0YXJnZXR4IiwidGFyZ2V0eSIsInRleHRhbmNob3IiLCJ0ZXh0ZGVjb3JhdGlvbiIsInRleHRsZW5ndGgiLCJ0ZXh0cmVuZGVyaW5nIiwidHJhbnNmb3JtIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmVjdG9yZWZmZWN0IiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieWNoYW5uZWxzZWxlY3RvciIsInpvb21hbmRwYW4iLCJnZXRTdGFja0FkZGVuZHVtJDIiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJoYXNPd25Qcm9wZXJ0eSQxIiwiRVZFTlRfTkFNRV9SRUdFWCIsIklOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCIsInJBUklBJDEiLCJyQVJJQUNhbWVsJDEiLCJ2YWxpZGF0ZVByb3BlcnR5JDEiLCJjYW5Vc2VFdmVudFN5c3RlbSIsImlzUmVzZXJ2ZWQiLCJ3YXJuVW5rbm93blByb3BlcnRpZXMiLCJ1bmtub3duUHJvcHMiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMiIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyIiwiZGlkV2FybkludmFsaWRIeWRyYXRpb24iLCJkaWRXYXJuU2hhZHlET00iLCJEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCIsIlNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEiLCJBVVRPRk9DVVMiLCJDSElMRFJFTiIsIlNUWUxFIiwiSFRNTCIsIkhUTUxfTkFNRVNQQUNFIiwid2FybmVkVW5rbm93blRhZ3MiLCJkaWFsb2ciLCJ2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50IiwiTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYIiwiTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYIiwibm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlIiwibWFya3VwIiwibWFya3VwU3RyaW5nIiwid2FybkZvclRleHREaWZmZXJlbmNlIiwic2VydmVyVGV4dCIsImNsaWVudFRleHQiLCJub3JtYWxpemVkQ2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRTZXJ2ZXJUZXh0Iiwid2FybkZvclByb3BEaWZmZXJlbmNlIiwic2VydmVyVmFsdWUiLCJjbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRDbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSIsIndhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVOYW1lcyIsIm5hbWVzIiwid2FybkZvckludmFsaWRFdmVudExpc3RlbmVyIiwibm9ybWFsaXplSFRNTCIsInRlc3RFbGVtZW50IiwiZW5zdXJlTGlzdGVuaW5nVG8iLCJyb290Q29udGFpbmVyRWxlbWVudCIsImlzRG9jdW1lbnRPckZyYWdtZW50IiwiZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyIiwibWVkaWFFdmVudHMiLCJ0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudCIsInNldEluaXRpYWxET01Qcm9wZXJ0aWVzIiwiZG9tRWxlbWVudCIsImlzQ3VzdG9tQ29tcG9uZW50VGFnIiwicHJvcEtleSIsIm5leHRQcm9wIiwibmV4dEh0bWwiLCJjYW5TZXRUZXh0Q29udGVudCIsInVwZGF0ZURPTVByb3BlcnRpZXMiLCJ3YXNDdXN0b21Db21wb25lbnRUYWciLCJjcmVhdGVFbGVtZW50JDEiLCJkaXYiLCJjcmVhdGVUZXh0Tm9kZSQxIiwic2V0SW5pdGlhbFByb3BlcnRpZXMkMSIsInJhd1Byb3BzIiwic2hhZHlSb290IiwiZGlmZlByb3BlcnRpZXMkMSIsImxhc3RSYXdQcm9wcyIsIm5leHRSYXdQcm9wcyIsImxhc3RQcm9wcyIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsImxhc3RQcm9wIiwibGFzdEh0bWwiLCJ1cGRhdGVQcm9wZXJ0aWVzJDEiLCJkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEiLCJleHRyYUF0dHJpYnV0ZU5hbWVzIiwiYXR0cmlidXRlcyIsInJhd0h0bWwiLCJzZXJ2ZXJIVE1MIiwiZXhwZWN0ZWRIVE1MIiwiZXhwZWN0ZWRTdHlsZSIsIm93bk5hbWVzcGFjZSIsImRpZmZIeWRyYXRlZFRleHQkMSIsInRleHROb2RlIiwiaXNEaWZmZXJlbnQiLCJ3YXJuRm9yVW5tYXRjaGVkVGV4dCQxIiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxIiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxIiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMSIsIlJlYWN0RE9NRmliZXJDb21wb25lbnQiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJzcGVjaWFsVGFncyIsImluU2NvcGVUYWdzIiwiYnV0dG9uU2NvcGVUYWdzIiwiaW1wbGllZEVuZFRhZ3MiLCJlbXB0eUFuY2VzdG9ySW5mbyIsImZvcm1UYWciLCJhVGFnSW5TY29wZSIsImJ1dHRvblRhZ0luU2NvcGUiLCJub2JyVGFnSW5TY29wZSIsInBUYWdJbkJ1dHRvblNjb3BlIiwibGlzdEl0ZW1UYWdBdXRvY2xvc2luZyIsImRsSXRlbVRhZ0F1dG9jbG9zaW5nIiwidXBkYXRlZEFuY2VzdG9ySW5mbyQxIiwib2xkSW5mbyIsImFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwicGFyZW50VGFnIiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImRpZFdhcm4iLCJjaGlsZFRhZyIsImNoaWxkVGV4dCIsInBhcmVudEluZm8iLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwiaW52YWxpZFBhcmVudE9yQW5jZXN0b3IiLCJhbmNlc3RvclRhZyIsIndhcm5LZXkiLCJ0YWdEaXNwbGF5TmFtZSIsIndoaXRlc3BhY2VJbmZvIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRJbkNvbnRleHQiLCJ2YWxpZGF0ZURPTU5lc3RpbmckMSIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIiwiZXZlbnRzRW5hYmxlZCIsInNlbGVjdGlvbkluZm9ybWF0aW9uIiwiaXNWYWxpZENvbnRhaW5lciIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsInNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyIsInJvb3RFbGVtZW50Iiwic2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCIsIkRPTVJlbmRlcmVyIiwidmFsaWRhdGVkVGFnIiwiX2FuY2VzdG9ySW5mbyIsInBhcmVudEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHREZXYiLCJfbmFtZXNwYWNlIiwiX2FuY2VzdG9ySW5mbzIiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaG9zdENvbnRleHREZXYiLCJvd25BbmNlc3RvckluZm8iLCJiZWZvcmVDaGlsZCIsIndhcm5lZEFib3V0SHlkcmF0ZUFQSSIsInJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiZm9yY2VIeWRyYXRlIiwiaG9zdEluc3RhbmNlIiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImhhc05vblJvb3RSZWFjdENoaWxkIiwic2hvdWxkSHlkcmF0ZSIsIndhcm5lZCIsInJvb3RTaWJsaW5nIiwibmV3Um9vdCIsIlJlYWN0Um9vdCIsIlJlYWN0RE9NIiwiY29tcG9uZW50T3JFbGVtZW50Iiwid2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJjb250YWluZXJOb2RlIiwicmVuZGVyZWRCeURpZmZlcmVudFJlYWN0IiwiX3Jvb3RFbCIsImlzQ29udGFpbmVyUmVhY3RSb290IiwiY3JlYXRlUm9vdCIsImZvdW5kRGV2VG9vbHMiLCJwcm90b2NvbCIsIlJlYWN0RE9NJDIiLCJSZWFjdERPTSQzIiwicmVhY3REb20iLCJoeXBoZW5hdGUiLCJtc1BhdHRlcm4iLCJfdXBwZXJjYXNlUGF0dGVybiIsImNhbWVsaXplIiwiX2h5cGhlblBhdHRlcm4iLCJfIiwiY2hhcmFjdGVyIiwiYmFzZW5hbWUiLCJmb3JjZVJlZnJlc2giLCJrZXlMZW5ndGgiLCJJVEVSQVRPUl9TWU1CT0wiLCJBTk9OWU1PVVMiLCJSZWFjdFByb3BUeXBlcyIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwic3ltYm9sIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyIiwiUHJvcFR5cGVFcnJvciIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSIsIm1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IiwiY2hlY2tUeXBlIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwiZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nIiwic2hhcGVUeXBlcyIsImFsbEtleXMiLCJlbnRyeSIsImlzU3ltYm9sIiwic2hpbSIsImdldFNoaW0iLCJfaW52YXJpYW50IiwiX2ludmFyaWFudDIiLCJfTG9jYXRpb25VdGlscyIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIiLCJfRE9NVXRpbHMiLCJQb3BTdGF0ZUV2ZW50IiwiSGFzaENoYW5nZUV2ZW50IiwiZ2V0SGlzdG9yeVN0YXRlIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJnbG9iYWxIaXN0b3J5IiwiY2FuVXNlSGlzdG9yeSIsIm5lZWRzSGFzaENoYW5nZUxpc3RlbmVyIiwiX3Byb3BzJGZvcmNlUmVmcmVzaCIsIl9wcm9wcyRnZXRVc2VyQ29uZmlybSIsIl9wcm9wcyRrZXlMZW5ndGgiLCJnZXRET01Mb2NhdGlvbiIsImhpc3RvcnlTdGF0ZSIsIl93aW5kb3ckbG9jYXRpb24iLCJjcmVhdGVLZXkiLCJ0cmFuc2l0aW9uTWFuYWdlciIsImhhbmRsZVBvcFN0YXRlIiwiaGFuZGxlUG9wIiwiaGFuZGxlSGFzaENoYW5nZSIsImZvcmNlTmV4dFBvcCIsIm9rIiwicmV2ZXJ0UG9wIiwiZnJvbUxvY2F0aW9uIiwidG9Mb2NhdGlvbiIsInRvSW5kZXgiLCJmcm9tSW5kZXgiLCJkZWx0YSIsImdvIiwiaW5pdGlhbExvY2F0aW9uIiwicHVzaFN0YXRlIiwicHJldkluZGV4IiwibmV4dEtleXMiLCJnb0JhY2siLCJnb0ZvcndhcmQiLCJsaXN0ZW5lckNvdW50IiwiY2hlY2tET01MaXN0ZW5lcnMiLCJpc0Jsb2NrZWQiLCJibG9jayIsInVuYmxvY2siLCJoYXNoVHlwZSIsIkhhc2hQYXRoQ29kZXJzIiwiaGFzaGJhbmciLCJlbmNvZGVQYXRoIiwiZGVjb2RlUGF0aCIsIm5vc2xhc2giLCJzbGFzaCIsImdldEhhc2hQYXRoIiwicHVzaEhhc2hQYXRoIiwicmVwbGFjZUhhc2hQYXRoIiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJjYW5Hb1dpdGhvdXRSZWxvYWQiLCJfcHJvcHMkaGFzaFR5cGUiLCJfSGFzaFBhdGhDb2RlcnMkaGFzaFQiLCJpZ25vcmVQYXRoIiwiZW5jb2RlZFBhdGgiLCJwcmV2TG9jYXRpb24iLCJhbGxQYXRocyIsImxhc3RJbmRleE9mIiwiaGFzaENoYW5nZWQiLCJuZXh0UGF0aHMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsImNsYW1wIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJjcmVhdGVNZW1vcnlIaXN0b3J5IiwiX3Byb3BzJGluaXRpYWxFbnRyaWVzIiwiX3Byb3BzJGluaXRpYWxJbmRleCIsIm5leHRJbmRleCIsIm5leHRFbnRyaWVzIiwic3BsaWNlIiwiY2FuR28iLCJhY3RpdmVDbGFzc05hbWUiLCJhY3RpdmVTdHlsZSIsImdldElzQWN0aXZlIiwiYXJpYUN1cnJlbnQiLCJyZXN0IiwiX3JlZjIiLCJpc2FycmF5IiwicGF0aFRvUmVnZXhwIiwiY29tcGlsZSIsInRva2Vuc1RvRnVuY3Rpb24iLCJ0b2tlbnNUb1JlZ0V4cCIsIlBBVEhfUkVHRVhQIiwidG9rZW5zIiwiZGVmYXVsdERlbGltaXRlciIsInJlcyIsImVzY2FwZWQiLCJtb2RpZmllciIsImFzdGVyaXNrIiwicGFydGlhbCIsIm9wdGlvbmFsIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJjaGFyQ29kZUF0IiwiZW5jb2RlQXN0ZXJpc2siLCJtYXRjaGVzIiwib3B0cyIsImVuY29kZSIsInByZXR0eSIsInNlZ21lbnQiLCJqIiwiYXR0YWNoS2V5cyIsImZsYWdzIiwicmVnZXhwVG9SZWdleHAiLCJncm91cHMiLCJhcnJheVRvUmVnZXhwIiwicGFydHMiLCJyZWdleHAiLCJzdHJpbmdUb1JlZ2V4cCIsImVuZHNXaXRoRGVsaW1pdGVyIiwiZW5hYmxlIiwiZGlzYWJsZSIsIndoZW4iLCJpc1N0YXRpYyIsInBlcmZvcm0iLCJwcmV2VG8iLCJuZXh0VG8iLCJub3JtYWxpemVMb2NhdGlvbiIsIl9vYmplY3QkcGF0aG5hbWUiLCJfb2JqZWN0JHNlYXJjaCIsIl9vYmplY3QkaGFzaCIsImFkZEJhc2VuYW1lIiwiY3JlYXRlVVJMIiwic3RhdGljSGFuZGxlciIsIm5vb3AiLCJoYW5kbGVQdXNoIiwiaGFuZGxlUmVwbGFjZSIsIl90aGlzJHByb3BzMiIsImhhbmRsZUxpc3RlbiIsImhhbmRsZUJsb2NrIiwiX2VsZW1lbnQkcHJvcHMiLCJwYXRoUHJvcCIsIndyYXBwZWRDb21wb25lbnRSZWYiLCJyZW1haW5pbmdQcm9wcyIsInJvdXRlQ29tcG9uZW50UHJvcHMiLCJXcmFwcGVkQ29tcG9uZW50IiwiUkVBQ1RfU1RBVElDUyIsIm1peGlucyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJjYWxsZWUiLCJhcml0eSIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0UHJvdG90eXBlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJibGFja2xpc3QiLCJpbmhlcml0ZWRDb21wb25lbnQiLCJIb21lIiwibW92aWVTZWFyY2hlciIsImxvZyIsImRpc3BsYXlNb3ZpZVNlYXJjaCIsImltZGJJRCIsIlBvc3RlciIsIlRpdGxlIiwiWWVhciIsIlBsb3QiLCJEaXJlY3RvciIsIkFjdG9ycyIsIkdlbnJlIiwiQXdhcmRzIiwiQm94T2ZmaWNlIiwiUmF0ZWQiLCJzZWFyY2hNb3ZpZXMiLCJBeGlvcyIsImRlZmF1bHRDb25maWciLCJheGlvcyIsImluc3RhbmNlQ29uZmlnIiwiQ2FuY2VsVG9rZW4iLCJhbGwiLCJwcm9taXNlcyIsInNwcmVhZCIsImlzU2xvd0J1ZmZlciIsIl9pc0J1ZmZlciIsInJlYWRGbG9hdExFIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwiaW50ZXJjZXB0b3JzIiwiY2hhaW4iLCJ1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMiLCJzaGlmdCIsIm5vcm1hbGl6ZWROYW1lIiwicHJvY2Vzc0hlYWRlciIsInNlcmlhbGl6ZWRQYXJhbXMiLCJzZXJpYWxpemUiLCJwYXJzZVZhbHVlIiwidG9JU09TdHJpbmciLCJpZ25vcmVEdXBsaWNhdGVPZiIsInBhcnNlZCIsInBhcnNlciIsImxpbmUiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJtc2llIiwidXJsUGFyc2luZ05vZGUiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwiaG9zdCIsImhvc3RuYW1lIiwicG9ydCIsInJlcXVlc3RVUkwiLCJub25TdGFuZGFyZEJyb3dzZXJFbnYiLCJvdXRwdXQiLCJpZHgiLCJ3cml0ZSIsImV4cGlyZXMiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJ0b0dNVFN0cmluZyIsImRlY29kZVVSSUNvbXBvbmVudCIsImhhbmRsZXJzIiwidXNlIiwiZWplY3QiLCJmb3JFYWNoSGFuZGxlciIsInRyYW5zZm9ybURhdGEiLCJpc0Fic29sdXRlVVJMIiwiY29tYmluZVVSTHMiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwidGhyb3dJZlJlcXVlc3RlZCIsImJhc2VVUkwiLCJjbGVhbkhlYWRlckNvbmZpZyIsIm9uQWRhcHRlclJlc29sdXRpb24iLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJyZWFzb24iLCJmbnMiLCJyZWxhdGl2ZVVSTCIsImV4ZWN1dG9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJtb3ZpZSIsImFwaV9rZXkiLCJhcGlfdXJsIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OytDQzdEQTs7QUFFQSxJQUFJQSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNDLFNBQU9DLE9BQVAsR0FBaUIsbUJBQUFDLENBQVEsRUFBUixDQUFqQjtBQUNELENBRkQsTUFFTztBQUNMRixTQUFPQyxPQUFQLEdBQWlCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBakI7QUFDRCxDOzs7Ozs7OztBQ05EOzs7Ozs7Ozs7QUFTQTs7QUFFQTs7Ozs7OztBQU9BLElBQUlDLFVBQVUsbUJBQVcsQ0FBRSxDQUEzQjs7QUFFQSxJQUFJTixRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNJLFlBQVUsaUJBQVNDLFNBQVQsRUFBb0JDLE1BQXBCLEVBQTRCQyxJQUE1QixFQUFrQztBQUMxQyxRQUFJQyxNQUFNQyxVQUFVQyxNQUFwQjtBQUNBSCxXQUFPLElBQUlJLEtBQUosQ0FBVUgsTUFBTSxDQUFOLEdBQVVBLE1BQU0sQ0FBaEIsR0FBb0IsQ0FBOUIsQ0FBUDtBQUNBLFNBQUssSUFBSUksTUFBTSxDQUFmLEVBQWtCQSxNQUFNSixHQUF4QixFQUE2QkksS0FBN0IsRUFBb0M7QUFDbENMLFdBQUtLLE1BQU0sQ0FBWCxJQUFnQkgsVUFBVUcsR0FBVixDQUFoQjtBQUNEO0FBQ0QsUUFBSU4sV0FBV08sU0FBZixFQUEwQjtBQUN4QixZQUFNLElBQUlDLEtBQUosQ0FDSiw4REFDQSxrQkFGSSxDQUFOO0FBSUQ7O0FBRUQsUUFBSVIsT0FBT0ksTUFBUCxHQUFnQixFQUFoQixJQUF1QixVQUFELENBQWFLLElBQWIsQ0FBa0JULE1BQWxCLENBQTFCLEVBQXFEO0FBQ25ELFlBQU0sSUFBSVEsS0FBSixDQUNKLGlFQUNBLHVEQURBLEdBQzBEUixNQUZ0RCxDQUFOO0FBSUQ7O0FBRUQsUUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQ2QsVUFBSVcsV0FBVyxDQUFmO0FBQ0EsVUFBSUMsVUFBVSxjQUNaWCxPQUFPWSxPQUFQLENBQWUsS0FBZixFQUFzQixZQUFXO0FBQy9CLGVBQU9YLEtBQUtTLFVBQUwsQ0FBUDtBQUNELE9BRkQsQ0FERjtBQUlBLFVBQUksT0FBT0csT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUNsQ0EsZ0JBQVFDLEtBQVIsQ0FBY0gsT0FBZDtBQUNEO0FBQ0QsVUFBSTtBQUNGO0FBQ0E7QUFDQSxjQUFNLElBQUlILEtBQUosQ0FBVUcsT0FBVixDQUFOO0FBQ0QsT0FKRCxDQUlFLE9BQU1JLENBQU4sRUFBUyxDQUFFO0FBQ2Q7QUFDRixHQW5DRDtBQW9DRDs7QUFFRHBCLE9BQU9DLE9BQVAsR0FBaUJFLE9BQWpCLEM7Ozs7Ozs7QUMzREE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7O0FDdkx0Qzs7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SCxHQUFQO0FBSUQsQ0FURDs7QUFXQS9jLE9BQU9DLE9BQVAsR0FBaUJzN0csV0FBakIsQzs7Ozs7OztBQ3hEQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBdjdHLE9BQU9DLE9BQVAsR0FBaUIsU0FBU3k3RyxNQUFULENBQWdCcHdHLFFBQWhCLEVBQTBCO0FBQ3pDLFNBQU8sU0FBU2tPLElBQVQsQ0FBY3UwQyxHQUFkLEVBQW1CO0FBQ3hCLFdBQU96aUQsU0FBU25DLEtBQVQsQ0FBZSxJQUFmLEVBQXFCNGtELEdBQXJCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxDOzs7Ozs7Ozs7QUN0QkE7Ozs7OztBQUVBL3RELE9BQU9DLE9BQVAsR0FBaUIsVUFBQ3UvRyxLQUFELEVBQVc7QUFDMUIsTUFBSUMsVUFBVSxVQUFkO0FBQ0EsTUFBSUMsOENBQTRDRCxPQUE1QyxXQUF5REQsS0FBN0Q7QUFDQSxTQUFPLGdCQUFNbjhGLEdBQU4sQ0FBVXE4RixPQUFWLEVBQW1CO0FBQzNCenVHLGFBQVM7QUFDUixzQkFBZ0Isa0JBRFI7QUFFUixnQkFBVTtBQUZGO0FBRGtCLEdBQW5CLEVBS0o0TCxJQUxJLENBS0MsVUFBQ3cvRSxPQUFELEVBQWE7QUFDcEIsV0FBT0EsT0FBUDtBQUNBLEdBUE0sQ0FBUDtBQVFELENBWEQsQyIsImZpbGUiOiIuL3B1YmxpYy9idW5kbGUvYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNDIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGM2ZjcwMGE0YWMwMzE5MDA5MzU5IiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGFkZExlYWRpbmdTbGFzaCA9IGV4cG9ydHMuYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn07XG5cbnZhciBzdHJpcExlYWRpbmdTbGFzaCA9IGV4cG9ydHMuc3RyaXBMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufTtcblxudmFyIGhhc0Jhc2VuYW1lID0gZXhwb3J0cy5oYXNCYXNlbmFtZSA9IGZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXggKyAnKFxcXFwvfFxcXFw/fCN8JCknLCAnaScpLnRlc3QocGF0aCk7XG59O1xuXG52YXIgc3RyaXBCYXNlbmFtZSA9IGV4cG9ydHMuc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpID8gcGF0aC5zdWJzdHIocHJlZml4Lmxlbmd0aCkgOiBwYXRoO1xufTtcblxudmFyIHN0cmlwVHJhaWxpbmdTbGFzaCA9IGV4cG9ydHMuc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn07XG5cbnZhciBwYXJzZVBhdGggPSBleHBvcnRzLnBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxudmFyIGNyZWF0ZVBhdGggPSBleHBvcnRzLmNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cblxuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6ICc/JyArIHNlYXJjaDtcblxuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMiLCJleHBvcnQgdmFyIGFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxuZXhwb3J0IHZhciBjcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvUGF0aFV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCByZXNvbHZlUGF0aG5hbWUgZnJvbSAncmVzb2x2ZS1wYXRobmFtZSc7XG5pbXBvcnQgdmFsdWVFcXVhbCBmcm9tICd2YWx1ZS1lcXVhbCc7XG5pbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cbmV4cG9ydCB2YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IHJlc29sdmVQYXRobmFtZShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufTtcblxuZXhwb3J0IHZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiB2YWx1ZUVxdWFsKGEuc3RhdGUsIGIuc3RhdGUpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9Mb2NhdGlvblV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZXNvbHZlUGF0aG5hbWUgPSByZXF1aXJlKCdyZXNvbHZlLXBhdGhuYW1lJyk7XG5cbnZhciBfcmVzb2x2ZVBhdGhuYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc29sdmVQYXRobmFtZSk7XG5cbnZhciBfdmFsdWVFcXVhbCA9IHJlcXVpcmUoJ3ZhbHVlLWVxdWFsJyk7XG5cbnZhciBfdmFsdWVFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWx1ZUVxdWFsKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlTG9jYXRpb24gPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gKDAsIF9yZXNvbHZlUGF0aG5hbWUyLmRlZmF1bHQpKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59O1xuXG52YXIgbG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmICgwLCBfdmFsdWVFcXVhbDIuZGVmYXVsdCkoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L0xvY2F0aW9uVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUm91dGVyIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGVyLmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwdXR0aW5nIGhpc3Rvcnkgb24gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFJvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIGhpc3Rvcnk6IHRoaXMucHJvcHMuaGlzdG9yeSxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogdGhpcy5wcm9wcy5oaXN0b3J5LmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoOiB0aGlzLnN0YXRlLm1hdGNoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChwYXRobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiAnLycsXG4gICAgICB1cmw6ICcvJyxcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0V4YWN0OiBwYXRobmFtZSA9PT0gJy8nXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgaGlzdG9yeSA9IF9wcm9wcy5oaXN0b3J5O1xuXG5cbiAgICBpbnZhcmlhbnQoY2hpbGRyZW4gPT0gbnVsbCB8fCBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDEsICdBIDxSb3V0ZXI+IG1heSBoYXZlIG9ubHkgb25lIGNoaWxkIGVsZW1lbnQnKTtcblxuICAgIC8vIERvIHRoaXMgaGVyZSBzbyB3ZSBjYW4gc2V0U3RhdGUgd2hlbiBhIDxSZWRpcmVjdD4gY2hhbmdlcyB0aGVcbiAgICAvLyBsb2NhdGlvbiBpbiBjb21wb25lbnRXaWxsTW91bnQuIFRoaXMgaGFwcGVucyBlLmcuIHdoZW4gZG9pbmdcbiAgICAvLyBzZXJ2ZXIgcmVuZGVyaW5nIHVzaW5nIGEgPFN0YXRpY1JvdXRlcj4uXG4gICAgdGhpcy51bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgIG1hdGNoOiBfdGhpczIuY29tcHV0ZU1hdGNoKGhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHdhcm5pbmcodGhpcy5wcm9wcy5oaXN0b3J5ID09PSBuZXh0UHJvcHMuaGlzdG9yeSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT4nKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bmxpc3RlbigpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICByZXR1cm4gY2hpbGRyZW4gPyBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5Sb3V0ZXIuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcyIsImltcG9ydCBwYXRoVG9SZWdleHAgZnJvbSAncGF0aC10by1yZWdleHAnO1xuXG52YXIgcGF0dGVybkNhY2hlID0ge307XG52YXIgY2FjaGVMaW1pdCA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQgPSAwO1xuXG52YXIgY29tcGlsZVBhdGggPSBmdW5jdGlvbiBjb21waWxlUGF0aChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZUtleSA9ICcnICsgb3B0aW9ucy5lbmQgKyBvcHRpb25zLnN0cmljdCArIG9wdGlvbnMuc2Vuc2l0aXZlO1xuICB2YXIgY2FjaGUgPSBwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldIHx8IChwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldID0ge30pO1xuXG4gIGlmIChjYWNoZVtwYXR0ZXJuXSkgcmV0dXJuIGNhY2hlW3BhdHRlcm5dO1xuXG4gIHZhciBrZXlzID0gW107XG4gIHZhciByZSA9IHBhdGhUb1JlZ2V4cChwYXR0ZXJuLCBrZXlzLCBvcHRpb25zKTtcbiAgdmFyIGNvbXBpbGVkUGF0dGVybiA9IHsgcmU6IHJlLCBrZXlzOiBrZXlzIH07XG5cbiAgaWYgKGNhY2hlQ291bnQgPCBjYWNoZUxpbWl0KSB7XG4gICAgY2FjaGVbcGF0dGVybl0gPSBjb21waWxlZFBhdHRlcm47XG4gICAgY2FjaGVDb3VudCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVkUGF0dGVybjtcbn07XG5cbi8qKlxuICogUHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBVUkwgcGF0aG5hbWUgdG8gYSBwYXRoIHBhdHRlcm4uXG4gKi9cbnZhciBtYXRjaFBhdGggPSBmdW5jdGlvbiBtYXRjaFBhdGgocGF0aG5hbWUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMgPSB7IHBhdGg6IG9wdGlvbnMgfTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGF0aCA9IF9vcHRpb25zLnBhdGgsXG4gICAgICBwYXRoID0gX29wdGlvbnMkcGF0aCA9PT0gdW5kZWZpbmVkID8gJy8nIDogX29wdGlvbnMkcGF0aCxcbiAgICAgIF9vcHRpb25zJGV4YWN0ID0gX29wdGlvbnMuZXhhY3QsXG4gICAgICBleGFjdCA9IF9vcHRpb25zJGV4YWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJGV4YWN0LFxuICAgICAgX29wdGlvbnMkc3RyaWN0ID0gX29wdGlvbnMuc3RyaWN0LFxuICAgICAgc3RyaWN0ID0gX29wdGlvbnMkc3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHN0cmljdCxcbiAgICAgIF9vcHRpb25zJHNlbnNpdGl2ZSA9IF9vcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIHNlbnNpdGl2ZSA9IF9vcHRpb25zJHNlbnNpdGl2ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRzZW5zaXRpdmU7XG5cbiAgdmFyIF9jb21waWxlUGF0aCA9IGNvbXBpbGVQYXRoKHBhdGgsIHsgZW5kOiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pLFxuICAgICAgcmUgPSBfY29tcGlsZVBhdGgucmUsXG4gICAgICBrZXlzID0gX2NvbXBpbGVQYXRoLmtleXM7XG5cbiAgdmFyIG1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSk7XG5cbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHVybCA9IG1hdGNoWzBdLFxuICAgICAgdmFsdWVzID0gbWF0Y2guc2xpY2UoMSk7XG5cbiAgdmFyIGlzRXhhY3QgPSBwYXRobmFtZSA9PT0gdXJsO1xuXG4gIGlmIChleGFjdCAmJiAhaXNFeGFjdCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLCAvLyB0aGUgcGF0aCBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2hcbiAgICB1cmw6IHBhdGggPT09ICcvJyAmJiB1cmwgPT09ICcnID8gJy8nIDogdXJsLCAvLyB0aGUgbWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBVUkxcbiAgICBpc0V4YWN0OiBpc0V4YWN0LCAvLyB3aGV0aGVyIG9yIG5vdCB3ZSBtYXRjaGVkIGV4YWN0bHlcbiAgICBwYXJhbXM6IGtleXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXksIGluZGV4KSB7XG4gICAgICBtZW1vW2tleS5uYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSlcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsImltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgd2FybmluZyhwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7P0RPTURvY3VtZW50fSBkb2MgRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykgLyo/RE9NRWxlbWVudCove1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cblxuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgLy8gSUU4IGNhbiB0aHJvdyBcIkNhbid0IG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRyb2wgYmVjYXVzZSBpdCBpcyBpbnZpc2libGUsXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcbiAgLy8gcmVhc29ucyB0aGF0IGFyZSB0b28gZXhwZW5zaXZlIGFuZCBmcmFnaWxlIHRvIHRlc3QuXG4gIHRyeSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwiaW1wb3J0IF9Ccm93c2VyUm91dGVyIGZyb20gJy4vQnJvd3NlclJvdXRlcic7XG5leHBvcnQgeyBfQnJvd3NlclJvdXRlciBhcyBCcm93c2VyUm91dGVyIH07XG5pbXBvcnQgX0hhc2hSb3V0ZXIgZnJvbSAnLi9IYXNoUm91dGVyJztcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tICcuL0xpbmsnO1xuZXhwb3J0IHsgX0xpbmsgYXMgTGluayB9O1xuaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSAnLi9NZW1vcnlSb3V0ZXInO1xuZXhwb3J0IHsgX01lbW9yeVJvdXRlciBhcyBNZW1vcnlSb3V0ZXIgfTtcbmltcG9ydCBfTmF2TGluayBmcm9tICcuL05hdkxpbmsnO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSAnLi9Qcm9tcHQnO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSAnLi9SZWRpcmVjdCc7XG5leHBvcnQgeyBfUmVkaXJlY3QgYXMgUmVkaXJlY3QgfTtcbmltcG9ydCBfUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gJy4vUm91dGVyJztcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tICcuL1N0YXRpY1JvdXRlcic7XG5leHBvcnQgeyBfU3RhdGljUm91dGVyIGFzIFN0YXRpY1JvdXRlciB9O1xuaW1wb3J0IF9Td2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSAnLi93aXRoUm91dGVyJztcbmV4cG9ydCB7IF93aXRoUm91dGVyIGFzIHdpdGhSb3V0ZXIgfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qcyIsImZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKClcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfVxuXG4gIGxpc3QucG9wKCk7XG59XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUodG8pIHtcbiAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuXG4gIHZhciB0b1BhcnRzID0gdG8gJiYgdG8uc3BsaXQoJy8nKSB8fCBbXTtcbiAgdmFyIGZyb21QYXJ0cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLycpIHx8IFtdO1xuXG4gIHZhciBpc1RvQWJzID0gdG8gJiYgaXNBYnNvbHV0ZSh0byk7XG4gIHZhciBpc0Zyb21BYnMgPSBmcm9tICYmIGlzQWJzb2x1dGUoZnJvbSk7XG4gIHZhciBtdXN0RW5kQWJzID0gaXNUb0FicyB8fCBpc0Zyb21BYnM7XG5cbiAgaWYgKHRvICYmIGlzQWJzb2x1dGUodG8pKSB7XG4gICAgLy8gdG8gaXMgYWJzb2x1dGVcbiAgICBmcm9tUGFydHMgPSB0b1BhcnRzO1xuICB9IGVsc2UgaWYgKHRvUGFydHMubGVuZ3RoKSB7XG4gICAgLy8gdG8gaXMgcmVsYXRpdmUsIGRyb3AgdGhlIGZpbGVuYW1lXG4gICAgZnJvbVBhcnRzLnBvcCgpO1xuICAgIGZyb21QYXJ0cyA9IGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cyk7XG4gIH1cblxuICBpZiAoIWZyb21QYXJ0cy5sZW5ndGgpIHJldHVybiAnLyc7XG5cbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSB2b2lkIDA7XG4gIGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3QgPSBmcm9tUGFydHNbZnJvbVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJyB8fCBsYXN0ID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gIH1cblxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gZnJvbVBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IGZyb21QYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW11c3RFbmRBYnMpIGZvciAoOyB1cC0tOyB1cCkge1xuICAgIGZyb21QYXJ0cy51bnNoaWZ0KCcuLicpO1xuICB9aWYgKG11c3RFbmRBYnMgJiYgZnJvbVBhcnRzWzBdICE9PSAnJyAmJiAoIWZyb21QYXJ0c1swXSB8fCAhaXNBYnNvbHV0ZShmcm9tUGFydHNbMF0pKSkgZnJvbVBhcnRzLnVuc2hpZnQoJycpO1xuXG4gIHZhciByZXN1bHQgPSBmcm9tUGFydHMuam9pbignLycpO1xuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHJlc3VsdC5zdWJzdHIoLTEpICE9PSAnLycpIHJlc3VsdCArPSAnLyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZVBhdGhuYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiB2YWx1ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBhVHlwZSA9IHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKTtcbiAgdmFyIGJUeXBlID0gdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpO1xuXG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpIHJldHVybiBmYWxzZTtcblxuICBpZiAoYVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGFWYWx1ZSA9IGEudmFsdWVPZigpO1xuICAgIHZhciBiVmFsdWUgPSBiLnZhbHVlT2YoKTtcblxuICAgIGlmIChhVmFsdWUgIT09IGEgfHwgYlZhbHVlICE9PSBiKSByZXR1cm4gdmFsdWVFcXVhbChhVmFsdWUsIGJWYWx1ZSk7XG5cbiAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGFba2V5XSwgYltrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVFcXVhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gZXhwb3J0cy5jYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciBnZXRDb25maXJtYXRpb24gPSBleHBvcnRzLmdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG52YXIgc3VwcG9ydHNIaXN0b3J5ID0gZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xudmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBleHBvcnRzLnN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG52YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBleHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG52YXIgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGV4cG9ydHMuaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvRE9NVXRpbHMuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5cbnZhciBpc01vZGlmaWVkRXZlbnQgPSBmdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufTtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIGEgaGlzdG9yeS1hd2FyZSA8YT4uXG4gKi9cblxudmFyIExpbmsgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTGluaywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTGluaygpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmspO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25DbGljaykgX3RoaXMucHJvcHMub25DbGljayhldmVudCk7XG5cbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiAvLyBvbkNsaWNrIHByZXZlbnRlZCBkZWZhdWx0XG4gICAgICBldmVudC5idXR0b24gPT09IDAgJiYgLy8gaWdub3JlIHJpZ2h0IGNsaWNrc1xuICAgICAgIV90aGlzLnByb3BzLnRhcmdldCAmJiAvLyBsZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gaWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB2YXIgaGlzdG9yeSA9IF90aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHJlcGxhY2UgPSBfdGhpcyRwcm9wcy5yZXBsYWNlLFxuICAgICAgICAgICAgICB0byA9IF90aGlzJHByb3BzLnRvO1xuXG5cbiAgICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlzdG9yeS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIExpbmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcmVwbGFjZSA9IF9wcm9wcy5yZXBsYWNlLFxuICAgICAgICB0byA9IF9wcm9wcy50byxcbiAgICAgICAgaW5uZXJSZWYgPSBfcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydyZXBsYWNlJywgJ3RvJywgJ2lubmVyUmVmJ10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8TGluaz4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICB2YXIgaHJlZiA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5jcmVhdGVIcmVmKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB7IHBhdGhuYW1lOiB0byB9IDogdG8pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljaywgaHJlZjogaHJlZiwgcmVmOiBpbm5lclJlZiB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkxpbmsucHJvcFR5cGVzID0ge1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICByZXBsYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICBpbm5lclJlZjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKVxufTtcbkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICByZXBsYWNlOiBmYWxzZVxufTtcbkxpbmsuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgY3JlYXRlSHJlZjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBMaW5rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9Sb3V0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlLmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5cbnZhciBpc0VtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMDtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgc2luZ2xlIHBhdGggYW5kIHJlbmRlcmluZy5cbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcywgX3RoaXMuY29udGV4dC5yb3V0ZXIpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMubG9jYXRpb24gfHwgdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChfcmVmLCByb3V0ZXIpIHtcbiAgICB2YXIgY29tcHV0ZWRNYXRjaCA9IF9yZWYuY29tcHV0ZWRNYXRjaCxcbiAgICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgICBzZW5zaXRpdmUgPSBfcmVmLnNlbnNpdGl2ZTtcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSByZXR1cm4gY29tcHV0ZWRNYXRjaDsgLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG5cbiAgICBpbnZhcmlhbnQocm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZT4gb3Igd2l0aFJvdXRlcigpIG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgdmFyIHJvdXRlID0gcm91dGVyLnJvdXRlO1xuXG4gICAgdmFyIHBhdGhuYW1lID0gKGxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uKS5wYXRobmFtZTtcblxuICAgIHJldHVybiBwYXRoID8gbWF0Y2hQYXRoKHBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIHN0cmljdDogc3RyaWN0LCBleGFjdDogZXhhY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pIDogcm91dGUubWF0Y2g7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgcmVuZGVyPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIHJlbmRlcj4gd2lsbCBiZSBpZ25vcmVkJyk7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKTtcblxuICAgIHdhcm5pbmcoISh0aGlzLnByb3BzLnJlbmRlciAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikpLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSByZW5kZXI+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCcpO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtYXRjaDogdGhpcy5jb21wdXRlTWF0Y2gobmV4dFByb3BzLCBuZXh0Q29udGV4dC5yb3V0ZXIpXG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0YXRlLm1hdGNoO1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50ID0gX3Byb3BzLmNvbXBvbmVudCxcbiAgICAgICAgcmVuZGVyID0gX3Byb3BzLnJlbmRlcjtcbiAgICB2YXIgX2NvbnRleHQkcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcixcbiAgICAgICAgaGlzdG9yeSA9IF9jb250ZXh0JHJvdXRlci5oaXN0b3J5LFxuICAgICAgICByb3V0ZSA9IF9jb250ZXh0JHJvdXRlci5yb3V0ZSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IF9jb250ZXh0JHJvdXRlci5zdGF0aWNDb250ZXh0O1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcHJvcHMgPSB7IG1hdGNoOiBtYXRjaCwgbG9jYXRpb246IGxvY2F0aW9uLCBoaXN0b3J5OiBoaXN0b3J5LCBzdGF0aWNDb250ZXh0OiBzdGF0aWNDb250ZXh0IH07XG5cbiAgICByZXR1cm4gY29tcG9uZW50ID8gLy8gY29tcG9uZW50IHByb3AgZ2V0cyBmaXJzdCBwcmlvcml0eSwgb25seSBjYWxsZWQgaWYgdGhlcmUncyBhIG1hdGNoXG4gICAgbWF0Y2ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogbnVsbCA6IHJlbmRlciA/IC8vIHJlbmRlciBwcm9wIGlzIG5leHQsIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gcmVuZGVyKHByb3BzKSA6IG51bGwgOiBjaGlsZHJlbiA/IC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxuICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHByb3BzKSA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlLnByb3BUeXBlcyA9IHtcbiAgY29tcHV0ZWRNYXRjaDogUHJvcFR5cGVzLm9iamVjdCwgLy8gcHJpdmF0ZSwgZnJvbSA8U3dpdGNoPlxuICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZS5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59O1xuUm91dGUuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGUuanMiLCJleHBvcnQgdmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbmV4cG9ydCB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG5leHBvcnQgdmFyIGdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG5leHBvcnQgdmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIGJ0b2EgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmJ0b2EgJiYgd2luZG93LmJ0b2EuYmluZCh3aW5kb3cpKSB8fCByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnRvYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBsb2FkRXZlbnQgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbiAgICB2YXIgeERvbWFpbiA9IGZhbHNlO1xuXG4gICAgLy8gRm9yIElFIDgvOSBDT1JTIHN1cHBvcnRcbiAgICAvLyBPbmx5IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBjYWxscyBhbmQgZG9lc24ndCByZXR1cm5zIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgIC8vIERPTidUIGRvIHRoaXMgZm9yIHRlc3RpbmcgYi9jIFhNTEh0dHBSZXF1ZXN0IGlzIG1vY2tlZCwgbm90IFhEb21haW5SZXF1ZXN0LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAgICFpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpIHtcbiAgICAgIHJlcXVlc3QgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICBsb2FkRXZlbnQgPSAnb25sb2FkJztcbiAgICAgIHhEb21haW4gPSB0cnVlO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3MoKSB7fTtcbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHt9O1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3RbbG9hZEV2ZW50XSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCAmJiAheERvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgLy8gSUUgc2VuZHMgMTIyMyBpbnN0ZWFkIG9mIDIwNCAoaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXIgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgQnJvd3NlclJvdXRlciB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcy5qcyc7XG5cbnJlbmRlcihcblx0PEJyb3dzZXJSb3V0ZXI+e3JvdXRlc308L0Jyb3dzZXJSb3V0ZXI+LFxuXHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJylcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvYXBwLmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLG49cmVxdWlyZShcImZianMvbGliL2VtcHR5T2JqZWN0XCIpLHA9cmVxdWlyZShcImZianMvbGliL2VtcHR5RnVuY3Rpb25cIikscT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0scj1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMsdD1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNhbGxcIik6NjAxMDQsdT1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKTo2MDEwNSx2PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LHc9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyx4PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIHkoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxlPVwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGM9MDtjPGI7YysrKWUrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYysxXSk7Yj1FcnJvcihlK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7Yi5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwiO2IuZnJhbWVzVG9Qb3A9MTt0aHJvdyBiO31cbnZhciB6PXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fTtmdW5jdGlvbiBBKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9QS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtBLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJm51bGwhPWE/eShcIjg1XCIpOnZvaWQgMDt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0EucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gQihhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHx6fWZ1bmN0aW9uIEMoKXt9Qy5wcm90b3R5cGU9QS5wcm90b3R5cGU7dmFyIEQ9Qi5wcm90b3R5cGU9bmV3IEM7RC5jb25zdHJ1Y3Rvcj1CO20oRCxBLnByb3RvdHlwZSk7RC5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDtmdW5jdGlvbiBFKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9dmFyIEY9RS5wcm90b3R5cGU9bmV3IEM7Ri5jb25zdHJ1Y3Rvcj1FO20oRixBLnByb3RvdHlwZSk7Ri51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ9ITA7Ri5yZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbn07dmFyIEc9e2N1cnJlbnQ6bnVsbH0sSD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LEk9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIEooYSxiLGUpe3ZhciBjLGQ9e30sZz1udWxsLGs9bnVsbDtpZihudWxsIT1iKWZvcihjIGluIHZvaWQgMCE9PWIucmVmJiYoaz1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihnPVwiXCIrYi5rZXkpLGIpSC5jYWxsKGIsYykmJiFJLmhhc093blByb3BlcnR5KGMpJiYoZFtjXT1iW2NdKTt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWYpZC5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxmKXtmb3IodmFyIGg9QXJyYXkoZiksbD0wO2w8ZjtsKyspaFtsXT1hcmd1bWVudHNbbCsyXTtkLmNoaWxkcmVuPWh9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGMgaW4gZj1hLmRlZmF1bHRQcm9wcyxmKXZvaWQgMD09PWRbY10mJihkW2NdPWZbY10pO3JldHVybnskJHR5cGVvZjpyLHR5cGU6YSxrZXk6ZyxyZWY6ayxwcm9wczpkLF9vd25lcjpHLmN1cnJlbnR9fWZ1bmN0aW9uIEsoYSl7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmYS4kJHR5cGVvZj09PXJ9XG5mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiXFx4M2RcIjpcIlxceDNkMFwiLFwiOlwiOlwiXFx4M2QyXCJ9O3JldHVyblwiJFwiKyhcIlwiK2EpLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBMPS9cXC8rL2csTT1bXTtmdW5jdGlvbiBOKGEsYixlLGMpe2lmKE0ubGVuZ3RoKXt2YXIgZD1NLnBvcCgpO2QucmVzdWx0PWE7ZC5rZXlQcmVmaXg9YjtkLmZ1bmM9ZTtkLmNvbnRleHQ9YztkLmNvdW50PTA7cmV0dXJuIGR9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6ZSxjb250ZXh0OmMsY291bnQ6MH19ZnVuY3Rpb24gTyhhKXthLnJlc3VsdD1udWxsO2Eua2V5UHJlZml4PW51bGw7YS5mdW5jPW51bGw7YS5jb250ZXh0PW51bGw7YS5jb3VudD0wOzEwPk0ubGVuZ3RoJiZNLnB1c2goYSl9XG5mdW5jdGlvbiBQKGEsYixlLGMpe3ZhciBkPXR5cGVvZiBhO2lmKFwidW5kZWZpbmVkXCI9PT1kfHxcImJvb2xlYW5cIj09PWQpYT1udWxsO3ZhciBnPSExO2lmKG51bGw9PT1hKWc9ITA7ZWxzZSBzd2l0Y2goZCl7Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJudW1iZXJcIjpnPSEwO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjpzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSByOmNhc2UgdDpjYXNlIHU6Y2FzZSB2Omc9ITB9fWlmKGcpcmV0dXJuIGUoYyxhLFwiXCI9PT1iP1wiLlwiK1EoYSwwKTpiKSwxO2c9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGs9MDtrPGEubGVuZ3RoO2srKyl7ZD1hW2tdO3ZhciBmPWIrUShkLGspO2crPVAoZCxmLGUsYyl9ZWxzZSBpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP2Y9bnVsbDooZj14JiZhW3hdfHxhW1wiQEBpdGVyYXRvclwiXSxmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmP2Y6bnVsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9XG5mLmNhbGwoYSksaz0wOyEoZD1hLm5leHQoKSkuZG9uZTspZD1kLnZhbHVlLGY9YitRKGQsaysrKSxnKz1QKGQsZixlLGMpO2Vsc2VcIm9iamVjdFwiPT09ZCYmKGU9XCJcIithLHkoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1lP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmUsXCJcIikpO3JldHVybiBnfWZ1bmN0aW9uIFEoYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoYS5rZXkpOmIudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIFIoYSxiKXthLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspfVxuZnVuY3Rpb24gUyhhLGIsZSl7dmFyIGM9YS5yZXN1bHQsZD1hLmtleVByZWZpeDthPWEuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyk7QXJyYXkuaXNBcnJheShhKT9UKGEsYyxlLHAudGhhdFJldHVybnNBcmd1bWVudCk6bnVsbCE9YSYmKEsoYSkmJihiPWQrKCFhLmtleXx8YiYmYi5rZXk9PT1hLmtleT9cIlwiOihcIlwiK2Eua2V5KS5yZXBsYWNlKEwsXCIkXFx4MjYvXCIpK1wiL1wiKStlLGE9eyQkdHlwZW9mOnIsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfSksYy5wdXNoKGEpKX1mdW5jdGlvbiBUKGEsYixlLGMsZCl7dmFyIGc9XCJcIjtudWxsIT1lJiYoZz0oXCJcIitlKS5yZXBsYWNlKEwsXCIkXFx4MjYvXCIpK1wiL1wiKTtiPU4oYixnLGMsZCk7bnVsbD09YXx8UChhLFwiXCIsUyxiKTtPKGIpfVxudmFyIFU9e0NoaWxkcmVuOnttYXA6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGM9W107VChhLGMsbnVsbCxiLGUpO3JldHVybiBjfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO2I9TihudWxsLG51bGwsYixlKTtudWxsPT1hfHxQKGEsXCJcIixSLGIpO08oYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hPzA6UChhLFwiXCIscC50aGF0UmV0dXJuc051bGwsbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107VChhLGIsbnVsbCxwLnRoYXRSZXR1cm5zQXJndW1lbnQpO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe0soYSk/dm9pZCAwOnkoXCIxNDNcIik7cmV0dXJuIGF9fSxDb21wb25lbnQ6QSxQdXJlQ29tcG9uZW50OkIsdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6RSxGcmFnbWVudDp3LGNyZWF0ZUVsZW1lbnQ6SixjbG9uZUVsZW1lbnQ6ZnVuY3Rpb24oYSxiLGUpe3ZhciBjPW0oe30sYS5wcm9wcyksXG5kPWEua2V5LGc9YS5yZWYsaz1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGc9Yi5yZWYsaz1HLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGY9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoaCBpbiBiKUguY2FsbChiLGgpJiYhSS5oYXNPd25Qcm9wZXJ0eShoKSYmKGNbaF09dm9pZCAwPT09YltoXSYmdm9pZCAwIT09Zj9mW2hdOmJbaF0pfXZhciBoPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09aCljLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGgpe2Y9QXJyYXkoaCk7Zm9yKHZhciBsPTA7bDxoO2wrKylmW2xdPWFyZ3VtZW50c1tsKzJdO2MuY2hpbGRyZW49Zn1yZXR1cm57JCR0eXBlb2Y6cix0eXBlOmEudHlwZSxrZXk6ZCxyZWY6Zyxwcm9wczpjLF9vd25lcjprfX0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbihhKXt2YXIgYj1KLmJpbmQobnVsbCxhKTtiLnR5cGU9YTtyZXR1cm4gYn0sXG5pc1ZhbGlkRWxlbWVudDpLLHZlcnNpb246XCIxNi4yLjBcIixfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7UmVhY3RDdXJyZW50T3duZXI6Ryxhc3NpZ246bX19LFY9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpVfSksVz1WJiZVfHxWO21vZHVsZS5leHBvcnRzPVdbXCJkZWZhdWx0XCJdP1dbXCJkZWZhdWx0XCJdOlc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjIuMCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX0NBTExfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNhbGwnKSA6IDB4ZWFjODtcbnZhciBSRUFDVF9SRVRVUk5fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnJldHVybicpIDogMHhlYWM5O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuZnVuY3Rpb24gQXN5bmNDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBhc3luY0NvbXBvbmVudFByb3RvdHlwZSA9IEFzeW5jQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3luY0NvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihhc3luY0NvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudCAhPT0gbnVsbCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobnVsbCwgbnVsbCwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxue1xuICB2YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gIHZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuXG4gIHZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgcmV0dXJuICdSZWFjdC5GcmFnbWVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJztcbiAgICBpZiAoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyKSk7XG4gICAgfVxuICAgIHN0YWNrICs9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgVkFMSURfRlJBR01FTlRfUFJPUFMgPSBuZXcgTWFwKFtbJ2NoaWxkcmVuJywgdHJ1ZV0sIFsna2V5JywgdHJ1ZV1dKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIpICsgJy4nO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICB2YXIgcHJvcFR5cGVzID0gY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzO1xuICBpZiAocHJvcFR5cGVzKSB7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKTtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50Q2xhc3MuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBuYW1lIHx8ICdVbmtub3duJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGZyYWdtZW50O1xuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKCFWQUxJRF9GUkFHTUVOVF9QUk9QUy5oYXMoa2V5KSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLiVzJywga2V5LCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvclsncmV0dXJuJ10pIHtcbiAgICAgICAgX2l0ZXJhdG9yWydyZXR1cm4nXSgpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiVzJywgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ251bWJlcic7XG4gIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHByb3BzKTtcbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIGluZm8gKz0gZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N5bWJvbCcgJiYgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuICBDaGlsZHJlbjoge1xuICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXG4gIHVuc3RhYmxlX0FzeW5jQ29tcG9uZW50OiBBc3luY0NvbXBvbmVudCxcblxuICBGcmFnbWVudDogUkVBQ1RfRlJBR01FTlRfVFlQRSxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbixcbiAgaXNWYWxpZEVsZW1lbnQ6IGlzVmFsaWRFbGVtZW50LFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICAgIGFzc2lnbjogX2Fzc2lnblxuICB9XG59O1xuXG57XG4gIF9hc3NpZ24oUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkM1snZGVmYXVsdCddID8gUmVhY3QkM1snZGVmYXVsdCddIDogUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG4gTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBhYT1yZXF1aXJlKFwicmVhY3RcIiksbD1yZXF1aXJlKFwiZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnRcIiksQj1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxDPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uXCIpLGJhPXJlcXVpcmUoXCJmYmpzL2xpYi9FdmVudExpc3RlbmVyXCIpLGRhPXJlcXVpcmUoXCJmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50XCIpLGVhPXJlcXVpcmUoXCJmYmpzL2xpYi9zaGFsbG93RXF1YWxcIiksZmE9cmVxdWlyZShcImZianMvbGliL2NvbnRhaW5zTm9kZVwiKSxpYT1yZXF1aXJlKFwiZmJqcy9saWIvZm9jdXNOb2RlXCIpLEQ9cmVxdWlyZShcImZianMvbGliL2VtcHR5T2JqZWN0XCIpO1xuZnVuY3Rpb24gRShhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGM9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsZD0wO2Q8YjtkKyspYys9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tkKzFdKTtiPUVycm9yKGMrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fWFhP3ZvaWQgMDpFKFwiMjI3XCIpO1xudmFyIG9hPXtjaGlsZHJlbjohMCxkYW5nZXJvdXNseVNldElubmVySFRNTDohMCxkZWZhdWx0VmFsdWU6ITAsZGVmYXVsdENoZWNrZWQ6ITAsaW5uZXJIVE1MOiEwLHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzohMCxzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6ITAsc3R5bGU6ITB9O2Z1bmN0aW9uIHBhKGEsYil7cmV0dXJuKGEmYik9PT1ifVxudmFyIHRhPXtNVVNUX1VTRV9QUk9QRVJUWToxLEhBU19CT09MRUFOX1ZBTFVFOjQsSEFTX05VTUVSSUNfVkFMVUU6OCxIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRToyNCxIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOjMyLEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTo2NCxpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzpmdW5jdGlvbihhKXt2YXIgYj10YSxjPWEuUHJvcGVydGllc3x8e30sZD1hLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXN8fHt9LGU9YS5ET01BdHRyaWJ1dGVOYW1lc3x8e307YT1hLkRPTU11dGF0aW9uTWV0aG9kc3x8e307Zm9yKHZhciBmIGluIGMpe3VhLmhhc093blByb3BlcnR5KGYpP0UoXCI0OFwiLGYpOnZvaWQgMDt2YXIgZz1mLnRvTG93ZXJDYXNlKCksaD1jW2ZdO2c9e2F0dHJpYnV0ZU5hbWU6ZyxhdHRyaWJ1dGVOYW1lc3BhY2U6bnVsbCxwcm9wZXJ0eU5hbWU6ZixtdXRhdGlvbk1ldGhvZDpudWxsLG11c3RVc2VQcm9wZXJ0eTpwYShoLGIuTVVTVF9VU0VfUFJPUEVSVFkpLFxuaGFzQm9vbGVhblZhbHVlOnBhKGgsYi5IQVNfQk9PTEVBTl9WQUxVRSksaGFzTnVtZXJpY1ZhbHVlOnBhKGgsYi5IQVNfTlVNRVJJQ19WQUxVRSksaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6cGEoaCxiLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOnBhKGgsYi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKSxoYXNTdHJpbmdCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSl9OzE+PWcuaGFzQm9vbGVhblZhbHVlK2cuaGFzTnVtZXJpY1ZhbHVlK2cuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZT92b2lkIDA6RShcIjUwXCIsZik7ZS5oYXNPd25Qcm9wZXJ0eShmKSYmKGcuYXR0cmlidXRlTmFtZT1lW2ZdKTtkLmhhc093blByb3BlcnR5KGYpJiYoZy5hdHRyaWJ1dGVOYW1lc3BhY2U9ZFtmXSk7YS5oYXNPd25Qcm9wZXJ0eShmKSYmKGcubXV0YXRpb25NZXRob2Q9YVtmXSk7dWFbZl09Z319fSx1YT17fTtcbmZ1bmN0aW9uIHZhKGEsYil7aWYob2EuaGFzT3duUHJvcGVydHkoYSl8fDI8YS5sZW5ndGgmJihcIm9cIj09PWFbMF18fFwiT1wiPT09YVswXSkmJihcIm5cIj09PWFbMV18fFwiTlwiPT09YVsxXSkpcmV0dXJuITE7aWYobnVsbD09PWIpcmV0dXJuITA7c3dpdGNoKHR5cGVvZiBiKXtjYXNlIFwiYm9vbGVhblwiOnJldHVybiBvYS5oYXNPd25Qcm9wZXJ0eShhKT9hPSEwOihiPXdhKGEpKT9hPWIuaGFzQm9vbGVhblZhbHVlfHxiLmhhc1N0cmluZ0Jvb2xlYW5WYWx1ZXx8Yi5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOihhPWEudG9Mb3dlckNhc2UoKS5zbGljZSgwLDUpLGE9XCJkYXRhLVwiPT09YXx8XCJhcmlhLVwiPT09YSksYTtjYXNlIFwidW5kZWZpbmVkXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJzdHJpbmdcIjpjYXNlIFwib2JqZWN0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gd2EoYSl7cmV0dXJuIHVhLmhhc093blByb3BlcnR5KGEpP3VhW2FdOm51bGx9XG52YXIgeGE9dGEseWE9eGEuTVVTVF9VU0VfUFJPUEVSVFksSz14YS5IQVNfQk9PTEVBTl9WQUxVRSx6YT14YS5IQVNfTlVNRVJJQ19WQUxVRSxBYT14YS5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxCYT14YS5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLENhPXhhLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxEYT17UHJvcGVydGllczp7YWxsb3dGdWxsU2NyZWVuOkssYXN5bmM6SyxhdXRvRm9jdXM6SyxhdXRvUGxheTpLLGNhcHR1cmU6QmEsY2hlY2tlZDp5YXxLLGNvbHM6QWEsY29udGVudEVkaXRhYmxlOkNhLGNvbnRyb2xzOkssXCJkZWZhdWx0XCI6SyxkZWZlcjpLLGRpc2FibGVkOkssZG93bmxvYWQ6QmEsZHJhZ2dhYmxlOkNhLGZvcm1Ob1ZhbGlkYXRlOkssaGlkZGVuOkssbG9vcDpLLG11bHRpcGxlOnlhfEssbXV0ZWQ6eWF8Syxub1ZhbGlkYXRlOkssb3BlbjpLLHBsYXlzSW5saW5lOksscmVhZE9ubHk6SyxyZXF1aXJlZDpLLHJldmVyc2VkOksscm93czpBYSxyb3dTcGFuOnphLFxuc2NvcGVkOkssc2VhbWxlc3M6SyxzZWxlY3RlZDp5YXxLLHNpemU6QWEsc3RhcnQ6emEsc3BhbjpBYSxzcGVsbENoZWNrOkNhLHN0eWxlOjAsdGFiSW5kZXg6MCxpdGVtU2NvcGU6SyxhY2NlcHRDaGFyc2V0OjAsY2xhc3NOYW1lOjAsaHRtbEZvcjowLGh0dHBFcXVpdjowLHZhbHVlOkNhfSxET01BdHRyaWJ1dGVOYW1lczp7YWNjZXB0Q2hhcnNldDpcImFjY2VwdC1jaGFyc2V0XCIsY2xhc3NOYW1lOlwiY2xhc3NcIixodG1sRm9yOlwiZm9yXCIsaHR0cEVxdWl2OlwiaHR0cC1lcXVpdlwifSxET01NdXRhdGlvbk1ldGhvZHM6e3ZhbHVlOmZ1bmN0aW9uKGEsYil7aWYobnVsbD09YilyZXR1cm4gYS5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcIm51bWJlclwiIT09YS50eXBlfHwhMT09PWEuaGFzQXR0cmlidXRlKFwidmFsdWVcIik/YS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIrYik6YS52YWxpZGl0eSYmIWEudmFsaWRpdHkuYmFkSW5wdXQmJmEub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50IT09YSYmXG5hLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitiKX19fSxFYT14YS5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsTT17eGxpbms6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIseG1sOlwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCJ9LEdhPXtQcm9wZXJ0aWVzOnthdXRvUmV2ZXJzZTpFYSxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOkVhLHByZXNlcnZlQWxwaGE6RWF9LERPTUF0dHJpYnV0ZU5hbWVzOnthdXRvUmV2ZXJzZTpcImF1dG9SZXZlcnNlXCIsZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDpcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixwcmVzZXJ2ZUFscGhhOlwicHJlc2VydmVBbHBoYVwifSxET01BdHRyaWJ1dGVOYW1lc3BhY2VzOnt4bGlua0FjdHVhdGU6TS54bGluayx4bGlua0FyY3JvbGU6TS54bGluayx4bGlua0hyZWY6TS54bGluayx4bGlua1JvbGU6TS54bGluayx4bGlua1Nob3c6TS54bGluayx4bGlua1RpdGxlOk0ueGxpbmsseGxpbmtUeXBlOk0ueGxpbmssXG54bWxCYXNlOk0ueG1sLHhtbExhbmc6TS54bWwseG1sU3BhY2U6TS54bWx9fSxIYT0vW1xcLVxcOl0oW2Etel0pL2c7ZnVuY3Rpb24gSWEoYSl7cmV0dXJuIGFbMV0udG9VcHBlckNhc2UoKX1cblwiYWNjZW50LWhlaWdodCBhbGlnbm1lbnQtYmFzZWxpbmUgYXJhYmljLWZvcm0gYmFzZWxpbmUtc2hpZnQgY2FwLWhlaWdodCBjbGlwLXBhdGggY2xpcC1ydWxlIGNvbG9yLWludGVycG9sYXRpb24gY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzIGNvbG9yLXByb2ZpbGUgY29sb3ItcmVuZGVyaW5nIGRvbWluYW50LWJhc2VsaW5lIGVuYWJsZS1iYWNrZ3JvdW5kIGZpbGwtb3BhY2l0eSBmaWxsLXJ1bGUgZmxvb2QtY29sb3IgZmxvb2Qtb3BhY2l0eSBmb250LWZhbWlseSBmb250LXNpemUgZm9udC1zaXplLWFkanVzdCBmb250LXN0cmV0Y2ggZm9udC1zdHlsZSBmb250LXZhcmlhbnQgZm9udC13ZWlnaHQgZ2x5cGgtbmFtZSBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsIGhvcml6LWFkdi14IGhvcml6LW9yaWdpbi14IGltYWdlLXJlbmRlcmluZyBsZXR0ZXItc3BhY2luZyBsaWdodGluZy1jb2xvciBtYXJrZXItZW5kIG1hcmtlci1taWQgbWFya2VyLXN0YXJ0IG92ZXJsaW5lLXBvc2l0aW9uIG92ZXJsaW5lLXRoaWNrbmVzcyBwYWludC1vcmRlciBwYW5vc2UtMSBwb2ludGVyLWV2ZW50cyByZW5kZXJpbmctaW50ZW50IHNoYXBlLXJlbmRlcmluZyBzdG9wLWNvbG9yIHN0b3Atb3BhY2l0eSBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uIHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzIHN0cm9rZS1kYXNoYXJyYXkgc3Ryb2tlLWRhc2hvZmZzZXQgc3Ryb2tlLWxpbmVjYXAgc3Ryb2tlLWxpbmVqb2luIHN0cm9rZS1taXRlcmxpbWl0IHN0cm9rZS1vcGFjaXR5IHN0cm9rZS13aWR0aCB0ZXh0LWFuY2hvciB0ZXh0LWRlY29yYXRpb24gdGV4dC1yZW5kZXJpbmcgdW5kZXJsaW5lLXBvc2l0aW9uIHVuZGVybGluZS10aGlja25lc3MgdW5pY29kZS1iaWRpIHVuaWNvZGUtcmFuZ2UgdW5pdHMtcGVyLWVtIHYtYWxwaGFiZXRpYyB2LWhhbmdpbmcgdi1pZGVvZ3JhcGhpYyB2LW1hdGhlbWF0aWNhbCB2ZWN0b3ItZWZmZWN0IHZlcnQtYWR2LXkgdmVydC1vcmlnaW4teCB2ZXJ0LW9yaWdpbi15IHdvcmQtc3BhY2luZyB3cml0aW5nLW1vZGUgeC1oZWlnaHQgeGxpbms6YWN0dWF0ZSB4bGluazphcmNyb2xlIHhsaW5rOmhyZWYgeGxpbms6cm9sZSB4bGluazpzaG93IHhsaW5rOnRpdGxlIHhsaW5rOnR5cGUgeG1sOmJhc2UgeG1sbnM6eGxpbmsgeG1sOmxhbmcgeG1sOnNwYWNlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKEhhLFxuSWEpO0dhLlByb3BlcnRpZXNbYl09MDtHYS5ET01BdHRyaWJ1dGVOYW1lc1tiXT1hfSk7eGEuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoRGEpO3hhLmluamVjdERPTVByb3BlcnR5Q29uZmlnKEdhKTtcbnZhciBQPXtfY2F1Z2h0RXJyb3I6bnVsbCxfaGFzQ2F1Z2h0RXJyb3I6ITEsX3JldGhyb3dFcnJvcjpudWxsLF9oYXNSZXRocm93RXJyb3I6ITEsaW5qZWN0aW9uOntpbmplY3RFcnJvclV0aWxzOmZ1bmN0aW9uKGEpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBhLmludm9rZUd1YXJkZWRDYWxsYmFjaz9FKFwiMTk3XCIpOnZvaWQgMDtKYT1hLmludm9rZUd1YXJkZWRDYWxsYmFja319LGludm9rZUd1YXJkZWRDYWxsYmFjazpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsayl7SmEuYXBwbHkoUCxhcmd1bWVudHMpfSxpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGspe1AuaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihQLmhhc0NhdWdodEVycm9yKCkpe3ZhciBxPVAuY2xlYXJDYXVnaHRFcnJvcigpO1AuX2hhc1JldGhyb3dFcnJvcnx8KFAuX2hhc1JldGhyb3dFcnJvcj0hMCxQLl9yZXRocm93RXJyb3I9XG5xKX19LHJldGhyb3dDYXVnaHRFcnJvcjpmdW5jdGlvbigpe3JldHVybiBLYS5hcHBseShQLGFyZ3VtZW50cyl9LGhhc0NhdWdodEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIFAuX2hhc0NhdWdodEVycm9yfSxjbGVhckNhdWdodEVycm9yOmZ1bmN0aW9uKCl7aWYoUC5faGFzQ2F1Z2h0RXJyb3Ipe3ZhciBhPVAuX2NhdWdodEVycm9yO1AuX2NhdWdodEVycm9yPW51bGw7UC5faGFzQ2F1Z2h0RXJyb3I9ITE7cmV0dXJuIGF9RShcIjE5OFwiKX19O2Z1bmN0aW9uIEphKGEsYixjLGQsZSxmLGcsaCxrKXtQLl9oYXNDYXVnaHRFcnJvcj0hMTtQLl9jYXVnaHRFcnJvcj1udWxsO3ZhciBxPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywzKTt0cnl7Yi5hcHBseShjLHEpfWNhdGNoKHYpe1AuX2NhdWdodEVycm9yPXYsUC5faGFzQ2F1Z2h0RXJyb3I9ITB9fVxuZnVuY3Rpb24gS2EoKXtpZihQLl9oYXNSZXRocm93RXJyb3Ipe3ZhciBhPVAuX3JldGhyb3dFcnJvcjtQLl9yZXRocm93RXJyb3I9bnVsbDtQLl9oYXNSZXRocm93RXJyb3I9ITE7dGhyb3cgYTt9fXZhciBMYT1udWxsLE1hPXt9O1xuZnVuY3Rpb24gTmEoKXtpZihMYSlmb3IodmFyIGEgaW4gTWEpe3ZhciBiPU1hW2FdLGM9TGEuaW5kZXhPZihhKTstMTxjP3ZvaWQgMDpFKFwiOTZcIixhKTtpZighT2FbY10pe2IuZXh0cmFjdEV2ZW50cz92b2lkIDA6RShcIjk3XCIsYSk7T2FbY109YjtjPWIuZXZlbnRUeXBlcztmb3IodmFyIGQgaW4gYyl7dmFyIGU9dm9pZCAwO3ZhciBmPWNbZF0sZz1iLGg9ZDtQYS5oYXNPd25Qcm9wZXJ0eShoKT9FKFwiOTlcIixoKTp2b2lkIDA7UGFbaF09Zjt2YXIgaz1mLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO2lmKGspe2ZvcihlIGluIGspay5oYXNPd25Qcm9wZXJ0eShlKSYmUWEoa1tlXSxnLGgpO2U9ITB9ZWxzZSBmLnJlZ2lzdHJhdGlvbk5hbWU/KFFhKGYucmVnaXN0cmF0aW9uTmFtZSxnLGgpLGU9ITApOmU9ITE7ZT92b2lkIDA6RShcIjk4XCIsZCxhKX19fX1cbmZ1bmN0aW9uIFFhKGEsYixjKXtSYVthXT9FKFwiMTAwXCIsYSk6dm9pZCAwO1JhW2FdPWI7U2FbYV09Yi5ldmVudFR5cGVzW2NdLmRlcGVuZGVuY2llc312YXIgT2E9W10sUGE9e30sUmE9e30sU2E9e307ZnVuY3Rpb24gVGEoYSl7TGE/RShcIjEwMVwiKTp2b2lkIDA7TGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSk7TmEoKX1mdW5jdGlvbiBVYShhKXt2YXIgYj0hMSxjO2ZvcihjIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9YVtjXTtNYS5oYXNPd25Qcm9wZXJ0eShjKSYmTWFbY109PT1kfHwoTWFbY10/RShcIjEwMlwiLGMpOnZvaWQgMCxNYVtjXT1kLGI9ITApfWImJk5hKCl9XG52YXIgVmE9T2JqZWN0LmZyZWV6ZSh7cGx1Z2luczpPYSxldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6UGEscmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6UmEscmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczpTYSxwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOm51bGwsaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjpUYSxpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6VWF9KSxXYT1udWxsLFhhPW51bGwsWWE9bnVsbDtmdW5jdGlvbiBaYShhLGIsYyxkKXtiPWEudHlwZXx8XCJ1bmtub3duLWV2ZW50XCI7YS5jdXJyZW50VGFyZ2V0PVlhKGQpO1AuaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKGIsYyx2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9XG5mdW5jdGlvbiAkYShhLGIpe251bGw9PWI/RShcIjMwXCIpOnZvaWQgMDtpZihudWxsPT1hKXJldHVybiBiO2lmKEFycmF5LmlzQXJyYXkoYSkpe2lmKEFycmF5LmlzQXJyYXkoYikpcmV0dXJuIGEucHVzaC5hcHBseShhLGIpLGE7YS5wdXNoKGIpO3JldHVybiBhfXJldHVybiBBcnJheS5pc0FycmF5KGIpP1thXS5jb25jYXQoYik6W2EsYl19ZnVuY3Rpb24gYWIoYSxiLGMpe0FycmF5LmlzQXJyYXkoYSk/YS5mb3JFYWNoKGIsYyk6YSYmYi5jYWxsKGMsYSl9dmFyIGJiPW51bGw7XG5mdW5jdGlvbiBjYihhLGIpe2lmKGEpe3ZhciBjPWEuX2Rpc3BhdGNoTGlzdGVuZXJzLGQ9YS5fZGlzcGF0Y2hJbnN0YW5jZXM7aWYoQXJyYXkuaXNBcnJheShjKSlmb3IodmFyIGU9MDtlPGMubGVuZ3RoJiYhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO2UrKylaYShhLGIsY1tlXSxkW2VdKTtlbHNlIGMmJlphKGEsYixjLGQpO2EuX2Rpc3BhdGNoTGlzdGVuZXJzPW51bGw7YS5fZGlzcGF0Y2hJbnN0YW5jZXM9bnVsbDthLmlzUGVyc2lzdGVudCgpfHxhLmNvbnN0cnVjdG9yLnJlbGVhc2UoYSl9fWZ1bmN0aW9uIGRiKGEpe3JldHVybiBjYihhLCEwKX1mdW5jdGlvbiBnYihhKXtyZXR1cm4gY2IoYSwhMSl9dmFyIGhiPXtpbmplY3RFdmVudFBsdWdpbk9yZGVyOlRhLGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpVYX07XG5mdW5jdGlvbiBpYihhLGIpe3ZhciBjPWEuc3RhdGVOb2RlO2lmKCFjKXJldHVybiBudWxsO3ZhciBkPVdhKGMpO2lmKCFkKXJldHVybiBudWxsO2M9ZFtiXTthOnN3aXRjaChiKXtjYXNlIFwib25DbGlja1wiOmNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbkRvdWJsZUNsaWNrXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VEb3duXCI6Y2FzZSBcIm9uTW91c2VEb3duQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlTW92ZVwiOmNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZVVwXCI6Y2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2MmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjP0UoXCIyMzFcIixiLHR5cGVvZiBjKTp2b2lkIDA7XG5yZXR1cm4gY31mdW5jdGlvbiBqYihhLGIsYyxkKXtmb3IodmFyIGUsZj0wO2Y8T2EubGVuZ3RoO2YrKyl7dmFyIGc9T2FbZl07ZyYmKGc9Zy5leHRyYWN0RXZlbnRzKGEsYixjLGQpKSYmKGU9JGEoZSxnKSl9cmV0dXJuIGV9ZnVuY3Rpb24ga2IoYSl7YSYmKGJiPSRhKGJiLGEpKX1mdW5jdGlvbiBsYihhKXt2YXIgYj1iYjtiYj1udWxsO2ImJihhP2FiKGIsZGIpOmFiKGIsZ2IpLGJiP0UoXCI5NVwiKTp2b2lkIDAsUC5yZXRocm93Q2F1Z2h0RXJyb3IoKSl9dmFyIG1iPU9iamVjdC5mcmVlemUoe2luamVjdGlvbjpoYixnZXRMaXN0ZW5lcjppYixleHRyYWN0RXZlbnRzOmpiLGVucXVldWVFdmVudHM6a2IscHJvY2Vzc0V2ZW50UXVldWU6bGJ9KSxuYj1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxRPVwiX19yZWFjdEludGVybmFsSW5zdGFuY2UkXCIrbmIsb2I9XCJfX3JlYWN0RXZlbnRIYW5kbGVycyRcIituYjtcbmZ1bmN0aW9uIHBiKGEpe2lmKGFbUV0pcmV0dXJuIGFbUV07Zm9yKHZhciBiPVtdOyFhW1FdOylpZihiLnB1c2goYSksYS5wYXJlbnROb2RlKWE9YS5wYXJlbnROb2RlO2Vsc2UgcmV0dXJuIG51bGw7dmFyIGM9dm9pZCAwLGQ9YVtRXTtpZig1PT09ZC50YWd8fDY9PT1kLnRhZylyZXR1cm4gZDtmb3IoO2EmJihkPWFbUV0pO2E9Yi5wb3AoKSljPWQ7cmV0dXJuIGN9ZnVuY3Rpb24gcWIoYSl7aWYoNT09PWEudGFnfHw2PT09YS50YWcpcmV0dXJuIGEuc3RhdGVOb2RlO0UoXCIzM1wiKX1mdW5jdGlvbiByYihhKXtyZXR1cm4gYVtvYl18fG51bGx9XG52YXIgc2I9T2JqZWN0LmZyZWV6ZSh7cHJlY2FjaGVGaWJlck5vZGU6ZnVuY3Rpb24oYSxiKXtiW1FdPWF9LGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOnBiLGdldEluc3RhbmNlRnJvbU5vZGU6ZnVuY3Rpb24oYSl7YT1hW1FdO3JldHVybiFhfHw1IT09YS50YWcmJjYhPT1hLnRhZz9udWxsOmF9LGdldE5vZGVGcm9tSW5zdGFuY2U6cWIsZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTpyYix1cGRhdGVGaWJlclByb3BzOmZ1bmN0aW9uKGEsYil7YVtvYl09Yn19KTtmdW5jdGlvbiB0YihhKXtkbyBhPWFbXCJyZXR1cm5cIl07d2hpbGUoYSYmNSE9PWEudGFnKTtyZXR1cm4gYT9hOm51bGx9ZnVuY3Rpb24gdWIoYSxiLGMpe2Zvcih2YXIgZD1bXTthOylkLnB1c2goYSksYT10YihhKTtmb3IoYT1kLmxlbmd0aDswPGEtLTspYihkW2FdLFwiY2FwdHVyZWRcIixjKTtmb3IoYT0wO2E8ZC5sZW5ndGg7YSsrKWIoZFthXSxcImJ1YmJsZWRcIixjKX1cbmZ1bmN0aW9uIHZiKGEsYixjKXtpZihiPWliKGEsYy5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1tiXSkpYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9JGEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9JGEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSl9ZnVuY3Rpb24gd2IoYSl7YSYmYS5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcyYmdWIoYS5fdGFyZ2V0SW5zdCx2YixhKX1mdW5jdGlvbiB4YihhKXtpZihhJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKXt2YXIgYj1hLl90YXJnZXRJbnN0O2I9Yj90YihiKTpudWxsO3ViKGIsdmIsYSl9fVxuZnVuY3Rpb24geWIoYSxiLGMpe2EmJmMmJmMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmKGI9aWIoYSxjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpKSYmKGMuX2Rpc3BhdGNoTGlzdGVuZXJzPSRhKGMuX2Rpc3BhdGNoTGlzdGVuZXJzLGIpLGMuX2Rpc3BhdGNoSW5zdGFuY2VzPSRhKGMuX2Rpc3BhdGNoSW5zdGFuY2VzLGEpKX1mdW5jdGlvbiB6YihhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJnliKGEuX3RhcmdldEluc3QsbnVsbCxhKX1mdW5jdGlvbiBBYihhKXthYihhLHdiKX1cbmZ1bmN0aW9uIEJiKGEsYixjLGQpe2lmKGMmJmQpYTp7dmFyIGU9Yztmb3IodmFyIGY9ZCxnPTAsaD1lO2g7aD10YihoKSlnKys7aD0wO2Zvcih2YXIgaz1mO2s7az10YihrKSloKys7Zm9yKDswPGctaDspZT10YihlKSxnLS07Zm9yKDswPGgtZzspZj10YihmKSxoLS07Zm9yKDtnLS07KXtpZihlPT09Znx8ZT09PWYuYWx0ZXJuYXRlKWJyZWFrIGE7ZT10YihlKTtmPXRiKGYpfWU9bnVsbH1lbHNlIGU9bnVsbDtmPWU7Zm9yKGU9W107YyYmYyE9PWY7KXtnPWMuYWx0ZXJuYXRlO2lmKG51bGwhPT1nJiZnPT09ZilicmVhaztlLnB1c2goYyk7Yz10YihjKX1mb3IoYz1bXTtkJiZkIT09Zjspe2c9ZC5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2MucHVzaChkKTtkPXRiKGQpfWZvcihkPTA7ZDxlLmxlbmd0aDtkKyspeWIoZVtkXSxcImJ1YmJsZWRcIixhKTtmb3IoYT1jLmxlbmd0aDswPGEtLTspeWIoY1thXSxcImNhcHR1cmVkXCIsYil9XG52YXIgQ2I9T2JqZWN0LmZyZWV6ZSh7YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczpBYixhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDpmdW5jdGlvbihhKXthYihhLHhiKX0sYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOkJiLGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOmZ1bmN0aW9uKGEpe2FiKGEsemIpfX0pLERiPW51bGw7ZnVuY3Rpb24gRWIoKXshRGImJmwuY2FuVXNlRE9NJiYoRGI9XCJ0ZXh0Q29udGVudFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50P1widGV4dENvbnRlbnRcIjpcImlubmVyVGV4dFwiKTtyZXR1cm4gRGJ9dmFyIFM9e19yb290Om51bGwsX3N0YXJ0VGV4dDpudWxsLF9mYWxsYmFja1RleHQ6bnVsbH07XG5mdW5jdGlvbiBGYigpe2lmKFMuX2ZhbGxiYWNrVGV4dClyZXR1cm4gUy5fZmFsbGJhY2tUZXh0O3ZhciBhLGI9Uy5fc3RhcnRUZXh0LGM9Yi5sZW5ndGgsZCxlPUdiKCksZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtTLl9mYWxsYmFja1RleHQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKTtyZXR1cm4gUy5fZmFsbGJhY2tUZXh0fWZ1bmN0aW9uIEdiKCl7cmV0dXJuXCJ2YWx1ZVwiaW4gUy5fcm9vdD9TLl9yb290LnZhbHVlOlMuX3Jvb3RbRWIoKV19XG52YXIgSGI9XCJkaXNwYXRjaENvbmZpZyBfdGFyZ2V0SW5zdCBuYXRpdmVFdmVudCBpc0RlZmF1bHRQcmV2ZW50ZWQgaXNQcm9wYWdhdGlvblN0b3BwZWQgX2Rpc3BhdGNoTGlzdGVuZXJzIF9kaXNwYXRjaEluc3RhbmNlc1wiLnNwbGl0KFwiIFwiKSxJYj17dHlwZTpudWxsLHRhcmdldDpudWxsLGN1cnJlbnRUYXJnZXQ6Qy50aGF0UmV0dXJuc051bGwsZXZlbnRQaGFzZTpudWxsLGJ1YmJsZXM6bnVsbCxjYW5jZWxhYmxlOm51bGwsdGltZVN0YW1wOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX0sZGVmYXVsdFByZXZlbnRlZDpudWxsLGlzVHJ1c3RlZDpudWxsfTtcbmZ1bmN0aW9uIFQoYSxiLGMsZCl7dGhpcy5kaXNwYXRjaENvbmZpZz1hO3RoaXMuX3RhcmdldEluc3Q9Yjt0aGlzLm5hdGl2ZUV2ZW50PWM7YT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtmb3IodmFyIGUgaW4gYSlhLmhhc093blByb3BlcnR5KGUpJiYoKGI9YVtlXSk/dGhpc1tlXT1iKGMpOlwidGFyZ2V0XCI9PT1lP3RoaXMudGFyZ2V0PWQ6dGhpc1tlXT1jW2VdKTt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD0obnVsbCE9Yy5kZWZhdWx0UHJldmVudGVkP2MuZGVmYXVsdFByZXZlbnRlZDohMT09PWMucmV0dXJuVmFsdWUpP0MudGhhdFJldHVybnNUcnVlOkMudGhhdFJldHVybnNGYWxzZTt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUMudGhhdFJldHVybnNGYWxzZTtyZXR1cm4gdGhpc31cbkIoVC5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJihhLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1DLnRoYXRSZXR1cm5zVHJ1ZSl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEuc3RvcFByb3BhZ2F0aW9uP2Euc3RvcFByb3BhZ2F0aW9uKCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5jYW5jZWxCdWJibGUmJihhLmNhbmNlbEJ1YmJsZT0hMCksdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1DLnRoYXRSZXR1cm5zVHJ1ZSl9LHBlcnNpc3Q6ZnVuY3Rpb24oKXt0aGlzLmlzUGVyc2lzdGVudD1DLnRoYXRSZXR1cm5zVHJ1ZX0saXNQZXJzaXN0ZW50OkMudGhhdFJldHVybnNGYWxzZSxcbmRlc3RydWN0b3I6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZSxiO2ZvcihiIGluIGEpdGhpc1tiXT1udWxsO2ZvcihhPTA7YTxIYi5sZW5ndGg7YSsrKXRoaXNbSGJbYV1dPW51bGx9fSk7VC5JbnRlcmZhY2U9SWI7VC5hdWdtZW50Q2xhc3M9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPXRoaXMucHJvdG90eXBlO3ZhciBkPW5ldyBjO0IoZCxhLnByb3RvdHlwZSk7YS5wcm90b3R5cGU9ZDthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EuSW50ZXJmYWNlPUIoe30sdGhpcy5JbnRlcmZhY2UsYik7YS5hdWdtZW50Q2xhc3M9dGhpcy5hdWdtZW50Q2xhc3M7SmIoYSl9O0piKFQpO2Z1bmN0aW9uIEtiKGEsYixjLGQpe2lmKHRoaXMuZXZlbnRQb29sLmxlbmd0aCl7dmFyIGU9dGhpcy5ldmVudFBvb2wucG9wKCk7dGhpcy5jYWxsKGUsYSxiLGMsZCk7cmV0dXJuIGV9cmV0dXJuIG5ldyB0aGlzKGEsYixjLGQpfVxuZnVuY3Rpb24gTGIoYSl7YSBpbnN0YW5jZW9mIHRoaXM/dm9pZCAwOkUoXCIyMjNcIik7YS5kZXN0cnVjdG9yKCk7MTA+dGhpcy5ldmVudFBvb2wubGVuZ3RoJiZ0aGlzLmV2ZW50UG9vbC5wdXNoKGEpfWZ1bmN0aW9uIEpiKGEpe2EuZXZlbnRQb29sPVtdO2EuZ2V0UG9vbGVkPUtiO2EucmVsZWFzZT1MYn1mdW5jdGlvbiBNYihhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoTWIse2RhdGE6bnVsbH0pO2Z1bmN0aW9uIE5iKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhOYix7ZGF0YTpudWxsfSk7dmFyIFBiPVs5LDEzLDI3LDMyXSxWYj1sLmNhblVzZURPTSYmXCJDb21wb3NpdGlvbkV2ZW50XCJpbiB3aW5kb3csV2I9bnVsbDtsLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYoV2I9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgWGI7XG5pZihYYj1sLmNhblVzZURPTSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIVdiKXt2YXIgWWI9d2luZG93Lm9wZXJhO1hiPSEoXCJvYmplY3RcIj09PXR5cGVvZiBZYiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFliLnZlcnNpb24mJjEyPj1wYXJzZUludChZYi52ZXJzaW9uKCksMTApKX1cbnZhciBaYj1YYiwkYj1sLmNhblVzZURPTSYmKCFWYnx8V2ImJjg8V2ImJjExPj1XYiksYWM9U3RyaW5nLmZyb21DaGFyQ29kZSgzMiksYmM9e2JlZm9yZUlucHV0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQmVmb3JlSW5wdXRcIixjYXB0dXJlZDpcIm9uQmVmb3JlSW5wdXRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbXCJ0b3BDb21wb3NpdGlvbkVuZFwiLFwidG9wS2V5UHJlc3NcIixcInRvcFRleHRJbnB1dFwiLFwidG9wUGFzdGVcIl19LGNvbXBvc2l0aW9uRW5kOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25FbmRcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25FbmQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uU3RhcnQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvblN0YXJ0XCIsXG5jYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvblN0YXJ0IHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfSxjb21wb3NpdGlvblVwZGF0ZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCIsY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uVXBkYXRlIHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfX0sY2M9ITE7XG5mdW5jdGlvbiBkYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4tMSE9PVBiLmluZGV4T2YoYi5rZXlDb2RlKTtjYXNlIFwidG9wS2V5RG93blwiOnJldHVybiAyMjkhPT1iLmtleUNvZGU7Y2FzZSBcInRvcEtleVByZXNzXCI6Y2FzZSBcInRvcE1vdXNlRG93blwiOmNhc2UgXCJ0b3BCbHVyXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZWMoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgZmM9ITE7ZnVuY3Rpb24gZ2MoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuIGVjKGIpO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtjYz0hMDtyZXR1cm4gYWM7Y2FzZSBcInRvcFRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09YWMmJmNjP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIGhjKGEsYil7aWYoZmMpcmV0dXJuXCJ0b3BDb21wb3NpdGlvbkVuZFwiPT09YXx8IVZiJiZkYyhhLGIpPyhhPUZiKCksUy5fcm9vdD1udWxsLFMuX3N0YXJ0VGV4dD1udWxsLFMuX2ZhbGxiYWNrVGV4dD1udWxsLGZjPSExLGEpOm51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BQYXN0ZVwiOnJldHVybiBudWxsO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKCEoYi5jdHJsS2V5fHxiLmFsdEtleXx8Yi5tZXRhS2V5KXx8Yi5jdHJsS2V5JiZiLmFsdEtleSl7aWYoYi5jaGFyJiYxPGIuY2hhci5sZW5ndGgpcmV0dXJuIGIuY2hhcjtpZihiLndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIud2hpY2gpfXJldHVybiBudWxsO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOnJldHVybiAkYj9udWxsOmIuZGF0YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbnZhciBpYz17ZXZlbnRUeXBlczpiYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO2lmKFZiKWI6e3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25TdGFydFwiOnZhciBmPWJjLmNvbXBvc2l0aW9uU3RhcnQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpmPWJjLmNvbXBvc2l0aW9uRW5kO2JyZWFrIGI7Y2FzZSBcInRvcENvbXBvc2l0aW9uVXBkYXRlXCI6Zj1iYy5jb21wb3NpdGlvblVwZGF0ZTticmVhayBifWY9dm9pZCAwfWVsc2UgZmM/ZGMoYSxjKSYmKGY9YmMuY29tcG9zaXRpb25FbmQpOlwidG9wS2V5RG93blwiPT09YSYmMjI5PT09Yy5rZXlDb2RlJiYoZj1iYy5jb21wb3NpdGlvblN0YXJ0KTtmPygkYiYmKGZjfHxmIT09YmMuY29tcG9zaXRpb25TdGFydD9mPT09YmMuY29tcG9zaXRpb25FbmQmJmZjJiYoZT1GYigpKTooUy5fcm9vdD1kLFMuX3N0YXJ0VGV4dD1HYigpLGZjPSEwKSksZj1NYi5nZXRQb29sZWQoZixiLGMsZCksZT9mLmRhdGE9XG5lOihlPWVjKGMpLG51bGwhPT1lJiYoZi5kYXRhPWUpKSxBYihmKSxlPWYpOmU9bnVsbDsoYT1aYj9nYyhhLGMpOmhjKGEsYykpPyhiPU5iLmdldFBvb2xlZChiYy5iZWZvcmVJbnB1dCxiLGMsZCksYi5kYXRhPWEsQWIoYikpOmI9bnVsbDtyZXR1cm5bZSxiXX19LGpjPW51bGwsa2M9bnVsbCxsYz1udWxsO2Z1bmN0aW9uIG1jKGEpe2lmKGE9WGEoYSkpe2pjJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgamMucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZT92b2lkIDA6RShcIjE5NFwiKTt2YXIgYj1XYShhLnN0YXRlTm9kZSk7amMucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShhLnN0YXRlTm9kZSxhLnR5cGUsYil9fXZhciBuYz17aW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudDpmdW5jdGlvbihhKXtqYz1hfX07ZnVuY3Rpb24gb2MoYSl7a2M/bGM/bGMucHVzaChhKTpsYz1bYV06a2M9YX1cbmZ1bmN0aW9uIHBjKCl7aWYoa2Mpe3ZhciBhPWtjLGI9bGM7bGM9a2M9bnVsbDttYyhhKTtpZihiKWZvcihhPTA7YTxiLmxlbmd0aDthKyspbWMoYlthXSl9fXZhciBxYz1PYmplY3QuZnJlZXplKHtpbmplY3Rpb246bmMsZW5xdWV1ZVN0YXRlUmVzdG9yZTpvYyxyZXN0b3JlU3RhdGVJZk5lZWRlZDpwY30pO2Z1bmN0aW9uIHJjKGEsYil7cmV0dXJuIGEoYil9dmFyIHNjPSExO2Z1bmN0aW9uIHRjKGEsYil7aWYoc2MpcmV0dXJuIHJjKGEsYik7c2M9ITA7dHJ5e3JldHVybiByYyhhLGIpfWZpbmFsbHl7c2M9ITEscGMoKX19dmFyIHVjPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O1xuZnVuY3Rpb24gdmMoYSl7dmFyIGI9YSYmYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWI/ISF1Y1thLnR5cGVdOlwidGV4dGFyZWFcIj09PWI/ITA6ITF9ZnVuY3Rpb24gd2MoYSl7YT1hLnRhcmdldHx8YS5zcmNFbGVtZW50fHx3aW5kb3c7YS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCYmKGE9YS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCk7cmV0dXJuIDM9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphfXZhciB4YztsLmNhblVzZURPTSYmKHhjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uJiZkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlJiYhMCE9PWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJcIixcIlwiKSk7XG5mdW5jdGlvbiB5YyhhLGIpe2lmKCFsLmNhblVzZURPTXx8YiYmIShcImFkZEV2ZW50TGlzdGVuZXJcImluIGRvY3VtZW50KSlyZXR1cm4hMTtiPVwib25cIithO3ZhciBjPWIgaW4gZG9jdW1lbnQ7Y3x8KGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxjLnNldEF0dHJpYnV0ZShiLFwicmV0dXJuO1wiKSxjPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjW2JdKTshYyYmeGMmJlwid2hlZWxcIj09PWEmJihjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJFdmVudHMud2hlZWxcIixcIjMuMFwiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gemMoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIEFjKGEpe3ZhciBiPXpjKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLmdldCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuc2V0KXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZSxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZ2V0LmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtjLnNldC5jYWxsKHRoaXMsYSl9fSkse2dldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGR9LHNldFZhbHVlOmZ1bmN0aW9uKGEpe2Q9XCJcIithfSxzdG9wVHJhY2tpbmc6ZnVuY3Rpb24oKXthLl92YWx1ZVRyYWNrZXI9bnVsbDtkZWxldGUgYVtiXX19fVxuZnVuY3Rpb24gQmMoYSl7YS5fdmFsdWVUcmFja2VyfHwoYS5fdmFsdWVUcmFja2VyPUFjKGEpKX1mdW5jdGlvbiBDYyhhKXtpZighYSlyZXR1cm4hMTt2YXIgYj1hLl92YWx1ZVRyYWNrZXI7aWYoIWIpcmV0dXJuITA7dmFyIGM9Yi5nZXRWYWx1ZSgpO3ZhciBkPVwiXCI7YSYmKGQ9emMoYSk/YS5jaGVja2VkP1widHJ1ZVwiOlwiZmFsc2VcIjphLnZhbHVlKTthPWQ7cmV0dXJuIGEhPT1jPyhiLnNldFZhbHVlKGEpLCEwKTohMX12YXIgRGM9e2NoYW5nZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNoYW5nZVwiLGNhcHR1cmVkOlwib25DaGFuZ2VDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ2hhbmdlIHRvcENsaWNrIHRvcEZvY3VzIHRvcElucHV0IHRvcEtleURvd24gdG9wS2V5VXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX07XG5mdW5jdGlvbiBFYyhhLGIsYyl7YT1ULmdldFBvb2xlZChEYy5jaGFuZ2UsYSxiLGMpO2EudHlwZT1cImNoYW5nZVwiO29jKGMpO0FiKGEpO3JldHVybiBhfXZhciBGYz1udWxsLEdjPW51bGw7ZnVuY3Rpb24gSGMoYSl7a2IoYSk7bGIoITEpfWZ1bmN0aW9uIEljKGEpe3ZhciBiPXFiKGEpO2lmKENjKGIpKXJldHVybiBhfWZ1bmN0aW9uIEpjKGEsYil7aWYoXCJ0b3BDaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIEtjPSExO2wuY2FuVXNlRE9NJiYoS2M9eWMoXCJpbnB1dFwiKSYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fDk8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSk7ZnVuY3Rpb24gTGMoKXtGYyYmKEZjLmRldGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLE1jKSxHYz1GYz1udWxsKX1mdW5jdGlvbiBNYyhhKXtcInZhbHVlXCI9PT1hLnByb3BlcnR5TmFtZSYmSWMoR2MpJiYoYT1FYyhHYyxhLHdjKGEpKSx0YyhIYyxhKSl9XG5mdW5jdGlvbiBOYyhhLGIsYyl7XCJ0b3BGb2N1c1wiPT09YT8oTGMoKSxGYz1iLEdjPWMsRmMuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsTWMpKTpcInRvcEJsdXJcIj09PWEmJkxjKCl9ZnVuY3Rpb24gT2MoYSl7aWYoXCJ0b3BTZWxlY3Rpb25DaGFuZ2VcIj09PWF8fFwidG9wS2V5VXBcIj09PWF8fFwidG9wS2V5RG93blwiPT09YSlyZXR1cm4gSWMoR2MpfWZ1bmN0aW9uIFBjKGEsYil7aWYoXCJ0b3BDbGlja1wiPT09YSlyZXR1cm4gSWMoYil9ZnVuY3Rpb24gJGMoYSxiKXtpZihcInRvcElucHV0XCI9PT1hfHxcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gSWMoYil9XG52YXIgYWQ9e2V2ZW50VHlwZXM6RGMsX2lzSW5wdXRFdmVudFN1cHBvcnRlZDpLYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWI/cWIoYik6d2luZG93LGY9ZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwic2VsZWN0XCI9PT1mfHxcImlucHV0XCI9PT1mJiZcImZpbGVcIj09PWUudHlwZSl2YXIgZz1KYztlbHNlIGlmKHZjKGUpKWlmKEtjKWc9JGM7ZWxzZXtnPU9jO3ZhciBoPU5jfWVsc2UgZj1lLm5vZGVOYW1lLCFmfHxcImlucHV0XCIhPT1mLnRvTG93ZXJDYXNlKCl8fFwiY2hlY2tib3hcIiE9PWUudHlwZSYmXCJyYWRpb1wiIT09ZS50eXBlfHwoZz1QYyk7aWYoZyYmKGc9ZyhhLGIpKSlyZXR1cm4gRWMoZyxjLGQpO2gmJmgoYSxlLGIpO1widG9wQmx1clwiPT09YSYmbnVsbCE9YiYmKGE9Yi5fd3JhcHBlclN0YXRlfHxlLl93cmFwcGVyU3RhdGUpJiZhLmNvbnRyb2xsZWQmJlwibnVtYmVyXCI9PT1lLnR5cGUmJihhPVwiXCIrZS52YWx1ZSxlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIT09XG5hJiZlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsYSkpfX07ZnVuY3Rpb24gYmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKGJkLHt2aWV3Om51bGwsZGV0YWlsOm51bGx9KTt2YXIgY2Q9e0FsdDpcImFsdEtleVwiLENvbnRyb2w6XCJjdHJsS2V5XCIsTWV0YTpcIm1ldGFLZXlcIixTaGlmdDpcInNoaWZ0S2V5XCJ9O2Z1bmN0aW9uIGRkKGEpe3ZhciBiPXRoaXMubmF0aXZlRXZlbnQ7cmV0dXJuIGIuZ2V0TW9kaWZpZXJTdGF0ZT9iLmdldE1vZGlmaWVyU3RhdGUoYSk6KGE9Y2RbYV0pPyEhYlthXTohMX1mdW5jdGlvbiBlZCgpe3JldHVybiBkZH1mdW5jdGlvbiBmZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9XG5iZC5hdWdtZW50Q2xhc3MoZmQse3NjcmVlblg6bnVsbCxzY3JlZW5ZOm51bGwsY2xpZW50WDpudWxsLGNsaWVudFk6bnVsbCxwYWdlWDpudWxsLHBhZ2VZOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWQsYnV0dG9uOm51bGwsYnV0dG9uczpudWxsLHJlbGF0ZWRUYXJnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVsYXRlZFRhcmdldHx8KGEuZnJvbUVsZW1lbnQ9PT1hLnNyY0VsZW1lbnQ/YS50b0VsZW1lbnQ6YS5mcm9tRWxlbWVudCl9fSk7XG52YXIgZ2Q9e21vdXNlRW50ZXI6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvbk1vdXNlRW50ZXJcIixkZXBlbmRlbmNpZXM6W1widG9wTW91c2VPdXRcIixcInRvcE1vdXNlT3ZlclwiXX0sbW91c2VMZWF2ZTp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VMZWF2ZVwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfX0saGQ9e2V2ZW50VHlwZXM6Z2QsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXtpZihcInRvcE1vdXNlT3ZlclwiPT09YSYmKGMucmVsYXRlZFRhcmdldHx8Yy5mcm9tRWxlbWVudCl8fFwidG9wTW91c2VPdXRcIiE9PWEmJlwidG9wTW91c2VPdmVyXCIhPT1hKXJldHVybiBudWxsO3ZhciBlPWQud2luZG93PT09ZD9kOihlPWQub3duZXJEb2N1bWVudCk/ZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3c6d2luZG93O1widG9wTW91c2VPdXRcIj09PWE/KGE9YixiPShiPWMucmVsYXRlZFRhcmdldHx8Yy50b0VsZW1lbnQpP3BiKGIpOm51bGwpOmE9bnVsbDtpZihhPT09XG5iKXJldHVybiBudWxsO3ZhciBmPW51bGw9PWE/ZTpxYihhKTtlPW51bGw9PWI/ZTpxYihiKTt2YXIgZz1mZC5nZXRQb29sZWQoZ2QubW91c2VMZWF2ZSxhLGMsZCk7Zy50eXBlPVwibW91c2VsZWF2ZVwiO2cudGFyZ2V0PWY7Zy5yZWxhdGVkVGFyZ2V0PWU7Yz1mZC5nZXRQb29sZWQoZ2QubW91c2VFbnRlcixiLGMsZCk7Yy50eXBlPVwibW91c2VlbnRlclwiO2MudGFyZ2V0PWU7Yy5yZWxhdGVkVGFyZ2V0PWY7QmIoZyxjLGEsYik7cmV0dXJuW2csY119fSxpZD1hYS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcjtmdW5jdGlvbiBqZChhKXthPWEudHlwZTtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGE/YTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hLmRpc3BsYXlOYW1lfHxhLm5hbWU6bnVsbH1cbmZ1bmN0aW9uIGtkKGEpe3ZhciBiPWE7aWYoYS5hbHRlcm5hdGUpZm9yKDtiW1wicmV0dXJuXCJdOyliPWJbXCJyZXR1cm5cIl07ZWxzZXtpZigwIT09KGIuZWZmZWN0VGFnJjIpKXJldHVybiAxO2Zvcig7YltcInJldHVyblwiXTspaWYoYj1iW1wicmV0dXJuXCJdLDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDF9cmV0dXJuIDM9PT1iLnRhZz8yOjN9ZnVuY3Rpb24gbGQoYSl7cmV0dXJuKGE9YS5fcmVhY3RJbnRlcm5hbEZpYmVyKT8yPT09a2QoYSk6ITF9ZnVuY3Rpb24gbWQoYSl7MiE9PWtkKGEpP0UoXCIxODhcIik6dm9pZCAwfVxuZnVuY3Rpb24gbmQoYSl7dmFyIGI9YS5hbHRlcm5hdGU7aWYoIWIpcmV0dXJuIGI9a2QoYSksMz09PWI/RShcIjE4OFwiKTp2b2lkIDAsMT09PWI/bnVsbDphO2Zvcih2YXIgYz1hLGQ9Yjs7KXt2YXIgZT1jW1wicmV0dXJuXCJdLGY9ZT9lLmFsdGVybmF0ZTpudWxsO2lmKCFlfHwhZilicmVhaztpZihlLmNoaWxkPT09Zi5jaGlsZCl7Zm9yKHZhciBnPWUuY2hpbGQ7Zzspe2lmKGc9PT1jKXJldHVybiBtZChlKSxhO2lmKGc9PT1kKXJldHVybiBtZChlKSxiO2c9Zy5zaWJsaW5nfUUoXCIxODhcIil9aWYoY1tcInJldHVyblwiXSE9PWRbXCJyZXR1cm5cIl0pYz1lLGQ9ZjtlbHNle2c9ITE7Zm9yKHZhciBoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1mO2Q9ZTticmVha31pZihoPT09ZCl7Zz0hMDtkPWY7Yz1lO2JyZWFrfWg9aC5zaWJsaW5nfWc/XG52b2lkIDA6RShcIjE4OVwiKX19Yy5hbHRlcm5hdGUhPT1kP0UoXCIxOTBcIik6dm9pZCAwfTMhPT1jLnRhZz9FKFwiMTg4XCIpOnZvaWQgMDtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIG9kKGEpe2E9bmQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBwZChhKXthPW5kKGEpO2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYj1hOzspe2lmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKXJldHVybiBiO2lmKGIuY2hpbGQmJjQhPT1iLnRhZyliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9dmFyIHFkPVtdO1xuZnVuY3Rpb24gcmQoYSl7dmFyIGI9YS50YXJnZXRJbnN0O2Rve2lmKCFiKXthLmFuY2VzdG9ycy5wdXNoKGIpO2JyZWFrfXZhciBjO2ZvcihjPWI7Y1tcInJldHVyblwiXTspYz1jW1wicmV0dXJuXCJdO2M9MyE9PWMudGFnP251bGw6Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZighYylicmVhazthLmFuY2VzdG9ycy5wdXNoKGIpO2I9cGIoYyl9d2hpbGUoYik7Zm9yKGM9MDtjPGEuYW5jZXN0b3JzLmxlbmd0aDtjKyspYj1hLmFuY2VzdG9yc1tjXSxzZChhLnRvcExldmVsVHlwZSxiLGEubmF0aXZlRXZlbnQsd2MoYS5uYXRpdmVFdmVudCkpfXZhciB0ZD0hMCxzZD12b2lkIDA7ZnVuY3Rpb24gdWQoYSl7dGQ9ISFhfWZ1bmN0aW9uIFUoYSxiLGMpe3JldHVybiBjP2JhLmxpc3RlbihjLGIsdmQuYmluZChudWxsLGEpKTpudWxsfWZ1bmN0aW9uIHdkKGEsYixjKXtyZXR1cm4gYz9iYS5jYXB0dXJlKGMsYix2ZC5iaW5kKG51bGwsYSkpOm51bGx9XG5mdW5jdGlvbiB2ZChhLGIpe2lmKHRkKXt2YXIgYz13YyhiKTtjPXBiKGMpO251bGw9PT1jfHxcIm51bWJlclwiIT09dHlwZW9mIGMudGFnfHwyPT09a2QoYyl8fChjPW51bGwpO2lmKHFkLmxlbmd0aCl7dmFyIGQ9cWQucG9wKCk7ZC50b3BMZXZlbFR5cGU9YTtkLm5hdGl2ZUV2ZW50PWI7ZC50YXJnZXRJbnN0PWM7YT1kfWVsc2UgYT17dG9wTGV2ZWxUeXBlOmEsbmF0aXZlRXZlbnQ6Yix0YXJnZXRJbnN0OmMsYW5jZXN0b3JzOltdfTt0cnl7dGMocmQsYSl9ZmluYWxseXthLnRvcExldmVsVHlwZT1udWxsLGEubmF0aXZlRXZlbnQ9bnVsbCxhLnRhcmdldEluc3Q9bnVsbCxhLmFuY2VzdG9ycy5sZW5ndGg9MCwxMD5xZC5sZW5ndGgmJnFkLnB1c2goYSl9fX1cbnZhciB4ZD1PYmplY3QuZnJlZXplKHtnZXQgX2VuYWJsZWQoKXtyZXR1cm4gdGR9LGdldCBfaGFuZGxlVG9wTGV2ZWwoKXtyZXR1cm4gc2R9LHNldEhhbmRsZVRvcExldmVsOmZ1bmN0aW9uKGEpe3NkPWF9LHNldEVuYWJsZWQ6dWQsaXNFbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRkfSx0cmFwQnViYmxlZEV2ZW50OlUsdHJhcENhcHR1cmVkRXZlbnQ6d2QsZGlzcGF0Y2hFdmVudDp2ZH0pO2Z1bmN0aW9uIHlkKGEsYil7dmFyIGM9e307Y1thLnRvTG93ZXJDYXNlKCldPWIudG9Mb3dlckNhc2UoKTtjW1wiV2Via2l0XCIrYV09XCJ3ZWJraXRcIitiO2NbXCJNb3pcIithXT1cIm1velwiK2I7Y1tcIm1zXCIrYV09XCJNU1wiK2I7Y1tcIk9cIithXT1cIm9cIitiLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGN9XG52YXIgemQ9e2FuaW1hdGlvbmVuZDp5ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjp5ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOnlkKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sQWQ9e30sQmQ9e307bC5jYW5Vc2VET00mJihCZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFwiQW5pbWF0aW9uRXZlbnRcImluIHdpbmRvd3x8KGRlbGV0ZSB6ZC5hbmltYXRpb25lbmQuYW5pbWF0aW9uLGRlbGV0ZSB6ZC5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLGRlbGV0ZSB6ZC5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFwiVHJhbnNpdGlvbkV2ZW50XCJpbiB3aW5kb3d8fGRlbGV0ZSB6ZC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO1xuZnVuY3Rpb24gQ2QoYSl7aWYoQWRbYV0pcmV0dXJuIEFkW2FdO2lmKCF6ZFthXSlyZXR1cm4gYTt2YXIgYj16ZFthXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiBCZClyZXR1cm4gQWRbYV09YltjXTtyZXR1cm5cIlwifVxudmFyIERkPXt0b3BBYm9ydDpcImFib3J0XCIsdG9wQW5pbWF0aW9uRW5kOkNkKFwiYW5pbWF0aW9uZW5kXCIpfHxcImFuaW1hdGlvbmVuZFwiLHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjpDZChcImFuaW1hdGlvbml0ZXJhdGlvblwiKXx8XCJhbmltYXRpb25pdGVyYXRpb25cIix0b3BBbmltYXRpb25TdGFydDpDZChcImFuaW1hdGlvbnN0YXJ0XCIpfHxcImFuaW1hdGlvbnN0YXJ0XCIsdG9wQmx1cjpcImJsdXJcIix0b3BDYW5jZWw6XCJjYW5jZWxcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BDaGFuZ2U6XCJjaGFuZ2VcIix0b3BDbGljazpcImNsaWNrXCIsdG9wQ2xvc2U6XCJjbG9zZVwiLHRvcENvbXBvc2l0aW9uRW5kOlwiY29tcG9zaXRpb25lbmRcIix0b3BDb21wb3NpdGlvblN0YXJ0OlwiY29tcG9zaXRpb25zdGFydFwiLHRvcENvbXBvc2l0aW9uVXBkYXRlOlwiY29tcG9zaXRpb251cGRhdGVcIix0b3BDb250ZXh0TWVudTpcImNvbnRleHRtZW51XCIsdG9wQ29weTpcImNvcHlcIixcbnRvcEN1dDpcImN1dFwiLHRvcERvdWJsZUNsaWNrOlwiZGJsY2xpY2tcIix0b3BEcmFnOlwiZHJhZ1wiLHRvcERyYWdFbmQ6XCJkcmFnZW5kXCIsdG9wRHJhZ0VudGVyOlwiZHJhZ2VudGVyXCIsdG9wRHJhZ0V4aXQ6XCJkcmFnZXhpdFwiLHRvcERyYWdMZWF2ZTpcImRyYWdsZWF2ZVwiLHRvcERyYWdPdmVyOlwiZHJhZ292ZXJcIix0b3BEcmFnU3RhcnQ6XCJkcmFnc3RhcnRcIix0b3BEcm9wOlwiZHJvcFwiLHRvcER1cmF0aW9uQ2hhbmdlOlwiZHVyYXRpb25jaGFuZ2VcIix0b3BFbXB0aWVkOlwiZW1wdGllZFwiLHRvcEVuY3J5cHRlZDpcImVuY3J5cHRlZFwiLHRvcEVuZGVkOlwiZW5kZWRcIix0b3BFcnJvcjpcImVycm9yXCIsdG9wRm9jdXM6XCJmb2N1c1wiLHRvcElucHV0OlwiaW5wdXRcIix0b3BLZXlEb3duOlwia2V5ZG93blwiLHRvcEtleVByZXNzOlwia2V5cHJlc3NcIix0b3BLZXlVcDpcImtleXVwXCIsdG9wTG9hZGVkRGF0YTpcImxvYWRlZGRhdGFcIix0b3BMb2FkOlwibG9hZFwiLHRvcExvYWRlZE1ldGFkYXRhOlwibG9hZGVkbWV0YWRhdGFcIix0b3BMb2FkU3RhcnQ6XCJsb2Fkc3RhcnRcIixcbnRvcE1vdXNlRG93bjpcIm1vdXNlZG93blwiLHRvcE1vdXNlTW92ZTpcIm1vdXNlbW92ZVwiLHRvcE1vdXNlT3V0OlwibW91c2VvdXRcIix0b3BNb3VzZU92ZXI6XCJtb3VzZW92ZXJcIix0b3BNb3VzZVVwOlwibW91c2V1cFwiLHRvcFBhc3RlOlwicGFzdGVcIix0b3BQYXVzZTpcInBhdXNlXCIsdG9wUGxheTpcInBsYXlcIix0b3BQbGF5aW5nOlwicGxheWluZ1wiLHRvcFByb2dyZXNzOlwicHJvZ3Jlc3NcIix0b3BSYXRlQ2hhbmdlOlwicmF0ZWNoYW5nZVwiLHRvcFNjcm9sbDpcInNjcm9sbFwiLHRvcFNlZWtlZDpcInNlZWtlZFwiLHRvcFNlZWtpbmc6XCJzZWVraW5nXCIsdG9wU2VsZWN0aW9uQ2hhbmdlOlwic2VsZWN0aW9uY2hhbmdlXCIsdG9wU3RhbGxlZDpcInN0YWxsZWRcIix0b3BTdXNwZW5kOlwic3VzcGVuZFwiLHRvcFRleHRJbnB1dDpcInRleHRJbnB1dFwiLHRvcFRpbWVVcGRhdGU6XCJ0aW1ldXBkYXRlXCIsdG9wVG9nZ2xlOlwidG9nZ2xlXCIsdG9wVG91Y2hDYW5jZWw6XCJ0b3VjaGNhbmNlbFwiLHRvcFRvdWNoRW5kOlwidG91Y2hlbmRcIix0b3BUb3VjaE1vdmU6XCJ0b3VjaG1vdmVcIixcbnRvcFRvdWNoU3RhcnQ6XCJ0b3VjaHN0YXJ0XCIsdG9wVHJhbnNpdGlvbkVuZDpDZChcInRyYW5zaXRpb25lbmRcIil8fFwidHJhbnNpdGlvbmVuZFwiLHRvcFZvbHVtZUNoYW5nZTpcInZvbHVtZWNoYW5nZVwiLHRvcFdhaXRpbmc6XCJ3YWl0aW5nXCIsdG9wV2hlZWw6XCJ3aGVlbFwifSxFZD17fSxGZD0wLEdkPVwiX3JlYWN0TGlzdGVuZXJzSURcIisoXCJcIitNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtmdW5jdGlvbiBIZChhKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxHZCl8fChhW0dkXT1GZCsrLEVkW2FbR2RdXT17fSk7cmV0dXJuIEVkW2FbR2RdXX1mdW5jdGlvbiBJZChhKXtmb3IoO2EmJmEuZmlyc3RDaGlsZDspYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9XG5mdW5jdGlvbiBKZChhLGIpe3ZhciBjPUlkKGEpO2E9MDtmb3IodmFyIGQ7Yzspe2lmKDM9PT1jLm5vZGVUeXBlKXtkPWErYy50ZXh0Q29udGVudC5sZW5ndGg7aWYoYTw9YiYmZD49YilyZXR1cm57bm9kZTpjLG9mZnNldDpiLWF9O2E9ZH1hOntmb3IoO2M7KXtpZihjLm5leHRTaWJsaW5nKXtjPWMubmV4dFNpYmxpbmc7YnJlYWsgYX1jPWMucGFyZW50Tm9kZX1jPXZvaWQgMH1jPUlkKGMpfX1mdW5jdGlvbiBLZChhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiZcInRleHRcIj09PWEudHlwZXx8XCJ0ZXh0YXJlYVwiPT09Ynx8XCJ0cnVlXCI9PT1hLmNvbnRlbnRFZGl0YWJsZSl9XG52YXIgTGQ9bC5jYW5Vc2VET00mJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmMTE+PWRvY3VtZW50LmRvY3VtZW50TW9kZSxNZD17c2VsZWN0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uU2VsZWN0XCIsY2FwdHVyZWQ6XCJvblNlbGVjdENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb250ZXh0TWVudSB0b3BGb2N1cyB0b3BLZXlEb3duIHRvcEtleVVwIHRvcE1vdXNlRG93biB0b3BNb3VzZVVwIHRvcFNlbGVjdGlvbkNoYW5nZVwiLnNwbGl0KFwiIFwiKX19LE5kPW51bGwsT2Q9bnVsbCxQZD1udWxsLFFkPSExO1xuZnVuY3Rpb24gUmQoYSxiKXtpZihRZHx8bnVsbD09TmR8fE5kIT09ZGEoKSlyZXR1cm4gbnVsbDt2YXIgYz1OZDtcInNlbGVjdGlvblN0YXJ0XCJpbiBjJiZLZChjKT9jPXtzdGFydDpjLnNlbGVjdGlvblN0YXJ0LGVuZDpjLnNlbGVjdGlvbkVuZH06d2luZG93LmdldFNlbGVjdGlvbj8oYz13aW5kb3cuZ2V0U2VsZWN0aW9uKCksYz17YW5jaG9yTm9kZTpjLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OmMuYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpjLmZvY3VzTm9kZSxmb2N1c09mZnNldDpjLmZvY3VzT2Zmc2V0fSk6Yz12b2lkIDA7cmV0dXJuIFBkJiZlYShQZCxjKT9udWxsOihQZD1jLGE9VC5nZXRQb29sZWQoTWQuc2VsZWN0LE9kLGEsYiksYS50eXBlPVwic2VsZWN0XCIsYS50YXJnZXQ9TmQsQWIoYSksYSl9XG52YXIgU2Q9e2V2ZW50VHlwZXM6TWQsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kLndpbmRvdz09PWQ/ZC5kb2N1bWVudDo5PT09ZC5ub2RlVHlwZT9kOmQub3duZXJEb2N1bWVudCxmO2lmKCEoZj0hZSkpe2E6e2U9SGQoZSk7Zj1TYS5vblNlbGVjdDtmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZltnXTtpZighZS5oYXNPd25Qcm9wZXJ0eShoKXx8IWVbaF0pe2U9ITE7YnJlYWsgYX19ZT0hMH1mPSFlfWlmKGYpcmV0dXJuIG51bGw7ZT1iP3FiKGIpOndpbmRvdztzd2l0Y2goYSl7Y2FzZSBcInRvcEZvY3VzXCI6aWYodmMoZSl8fFwidHJ1ZVwiPT09ZS5jb250ZW50RWRpdGFibGUpTmQ9ZSxPZD1iLFBkPW51bGw7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpQZD1PZD1OZD1udWxsO2JyZWFrO2Nhc2UgXCJ0b3BNb3VzZURvd25cIjpRZD0hMDticmVhaztjYXNlIFwidG9wQ29udGV4dE1lbnVcIjpjYXNlIFwidG9wTW91c2VVcFwiOnJldHVybiBRZD0hMSxSZChjLGQpO2Nhc2UgXCJ0b3BTZWxlY3Rpb25DaGFuZ2VcIjppZihMZClicmVhaztcbmNhc2UgXCJ0b3BLZXlEb3duXCI6Y2FzZSBcInRvcEtleVVwXCI6cmV0dXJuIFJkKGMsZCl9cmV0dXJuIG51bGx9fTtmdW5jdGlvbiBUZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoVGQse2FuaW1hdGlvbk5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pO2Z1bmN0aW9uIFVkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhVZCx7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihhKXtyZXR1cm5cImNsaXBib2FyZERhdGFcImluIGE/YS5jbGlwYm9hcmREYXRhOndpbmRvdy5jbGlwYm9hcmREYXRhfX0pO2Z1bmN0aW9uIFZkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1iZC5hdWdtZW50Q2xhc3MoVmQse3JlbGF0ZWRUYXJnZXQ6bnVsbH0pO1xuZnVuY3Rpb24gV2QoYSl7dmFyIGI9YS5rZXlDb2RlO1wiY2hhckNvZGVcImluIGE/KGE9YS5jaGFyQ29kZSwwPT09YSYmMTM9PT1iJiYoYT0xMykpOmE9YjtyZXR1cm4gMzI8PWF8fDEzPT09YT9hOjB9XG52YXIgWGQ9e0VzYzpcIkVzY2FwZVwiLFNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LFlkPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLFxuMTE2OlwiRjVcIiwxMTc6XCJGNlwiLDExODpcIkY3XCIsMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifTtmdW5jdGlvbiBaZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9XG5iZC5hdWdtZW50Q2xhc3MoWmQse2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9WGRbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9V2QoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP1lkW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sbG9jYXRpb246bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwscmVwZWF0Om51bGwsbG9jYWxlOm51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZCxjaGFyQ29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/V2QoYSk6MH0sa2V5Q29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfSx3aGljaDpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1cbmEudHlwZT9XZChhKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfX0pO2Z1bmN0aW9uICRkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1mZC5hdWdtZW50Q2xhc3MoJGQse2RhdGFUcmFuc2ZlcjpudWxsfSk7ZnVuY3Rpb24gYWUoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWJkLmF1Z21lbnRDbGFzcyhhZSx7dG91Y2hlczpudWxsLHRhcmdldFRvdWNoZXM6bnVsbCxjaGFuZ2VkVG91Y2hlczpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkfSk7ZnVuY3Rpb24gYmUoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKGJlLHtwcm9wZXJ0eU5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pO1xuZnVuY3Rpb24gY2UoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWZkLmF1Z21lbnRDbGFzcyhjZSx7ZGVsdGFYOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFYXCJpbiBhP2EuZGVsdGFYOlwid2hlZWxEZWx0YVhcImluIGE/LWEud2hlZWxEZWx0YVg6MH0sZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOm51bGwsZGVsdGFNb2RlOm51bGx9KTt2YXIgZGU9e30sZWU9e307XG5cImFib3J0IGFuaW1hdGlvbkVuZCBhbmltYXRpb25JdGVyYXRpb24gYW5pbWF0aW9uU3RhcnQgYmx1ciBjYW5jZWwgY2FuUGxheSBjYW5QbGF5VGhyb3VnaCBjbGljayBjbG9zZSBjb250ZXh0TWVudSBjb3B5IGN1dCBkb3VibGVDbGljayBkcmFnIGRyYWdFbmQgZHJhZ0VudGVyIGRyYWdFeGl0IGRyYWdMZWF2ZSBkcmFnT3ZlciBkcmFnU3RhcnQgZHJvcCBkdXJhdGlvbkNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBmb2N1cyBpbnB1dCBpbnZhbGlkIGtleURvd24ga2V5UHJlc3Mga2V5VXAgbG9hZCBsb2FkZWREYXRhIGxvYWRlZE1ldGFkYXRhIGxvYWRTdGFydCBtb3VzZURvd24gbW91c2VNb3ZlIG1vdXNlT3V0IG1vdXNlT3ZlciBtb3VzZVVwIHBhc3RlIHBhdXNlIHBsYXkgcGxheWluZyBwcm9ncmVzcyByYXRlQ2hhbmdlIHJlc2V0IHNjcm9sbCBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1Ym1pdCBzdXNwZW5kIHRpbWVVcGRhdGUgdG9nZ2xlIHRvdWNoQ2FuY2VsIHRvdWNoRW5kIHRvdWNoTW92ZSB0b3VjaFN0YXJ0IHRyYW5zaXRpb25FbmQgdm9sdW1lQ2hhbmdlIHdhaXRpbmcgd2hlZWxcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hWzBdLnRvVXBwZXJDYXNlKCkrXG5hLnNsaWNlKDEpLGM9XCJvblwiK2I7Yj1cInRvcFwiK2I7Yz17cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6YyxjYXB0dXJlZDpjK1wiQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6W2JdfTtkZVthXT1jO2VlW2JdPWN9KTtcbnZhciBmZT17ZXZlbnRUeXBlczpkZSxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWVlW2FdO2lmKCFlKXJldHVybiBudWxsO3N3aXRjaChhKXtjYXNlIFwidG9wS2V5UHJlc3NcIjppZigwPT09V2QoYykpcmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjphPVpkO2JyZWFrO2Nhc2UgXCJ0b3BCbHVyXCI6Y2FzZSBcInRvcEZvY3VzXCI6YT1WZDticmVhaztjYXNlIFwidG9wQ2xpY2tcIjppZigyPT09Yy5idXR0b24pcmV0dXJuIG51bGw7Y2FzZSBcInRvcERvdWJsZUNsaWNrXCI6Y2FzZSBcInRvcE1vdXNlRG93blwiOmNhc2UgXCJ0b3BNb3VzZU1vdmVcIjpjYXNlIFwidG9wTW91c2VVcFwiOmNhc2UgXCJ0b3BNb3VzZU91dFwiOmNhc2UgXCJ0b3BNb3VzZU92ZXJcIjpjYXNlIFwidG9wQ29udGV4dE1lbnVcIjphPWZkO2JyZWFrO2Nhc2UgXCJ0b3BEcmFnXCI6Y2FzZSBcInRvcERyYWdFbmRcIjpjYXNlIFwidG9wRHJhZ0VudGVyXCI6Y2FzZSBcInRvcERyYWdFeGl0XCI6Y2FzZSBcInRvcERyYWdMZWF2ZVwiOmNhc2UgXCJ0b3BEcmFnT3ZlclwiOmNhc2UgXCJ0b3BEcmFnU3RhcnRcIjpjYXNlIFwidG9wRHJvcFwiOmE9XG4kZDticmVhaztjYXNlIFwidG9wVG91Y2hDYW5jZWxcIjpjYXNlIFwidG9wVG91Y2hFbmRcIjpjYXNlIFwidG9wVG91Y2hNb3ZlXCI6Y2FzZSBcInRvcFRvdWNoU3RhcnRcIjphPWFlO2JyZWFrO2Nhc2UgXCJ0b3BBbmltYXRpb25FbmRcIjpjYXNlIFwidG9wQW5pbWF0aW9uSXRlcmF0aW9uXCI6Y2FzZSBcInRvcEFuaW1hdGlvblN0YXJ0XCI6YT1UZDticmVhaztjYXNlIFwidG9wVHJhbnNpdGlvbkVuZFwiOmE9YmU7YnJlYWs7Y2FzZSBcInRvcFNjcm9sbFwiOmE9YmQ7YnJlYWs7Y2FzZSBcInRvcFdoZWVsXCI6YT1jZTticmVhaztjYXNlIFwidG9wQ29weVwiOmNhc2UgXCJ0b3BDdXRcIjpjYXNlIFwidG9wUGFzdGVcIjphPVVkO2JyZWFrO2RlZmF1bHQ6YT1UfWI9YS5nZXRQb29sZWQoZSxiLGMsZCk7QWIoYik7cmV0dXJuIGJ9fTtzZD1mdW5jdGlvbihhLGIsYyxkKXthPWpiKGEsYixjLGQpO2tiKGEpO2xiKCExKX07aGIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihcIlJlc3BvbmRlckV2ZW50UGx1Z2luIFNpbXBsZUV2ZW50UGx1Z2luIFRhcEV2ZW50UGx1Z2luIEVudGVyTGVhdmVFdmVudFBsdWdpbiBDaGFuZ2VFdmVudFBsdWdpbiBTZWxlY3RFdmVudFBsdWdpbiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXCIuc3BsaXQoXCIgXCIpKTtcbldhPXNiLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7WGE9c2IuZ2V0SW5zdGFuY2VGcm9tTm9kZTtZYT1zYi5nZXROb2RlRnJvbUluc3RhbmNlO2hiLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7U2ltcGxlRXZlbnRQbHVnaW46ZmUsRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOmhkLENoYW5nZUV2ZW50UGx1Z2luOmFkLFNlbGVjdEV2ZW50UGx1Z2luOlNkLEJlZm9yZUlucHV0RXZlbnRQbHVnaW46aWN9KTt2YXIgZ2U9W10saGU9LTE7ZnVuY3Rpb24gVihhKXswPmhlfHwoYS5jdXJyZW50PWdlW2hlXSxnZVtoZV09bnVsbCxoZS0tKX1mdW5jdGlvbiBXKGEsYil7aGUrKztnZVtoZV09YS5jdXJyZW50O2EuY3VycmVudD1ifW5ldyBTZXQ7dmFyIGllPXtjdXJyZW50OkR9LFg9e2N1cnJlbnQ6ITF9LGplPUQ7ZnVuY3Rpb24ga2UoYSl7cmV0dXJuIGxlKGEpP2plOmllLmN1cnJlbnR9XG5mdW5jdGlvbiBtZShhLGIpe3ZhciBjPWEudHlwZS5jb250ZXh0VHlwZXM7aWYoIWMpcmV0dXJuIEQ7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoZCYmZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PT09YilyZXR1cm4gZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt2YXIgZT17fSxmO2ZvcihmIGluIGMpZVtmXT1iW2ZdO2QmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1iLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9ZSk7cmV0dXJuIGV9ZnVuY3Rpb24gbGUoYSl7cmV0dXJuIDI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzfWZ1bmN0aW9uIG5lKGEpe2xlKGEpJiYoVihYLGEpLFYoaWUsYSkpfVxuZnVuY3Rpb24gb2UoYSxiLGMpe251bGwhPWllLmN1cnNvcj9FKFwiMTY4XCIpOnZvaWQgMDtXKGllLGIsYSk7VyhYLGMsYSl9ZnVuY3Rpb24gcGUoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZSxkPWEudHlwZS5jaGlsZENvbnRleHRUeXBlcztpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXRDaGlsZENvbnRleHQpcmV0dXJuIGI7Yz1jLmdldENoaWxkQ29udGV4dCgpO2Zvcih2YXIgZSBpbiBjKWUgaW4gZD92b2lkIDA6RShcIjEwOFwiLGpkKGEpfHxcIlVua25vd25cIixlKTtyZXR1cm4gQih7fSxiLGMpfWZ1bmN0aW9uIHFlKGEpe2lmKCFsZShhKSlyZXR1cm4hMTt2YXIgYj1hLnN0YXRlTm9kZTtiPWImJmIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fEQ7amU9aWUuY3VycmVudDtXKGllLGIsYSk7VyhYLFguY3VycmVudCxhKTtyZXR1cm4hMH1cbmZ1bmN0aW9uIHJlKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7Yz92b2lkIDA6RShcIjE2OVwiKTtpZihiKXt2YXIgZD1wZShhLGplKTtjLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PWQ7VihYLGEpO1YoaWUsYSk7VyhpZSxkLGEpfWVsc2UgVihYLGEpO1coWCxiLGEpfVxuZnVuY3Rpb24gWShhLGIsYyl7dGhpcy50YWc9YTt0aGlzLmtleT1iO3RoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT1udWxsO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXNbXCJyZXR1cm5cIl09bnVsbDt0aGlzLmluZGV4PTA7dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPXRoaXMucGVuZGluZ1Byb3BzPXRoaXMucmVmPW51bGw7dGhpcy5pbnRlcm5hbENvbnRleHRUYWc9Yzt0aGlzLmVmZmVjdFRhZz0wO3RoaXMubGFzdEVmZmVjdD10aGlzLmZpcnN0RWZmZWN0PXRoaXMubmV4dEVmZmVjdD1udWxsO3RoaXMuZXhwaXJhdGlvblRpbWU9MDt0aGlzLmFsdGVybmF0ZT1udWxsfVxuZnVuY3Rpb24gc2UoYSxiLGMpe3ZhciBkPWEuYWx0ZXJuYXRlO251bGw9PT1kPyhkPW5ldyBZKGEudGFnLGEua2V5LGEuaW50ZXJuYWxDb250ZXh0VGFnKSxkLnR5cGU9YS50eXBlLGQuc3RhdGVOb2RlPWEuc3RhdGVOb2RlLGQuYWx0ZXJuYXRlPWEsYS5hbHRlcm5hdGU9ZCk6KGQuZWZmZWN0VGFnPTAsZC5uZXh0RWZmZWN0PW51bGwsZC5maXJzdEVmZmVjdD1udWxsLGQubGFzdEVmZmVjdD1udWxsKTtkLmV4cGlyYXRpb25UaW1lPWM7ZC5wZW5kaW5nUHJvcHM9YjtkLmNoaWxkPWEuY2hpbGQ7ZC5tZW1vaXplZFByb3BzPWEubWVtb2l6ZWRQcm9wcztkLm1lbW9pemVkU3RhdGU9YS5tZW1vaXplZFN0YXRlO2QudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZTtkLnNpYmxpbmc9YS5zaWJsaW5nO2QuaW5kZXg9YS5pbmRleDtkLnJlZj1hLnJlZjtyZXR1cm4gZH1cbmZ1bmN0aW9uIHRlKGEsYixjKXt2YXIgZD12b2lkIDAsZT1hLnR5cGUsZj1hLmtleTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZT8oZD1lLnByb3RvdHlwZSYmZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD9uZXcgWSgyLGYsYik6bmV3IFkoMCxmLGIpLGQudHlwZT1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOlwic3RyaW5nXCI9PT10eXBlb2YgZT8oZD1uZXcgWSg1LGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJvYmplY3RcIj09PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJudW1iZXJcIj09PXR5cGVvZiBlLnRhZz8oZD1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOkUoXCIxMzBcIixudWxsPT1lP2U6dHlwZW9mIGUsXCJcIik7ZC5leHBpcmF0aW9uVGltZT1jO3JldHVybiBkfWZ1bmN0aW9uIHVlKGEsYixjLGQpe2I9bmV3IFkoMTAsZCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1cbmZ1bmN0aW9uIHZlKGEsYixjKXtiPW5ldyBZKDYsbnVsbCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiB3ZShhLGIsYyl7Yj1uZXcgWSg3LGEua2V5LGIpO2IudHlwZT1hLmhhbmRsZXI7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9ZnVuY3Rpb24geGUoYSxiLGMpe2E9bmV3IFkoOSxudWxsLGIpO2EuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYX1mdW5jdGlvbiB5ZShhLGIsYyl7Yj1uZXcgWSg0LGEua2V5LGIpO2IucGVuZGluZ1Byb3BzPWEuY2hpbGRyZW58fFtdO2IuZXhwaXJhdGlvblRpbWU9YztiLnN0YXRlTm9kZT17Y29udGFpbmVySW5mbzphLmNvbnRhaW5lckluZm8scGVuZGluZ0NoaWxkcmVuOm51bGwsaW1wbGVtZW50YXRpb246YS5pbXBsZW1lbnRhdGlvbn07cmV0dXJuIGJ9dmFyIHplPW51bGwsQWU9bnVsbDtcbmZ1bmN0aW9uIEJlKGEpe3JldHVybiBmdW5jdGlvbihiKXt0cnl7cmV0dXJuIGEoYil9Y2F0Y2goYyl7fX19ZnVuY3Rpb24gQ2UoYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pcmV0dXJuITE7dmFyIGI9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGIuaXNEaXNhYmxlZHx8IWIuc3VwcG9ydHNGaWJlcilyZXR1cm4hMDt0cnl7dmFyIGM9Yi5pbmplY3QoYSk7emU9QmUoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclJvb3QoYyxhKX0pO0FlPUJlKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJVbm1vdW50KGMsYSl9KX1jYXRjaChkKXt9cmV0dXJuITB9ZnVuY3Rpb24gRGUoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIHplJiZ6ZShhKX1mdW5jdGlvbiBFZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgQWUmJkFlKGEpfVxuZnVuY3Rpb24gRmUoYSl7cmV0dXJue2Jhc2VTdGF0ZTphLGV4cGlyYXRpb25UaW1lOjAsZmlyc3Q6bnVsbCxsYXN0Om51bGwsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITEsaXNJbml0aWFsaXplZDohMX19ZnVuY3Rpb24gR2UoYSxiKXtudWxsPT09YS5sYXN0P2EuZmlyc3Q9YS5sYXN0PWI6KGEubGFzdC5uZXh0PWIsYS5sYXN0PWIpO2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxhLmV4cGlyYXRpb25UaW1lPmIuZXhwaXJhdGlvblRpbWUpYS5leHBpcmF0aW9uVGltZT1iLmV4cGlyYXRpb25UaW1lfVxuZnVuY3Rpb24gSGUoYSxiKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEudXBkYXRlUXVldWU7bnVsbD09PWQmJihkPWEudXBkYXRlUXVldWU9RmUobnVsbCkpO251bGwhPT1jPyhhPWMudXBkYXRlUXVldWUsbnVsbD09PWEmJihhPWMudXBkYXRlUXVldWU9RmUobnVsbCkpKTphPW51bGw7YT1hIT09ZD9hOm51bGw7bnVsbD09PWE/R2UoZCxiKTpudWxsPT09ZC5sYXN0fHxudWxsPT09YS5sYXN0PyhHZShkLGIpLEdlKGEsYikpOihHZShkLGIpLGEubGFzdD1iKX1mdW5jdGlvbiBJZShhLGIsYyxkKXthPWEucGFydGlhbFN0YXRlO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuY2FsbChiLGMsZCk6YX1cbmZ1bmN0aW9uIEplKGEsYixjLGQsZSxmKXtudWxsIT09YSYmYS51cGRhdGVRdWV1ZT09PWMmJihjPWIudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTpjLmJhc2VTdGF0ZSxleHBpcmF0aW9uVGltZTpjLmV4cGlyYXRpb25UaW1lLGZpcnN0OmMuZmlyc3QsbGFzdDpjLmxhc3QsaXNJbml0aWFsaXplZDpjLmlzSW5pdGlhbGl6ZWQsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITF9KTtjLmV4cGlyYXRpb25UaW1lPTA7Yy5pc0luaXRpYWxpemVkP2E9Yy5iYXNlU3RhdGU6KGE9Yy5iYXNlU3RhdGU9Yi5tZW1vaXplZFN0YXRlLGMuaXNJbml0aWFsaXplZD0hMCk7Zm9yKHZhciBnPSEwLGg9Yy5maXJzdCxrPSExO251bGwhPT1oOyl7dmFyIHE9aC5leHBpcmF0aW9uVGltZTtpZihxPmYpe3ZhciB2PWMuZXhwaXJhdGlvblRpbWU7aWYoMD09PXZ8fHY+cSljLmV4cGlyYXRpb25UaW1lPXE7a3x8KGs9ITAsYy5iYXNlU3RhdGU9YSl9ZWxzZXtrfHwoYy5maXJzdD1oLm5leHQsbnVsbD09PVxuYy5maXJzdCYmKGMubGFzdD1udWxsKSk7aWYoaC5pc1JlcGxhY2UpYT1JZShoLGQsYSxlKSxnPSEwO2Vsc2UgaWYocT1JZShoLGQsYSxlKSlhPWc/Qih7fSxhLHEpOkIoYSxxKSxnPSExO2guaXNGb3JjZWQmJihjLmhhc0ZvcmNlVXBkYXRlPSEwKTtudWxsIT09aC5jYWxsYmFjayYmKHE9Yy5jYWxsYmFja0xpc3QsbnVsbD09PXEmJihxPWMuY2FsbGJhY2tMaXN0PVtdKSxxLnB1c2goaCkpfWg9aC5uZXh0fW51bGwhPT1jLmNhbGxiYWNrTGlzdD9iLmVmZmVjdFRhZ3w9MzI6bnVsbCE9PWMuZmlyc3R8fGMuaGFzRm9yY2VVcGRhdGV8fChiLnVwZGF0ZVF1ZXVlPW51bGwpO2t8fChjLmJhc2VTdGF0ZT1hKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIEtlKGEsYil7dmFyIGM9YS5jYWxsYmFja0xpc3Q7aWYobnVsbCE9PWMpZm9yKGEuY2FsbGJhY2tMaXN0PW51bGwsYT0wO2E8Yy5sZW5ndGg7YSsrKXt2YXIgZD1jW2FdLGU9ZC5jYWxsYmFjaztkLmNhbGxiYWNrPW51bGw7XCJmdW5jdGlvblwiIT09dHlwZW9mIGU/RShcIjE5MVwiLGUpOnZvaWQgMDtlLmNhbGwoYil9fVxuZnVuY3Rpb24gTGUoYSxiLGMsZCl7ZnVuY3Rpb24gZShhLGIpe2IudXBkYXRlcj1mO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbEZpYmVyPWF9dmFyIGY9e2lzTW91bnRlZDpsZCxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oYyxkLGUpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2U9dm9pZCAwPT09ZT9udWxsOmU7dmFyIGc9YihjKTtIZShjLHtleHBpcmF0aW9uVGltZTpnLHBhcnRpYWxTdGF0ZTpkLGNhbGxiYWNrOmUsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiExLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoYyxnKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITAsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7XG5hKGMsZyl9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihjLGQpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGU9YihjKTtIZShjLHtleHBpcmF0aW9uVGltZTplLHBhcnRpYWxTdGF0ZTpudWxsLGNhbGxiYWNrOmQsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiEwLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoYyxlKX19O3JldHVybnthZG9wdENsYXNzSW5zdGFuY2U6ZSxjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS50eXBlLGQ9a2UoYSksZj0yPT09YS50YWcmJm51bGwhPWEudHlwZS5jb250ZXh0VHlwZXMsZz1mP21lKGEsZCk6RDtiPW5ldyBjKGIsZyk7ZShhLGIpO2YmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1kLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9Zyk7cmV0dXJuIGJ9LG1vdW50Q2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLnN0YXRlTm9kZSxlPWQuc3RhdGV8fG51bGwsZz1hLnBlbmRpbmdQcm9wcztnP3ZvaWQgMDpFKFwiMTU4XCIpO3ZhciBoPWtlKGEpO2QucHJvcHM9ZztkLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZT1lO2QucmVmcz1EO2QuY29udGV4dD1tZShhLGgpO251bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCYmKGEuaW50ZXJuYWxDb250ZXh0VGFnfD0xKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnRXaWxsTW91bnQmJihlPWQuc3RhdGUsZC5jb21wb25lbnRXaWxsTW91bnQoKSxlIT09ZC5zdGF0ZSYmZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGQsZC5zdGF0ZSxudWxsKSxlPWEudXBkYXRlUXVldWUsbnVsbCE9PWUmJihkLnN0YXRlPUplKGMsYSxlLGQsZyxiKSkpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZE1vdW50JiYoYS5lZmZlY3RUYWd8PVxuNCl9LHVwZGF0ZUNsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGUpe3ZhciBnPWIuc3RhdGVOb2RlO2cucHJvcHM9Yi5tZW1vaXplZFByb3BzO2cuc3RhdGU9Yi5tZW1vaXplZFN0YXRlO3ZhciBoPWIubWVtb2l6ZWRQcm9wcyxrPWIucGVuZGluZ1Byb3BzO2t8fChrPWgsbnVsbD09az9FKFwiMTU5XCIpOnZvaWQgMCk7dmFyIHU9Zy5jb250ZXh0LHo9a2UoYik7ej1tZShiLHopO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fGg9PT1rJiZ1PT09enx8KHU9Zy5zdGF0ZSxnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoayx6KSxnLnN0YXRlIT09dSYmZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGcsZy5zdGF0ZSxudWxsKSk7dT1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09Yi51cGRhdGVRdWV1ZT9KZShhLGIsYi51cGRhdGVRdWV1ZSxnLGssZSk6dTtpZighKGghPT1rfHx1IT09ZXx8WC5jdXJyZW50fHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkpcmV0dXJuXCJmdW5jdGlvblwiIT09XG50eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnU9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksITE7dmFyIEc9aztpZihudWxsPT09aHx8bnVsbCE9PWIudXBkYXRlUXVldWUmJmIudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpRz0hMDtlbHNle3ZhciBJPWIuc3RhdGVOb2RlLEw9Yi50eXBlO0c9XCJmdW5jdGlvblwiPT09dHlwZW9mIEkuc2hvdWxkQ29tcG9uZW50VXBkYXRlP0kuc2hvdWxkQ29tcG9uZW50VXBkYXRlKEcsZSx6KTpMLnByb3RvdHlwZSYmTC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IWVhKGgsRyl8fCFlYSh1LGUpOiEwfUc/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJmcuY29tcG9uZW50V2lsbFVwZGF0ZShrLGUseiksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlJiYoYi5lZmZlY3RUYWd8PTQpKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbmg9PT1hLm1lbW9pemVkUHJvcHMmJnU9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksYyhiLGspLGQoYixlKSk7Zy5wcm9wcz1rO2cuc3RhdGU9ZTtnLmNvbnRleHQ9ejtyZXR1cm4gR319fXZhciBRZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0sUmU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxTZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5jYWxsXCIpOjYwMTA0LFRlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKTo2MDEwNSxVZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsVmU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsV2U9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24gWGUoYSl7aWYobnVsbD09PWF8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPVdlJiZhW1dlXXx8YVtcIkBAaXRlcmF0b3JcIl07cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YTpudWxsfXZhciBZZT1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gWmUoYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsIT09YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGMpe2lmKGIuX293bmVyKXtiPWIuX293bmVyO3ZhciBkPXZvaWQgMDtiJiYoMiE9PWIudGFnP0UoXCIxMTBcIik6dm9pZCAwLGQ9Yi5zdGF0ZU5vZGUpO2Q/dm9pZCAwOkUoXCIxNDdcIixjKTt2YXIgZT1cIlwiK2M7aWYobnVsbCE9PWEmJm51bGwhPT1hLnJlZiYmYS5yZWYuX3N0cmluZ1JlZj09PWUpcmV0dXJuIGEucmVmO2E9ZnVuY3Rpb24oYSl7dmFyIGI9ZC5yZWZzPT09RD9kLnJlZnM9e306ZC5yZWZzO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07YS5fc3RyaW5nUmVmPWU7cmV0dXJuIGF9XCJzdHJpbmdcIiE9PXR5cGVvZiBjP0UoXCIxNDhcIik6dm9pZCAwO2IuX293bmVyP3ZvaWQgMDpFKFwiMTQ5XCIsYyl9cmV0dXJuIGN9XG5mdW5jdGlvbiAkZShhLGIpe1widGV4dGFyZWFcIiE9PWEudHlwZSYmRShcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGIpLmpvaW4oXCIsIFwiKStcIn1cIjpiLFwiXCIpfVxuZnVuY3Rpb24gYWYoYSl7ZnVuY3Rpb24gYihiLGMpe2lmKGEpe3ZhciBkPWIubGFzdEVmZmVjdDtudWxsIT09ZD8oZC5uZXh0RWZmZWN0PWMsYi5sYXN0RWZmZWN0PWMpOmIuZmlyc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0PWM7Yy5uZXh0RWZmZWN0PW51bGw7Yy5lZmZlY3RUYWc9OH19ZnVuY3Rpb24gYyhjLGQpe2lmKCFhKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWIoYyxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZShhLGIsYyl7YT1zZShhLGIsYyk7YS5pbmRleD0wO2Euc2libGluZz1udWxsO3JldHVybiBhfWZ1bmN0aW9uIGYoYixjLGQpe2IuaW5kZXg9ZDtpZighYSlyZXR1cm4gYztkPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1kKXJldHVybiBkPWQuaW5kZXgsZDxjPyhiLmVmZmVjdFRhZz1cbjIsYyk6ZDtiLmVmZmVjdFRhZz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5lZmZlY3RUYWc9Mik7cmV0dXJuIGJ9ZnVuY3Rpb24gaChhLGIsYyxkKXtpZihudWxsPT09Ynx8NiE9PWIudGFnKXJldHVybiBiPXZlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXtpZihudWxsIT09YiYmYi50eXBlPT09Yy50eXBlKXJldHVybiBkPWUoYixjLnByb3BzLGQpLGQucmVmPVplKGIsYyksZFtcInJldHVyblwiXT1hLGQ7ZD10ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpO2QucmVmPVplKGIsYyk7ZFtcInJldHVyblwiXT1hO3JldHVybiBkfWZ1bmN0aW9uIHEoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDchPT1iLnRhZylyZXR1cm4gYj13ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMsZCk7XG5iW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gdihhLGIsYyxkKXtpZihudWxsPT09Ynx8OSE9PWIudGFnKXJldHVybiBiPXhlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYi50eXBlPWMudmFsdWUsYltcInJldHVyblwiXT1hLGI7Yj1lKGIsbnVsbCxkKTtiLnR5cGU9Yy52YWx1ZTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geShhLGIsYyxkKXtpZihudWxsPT09Ynx8NCE9PWIudGFnfHxiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09Yy5jb250YWluZXJJbmZvfHxiLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiE9PWMuaW1wbGVtZW50YXRpb24pcmV0dXJuIGI9eWUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLmNoaWxkcmVufHxbXSxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gdShhLGIsYyxkLGYpe2lmKG51bGw9PT1ifHwxMCE9PWIudGFnKXJldHVybiBiPXVlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsXG5kLGYpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMsZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHooYSxiLGMpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBiKXJldHVybiBiPXZlKFwiXCIrYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKXtzd2l0Y2goYi4kJHR5cGVvZil7Y2FzZSBSZTppZihiLnR5cGU9PT1WZSlyZXR1cm4gYj11ZShiLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMsYi5rZXkpLGJbXCJyZXR1cm5cIl09YSxiO2M9dGUoYixhLmludGVybmFsQ29udGV4dFRhZyxjKTtjLnJlZj1aZShudWxsLGIpO2NbXCJyZXR1cm5cIl09YTtyZXR1cm4gYztjYXNlIFNlOnJldHVybiBiPXdlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGI7Y2FzZSBUZTpyZXR1cm4gYz14ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLFxuYyksYy50eXBlPWIudmFsdWUsY1tcInJldHVyblwiXT1hLGM7Y2FzZSBVZTpyZXR1cm4gYj15ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxifWlmKFllKGIpfHxYZShiKSlyZXR1cm4gYj11ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMsbnVsbCksYltcInJldHVyblwiXT1hLGI7JGUoYSxiKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBHKGEsYixjLGQpe3ZhciBlPW51bGwhPT1iP2Iua2V5Om51bGw7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBjfHxcIm51bWJlclwiPT09dHlwZW9mIGMpcmV0dXJuIG51bGwhPT1lP251bGw6aChhLGIsXCJcIitjLGQpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYyYmbnVsbCE9PWMpe3N3aXRjaChjLiQkdHlwZW9mKXtjYXNlIFJlOnJldHVybiBjLmtleT09PWU/Yy50eXBlPT09VmU/dShhLGIsYy5wcm9wcy5jaGlsZHJlbixkLGUpOmsoYSxiLGMsZCk6bnVsbDtjYXNlIFNlOnJldHVybiBjLmtleT09PWU/cShhLGIsYyxkKTpudWxsO2Nhc2UgVGU6cmV0dXJuIG51bGw9PT1cbmU/dihhLGIsYyxkKTpudWxsO2Nhc2UgVWU6cmV0dXJuIGMua2V5PT09ZT95KGEsYixjLGQpOm51bGx9aWYoWWUoYyl8fFhlKGMpKXJldHVybiBudWxsIT09ZT9udWxsOnUoYSxiLGMsZCxudWxsKTskZShhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEkoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxoKGIsYSxcIlwiK2QsZSk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCl7c3dpdGNoKGQuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGQudHlwZT09PVZlP3UoYixhLGQucHJvcHMuY2hpbGRyZW4sZSxkLmtleSk6ayhiLGEsZCxlKTtjYXNlIFNlOnJldHVybiBhPWEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCxxKGIsYSxkLGUpO2Nhc2UgVGU6cmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsdihiLGEsZCxlKTtjYXNlIFVlOnJldHVybiBhPVxuYS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLHkoYixhLGQsZSl9aWYoWWUoZCl8fFhlKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLHUoYixhLGQsZSxudWxsKTskZShiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIEwoZSxnLG0sQSl7Zm9yKHZhciBoPW51bGwscj1udWxsLG49Zyx3PWc9MCxrPW51bGw7bnVsbCE9PW4mJnc8bS5sZW5ndGg7dysrKXtuLmluZGV4Pnc/KGs9bixuPW51bGwpOms9bi5zaWJsaW5nO3ZhciB4PUcoZSxuLG1bd10sQSk7aWYobnVsbD09PXgpe251bGw9PT1uJiYobj1rKTticmVha31hJiZuJiZudWxsPT09eC5hbHRlcm5hdGUmJmIoZSxuKTtnPWYoeCxnLHcpO251bGw9PT1yP2g9eDpyLnNpYmxpbmc9eDtyPXg7bj1rfWlmKHc9PT1tLmxlbmd0aClyZXR1cm4gYyhlLG4pLGg7aWYobnVsbD09PW4pe2Zvcig7dzxtLmxlbmd0aDt3KyspaWYobj16KGUsbVt3XSxBKSlnPWYobixnLHcpLG51bGw9PT1yP2g9bjpyLnNpYmxpbmc9bixyPW47cmV0dXJuIGh9Zm9yKG49XG5kKGUsbik7dzxtLmxlbmd0aDt3KyspaWYoaz1JKG4sZSx3LG1bd10sQSkpe2lmKGEmJm51bGwhPT1rLmFsdGVybmF0ZSluW1wiZGVsZXRlXCJdKG51bGw9PT1rLmtleT93Omsua2V5KTtnPWYoayxnLHcpO251bGw9PT1yP2g9azpyLnNpYmxpbmc9aztyPWt9YSYmbi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtyZXR1cm4gaH1mdW5jdGlvbiBOKGUsZyxtLEEpe3ZhciBoPVhlKG0pO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBoP0UoXCIxNTBcIik6dm9pZCAwO209aC5jYWxsKG0pO251bGw9PW0/RShcIjE1MVwiKTp2b2lkIDA7Zm9yKHZhciByPWg9bnVsbCxuPWcsdz1nPTAsaz1udWxsLHg9bS5uZXh0KCk7bnVsbCE9PW4mJiF4LmRvbmU7dysrLHg9bS5uZXh0KCkpe24uaW5kZXg+dz8oaz1uLG49bnVsbCk6az1uLnNpYmxpbmc7dmFyIEo9RyhlLG4seC52YWx1ZSxBKTtpZihudWxsPT09Sil7bnx8KG49ayk7YnJlYWt9YSYmbiYmbnVsbD09PUouYWx0ZXJuYXRlJiZiKGUsbik7Zz1mKEosXG5nLHcpO251bGw9PT1yP2g9SjpyLnNpYmxpbmc9SjtyPUo7bj1rfWlmKHguZG9uZSlyZXR1cm4gYyhlLG4pLGg7aWYobnVsbD09PW4pe2Zvcig7IXguZG9uZTt3KysseD1tLm5leHQoKSl4PXooZSx4LnZhbHVlLEEpLG51bGwhPT14JiYoZz1mKHgsZyx3KSxudWxsPT09cj9oPXg6ci5zaWJsaW5nPXgscj14KTtyZXR1cm4gaH1mb3Iobj1kKGUsbik7IXguZG9uZTt3KysseD1tLm5leHQoKSlpZih4PUkobixlLHcseC52YWx1ZSxBKSxudWxsIT09eCl7aWYoYSYmbnVsbCE9PXguYWx0ZXJuYXRlKW5bXCJkZWxldGVcIl0obnVsbD09PXgua2V5P3c6eC5rZXkpO2c9Zih4LGcsdyk7bnVsbD09PXI/aD14OnIuc2libGluZz14O3I9eH1hJiZuLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBofXJldHVybiBmdW5jdGlvbihhLGQsZixoKXtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT1WZSYmbnVsbD09PWYua2V5JiYoZj1mLnByb3BzLmNoaWxkcmVuKTtcbnZhciBtPVwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY7aWYobSlzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBSZTphOnt2YXIgcj1mLmtleTtmb3IobT1kO251bGwhPT1tOyl7aWYobS5rZXk9PT1yKWlmKDEwPT09bS50YWc/Zi50eXBlPT09VmU6bS50eXBlPT09Zi50eXBlKXtjKGEsbS5zaWJsaW5nKTtkPWUobSxmLnR5cGU9PT1WZT9mLnByb3BzLmNoaWxkcmVuOmYucHJvcHMsaCk7ZC5yZWY9WmUobSxmKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsbSk7YnJlYWt9ZWxzZSBiKGEsbSk7bT1tLnNpYmxpbmd9Zi50eXBlPT09VmU/KGQ9dWUoZi5wcm9wcy5jaGlsZHJlbixhLmludGVybmFsQ29udGV4dFRhZyxoLGYua2V5KSxkW1wicmV0dXJuXCJdPWEsYT1kKTooaD10ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpLGgucmVmPVplKGQsZiksaFtcInJldHVyblwiXT1hLGE9aCl9cmV0dXJuIGcoYSk7Y2FzZSBTZTphOntmb3IobT1mLmtleTtudWxsIT09ZDspe2lmKGQua2V5PT09XG5tKWlmKDc9PT1kLnRhZyl7YyhhLGQuc2libGluZyk7ZD1lKGQsZixoKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1kLnNpYmxpbmd9ZD13ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSk7Y2FzZSBUZTphOntpZihudWxsIT09ZClpZig5PT09ZC50YWcpe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLG51bGwsaCk7ZC50eXBlPWYudmFsdWU7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2UgYyhhLGQpO2Q9eGUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtkLnR5cGU9Zi52YWx1ZTtkW1wicmV0dXJuXCJdPWE7YT1kfXJldHVybiBnKGEpO2Nhc2UgVWU6YTp7Zm9yKG09Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PW0paWYoND09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PVxuZi5pbXBsZW1lbnRhdGlvbil7YyhhLGQuc2libGluZyk7ZD1lKGQsZi5jaGlsZHJlbnx8W10saCk7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9eWUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtkW1wicmV0dXJuXCJdPWE7YT1kfXJldHVybiBnKGEpfWlmKFwic3RyaW5nXCI9PT10eXBlb2YgZnx8XCJudW1iZXJcIj09PXR5cGVvZiBmKXJldHVybiBmPVwiXCIrZixudWxsIT09ZCYmNj09PWQudGFnPyhjKGEsZC5zaWJsaW5nKSxkPWUoZCxmLGgpKTooYyhhLGQpLGQ9dmUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKSksZFtcInJldHVyblwiXT1hLGE9ZCxnKGEpO2lmKFllKGYpKXJldHVybiBMKGEsZCxmLGgpO2lmKFhlKGYpKXJldHVybiBOKGEsZCxmLGgpO20mJiRlKGEsZik7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBmKXN3aXRjaChhLnRhZyl7Y2FzZSAyOmNhc2UgMTpoPWEudHlwZSxFKFwiMTUyXCIsaC5kaXNwbGF5TmFtZXx8XG5oLm5hbWV8fFwiQ29tcG9uZW50XCIpfXJldHVybiBjKGEsZCl9fXZhciBiZj1hZighMCksY2Y9YWYoITEpO1xuZnVuY3Rpb24gZGYoYSxiLGMsZCxlKXtmdW5jdGlvbiBmKGEsYixjKXt2YXIgZD1iLmV4cGlyYXRpb25UaW1lO2IuY2hpbGQ9bnVsbD09PWE/Y2YoYixudWxsLGMsZCk6YmYoYixhLmNoaWxkLGMsZCl9ZnVuY3Rpb24gZyhhLGIpe3ZhciBjPWIucmVmO251bGw9PT1jfHxhJiZhLnJlZj09PWN8fChiLmVmZmVjdFRhZ3w9MTI4KX1mdW5jdGlvbiBoKGEsYixjLGQpe2coYSxiKTtpZighYylyZXR1cm4gZCYmcmUoYiwhMSkscShhLGIpO2M9Yi5zdGF0ZU5vZGU7aWQuY3VycmVudD1iO3ZhciBlPWMucmVuZGVyKCk7Yi5lZmZlY3RUYWd8PTE7ZihhLGIsZSk7Yi5tZW1vaXplZFN0YXRlPWMuc3RhdGU7Yi5tZW1vaXplZFByb3BzPWMucHJvcHM7ZCYmcmUoYiwhMCk7cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gayhhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P29lKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJm9lKGEsXG5iLmNvbnRleHQsITEpO0koYSxiLmNvbnRhaW5lckluZm8pfWZ1bmN0aW9uIHEoYSxiKXtudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQ/RShcIjE1M1wiKTp2b2lkIDA7aWYobnVsbCE9PWIuY2hpbGQpe2E9Yi5jaGlsZDt2YXIgYz1zZShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpO2IuY2hpbGQ9Yztmb3IoY1tcInJldHVyblwiXT1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPXNlKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSksY1tcInJldHVyblwiXT1iO2Muc2libGluZz1udWxsfXJldHVybiBiLmNoaWxkfWZ1bmN0aW9uIHYoYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMzprKGIpO2JyZWFrO2Nhc2UgMjpxZShiKTticmVhaztjYXNlIDQ6SShiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pfXJldHVybiBudWxsfXZhciB5PWEuc2hvdWxkU2V0VGV4dENvbnRlbnQsdT1hLnVzZVN5bmNTY2hlZHVsaW5nLHo9YS5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlLFxuRz1iLnB1c2hIb3N0Q29udGV4dCxJPWIucHVzaEhvc3RDb250YWluZXIsTD1jLmVudGVySHlkcmF0aW9uU3RhdGUsTj1jLnJlc2V0SHlkcmF0aW9uU3RhdGUsSj1jLnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlO2E9TGUoZCxlLGZ1bmN0aW9uKGEsYil7YS5tZW1vaXplZFByb3BzPWJ9LGZ1bmN0aW9uKGEsYil7YS5tZW1vaXplZFN0YXRlPWJ9KTt2YXIgdz1hLmFkb3B0Q2xhc3NJbnN0YW5jZSxtPWEuY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxBPWEubW91bnRDbGFzc0luc3RhbmNlLE9iPWEudXBkYXRlQ2xhc3NJbnN0YW5jZTtyZXR1cm57YmVnaW5Xb3JrOmZ1bmN0aW9uKGEsYixjKXtpZigwPT09Yi5leHBpcmF0aW9uVGltZXx8Yi5leHBpcmF0aW9uVGltZT5jKXJldHVybiB2KGEsYik7c3dpdGNoKGIudGFnKXtjYXNlIDA6bnVsbCE9PWE/RShcIjE1NVwiKTp2b2lkIDA7dmFyIGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMscj1rZShiKTtyPW1lKGIscik7ZD1kKGUscik7Yi5lZmZlY3RUYWd8PVxuMTtcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5yZW5kZXI/KGIudGFnPTIsZT1xZShiKSx3KGIsZCksQShiLGMpLGI9aChhLGIsITAsZSkpOihiLnRhZz0xLGYoYSxiLGQpLGIubWVtb2l6ZWRQcm9wcz1lLGI9Yi5jaGlsZCk7cmV0dXJuIGI7Y2FzZSAxOmE6e2U9Yi50eXBlO2M9Yi5wZW5kaW5nUHJvcHM7ZD1iLm1lbW9pemVkUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1jJiYoYz1kKTtlbHNlIGlmKG51bGw9PT1jfHxkPT09Yyl7Yj1xKGEsYik7YnJlYWsgYX1kPWtlKGIpO2Q9bWUoYixkKTtlPWUoYyxkKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkUHJvcHM9YztiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSAyOnJldHVybiBlPXFlKGIpLGQ9dm9pZCAwLG51bGw9PT1hP2Iuc3RhdGVOb2RlP0UoXCIxNTNcIik6KG0oYixiLnBlbmRpbmdQcm9wcyksQShiLGMpLGQ9ITApOmQ9T2IoYSxiLGMpLGgoYSxiLGQsZSk7Y2FzZSAzOnJldHVybiBrKGIpLFxuZT1iLnVwZGF0ZVF1ZXVlLG51bGwhPT1lPyhkPWIubWVtb2l6ZWRTdGF0ZSxlPUplKGEsYixlLG51bGwsbnVsbCxjKSxkPT09ZT8oTigpLGI9cShhLGIpKTooZD1lLmVsZW1lbnQscj1iLnN0YXRlTm9kZSwobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKSYmci5oeWRyYXRlJiZMKGIpPyhiLmVmZmVjdFRhZ3w9MixiLmNoaWxkPWNmKGIsbnVsbCxkLGMpKTooTigpLGYoYSxiLGQpKSxiLm1lbW9pemVkU3RhdGU9ZSxiPWIuY2hpbGQpKTooTigpLGI9cShhLGIpKSxiO2Nhc2UgNTpHKGIpO251bGw9PT1hJiZKKGIpO2U9Yi50eXBlO3ZhciBuPWIubWVtb2l6ZWRQcm9wcztkPWIucGVuZGluZ1Byb3BzO251bGw9PT1kJiYoZD1uLG51bGw9PT1kP0UoXCIxNTRcIik6dm9pZCAwKTtyPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpudWxsO1guY3VycmVudHx8bnVsbCE9PWQmJm4hPT1kPyhuPWQuY2hpbGRyZW4seShlLGQpP249bnVsbDpyJiZ5KGUscikmJihiLmVmZmVjdFRhZ3w9MTYpLGcoYSxiKSxcbjIxNDc0ODM2NDchPT1jJiYhdSYmeihlLGQpPyhiLmV4cGlyYXRpb25UaW1lPTIxNDc0ODM2NDcsYj1udWxsKTooZihhLGIsbiksYi5tZW1vaXplZFByb3BzPWQsYj1iLmNoaWxkKSk6Yj1xKGEsYik7cmV0dXJuIGI7Y2FzZSA2OnJldHVybiBudWxsPT09YSYmSihiKSxhPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hJiYoYT1iLm1lbW9pemVkUHJvcHMpLGIubWVtb2l6ZWRQcm9wcz1hLG51bGw7Y2FzZSA4OmIudGFnPTc7Y2FzZSA3OmU9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1lJiYoZT1hJiZhLm1lbW9pemVkUHJvcHMsbnVsbD09PWU/RShcIjE1NFwiKTp2b2lkIDApO2Vsc2UgaWYobnVsbD09PWV8fGIubWVtb2l6ZWRQcm9wcz09PWUpZT1iLm1lbW9pemVkUHJvcHM7ZD1lLmNoaWxkcmVuO2Iuc3RhdGVOb2RlPW51bGw9PT1hP2NmKGIsYi5zdGF0ZU5vZGUsZCxjKTpiZihiLGIuc3RhdGVOb2RlLGQsYyk7Yi5tZW1vaXplZFByb3BzPWU7cmV0dXJuIGIuc3RhdGVOb2RlO1xuY2FzZSA5OnJldHVybiBudWxsO2Nhc2UgNDphOntJKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT1lP0UoXCIxNTRcIik6dm9pZCAwKTtlbHNlIGlmKG51bGw9PT1lfHxiLm1lbW9pemVkUHJvcHM9PT1lKXtiPXEoYSxiKTticmVhayBhfW51bGw9PT1hP2IuY2hpbGQ9YmYoYixudWxsLGUsYyk6ZihhLGIsZSk7Yi5tZW1vaXplZFByb3BzPWU7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgMTA6YTp7Yz1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWIubWVtb2l6ZWRQcm9wcyk7ZWxzZSBpZihudWxsPT09Y3x8Yi5tZW1vaXplZFByb3BzPT09Yyl7Yj1xKGEsYik7YnJlYWsgYX1mKGEsYixjKTtiLm1lbW9pemVkUHJvcHM9YztiPWIuY2hpbGR9cmV0dXJuIGI7ZGVmYXVsdDpFKFwiMTU2XCIpfX0sYmVnaW5GYWlsZWRXb3JrOmZ1bmN0aW9uKGEsYixcbmMpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOnFlKGIpO2JyZWFrO2Nhc2UgMzprKGIpO2JyZWFrO2RlZmF1bHQ6RShcIjE1N1wiKX1iLmVmZmVjdFRhZ3w9NjQ7bnVsbD09PWE/Yi5jaGlsZD1udWxsOmIuY2hpbGQhPT1hLmNoaWxkJiYoYi5jaGlsZD1hLmNoaWxkKTtpZigwPT09Yi5leHBpcmF0aW9uVGltZXx8Yi5leHBpcmF0aW9uVGltZT5jKXJldHVybiB2KGEsYik7Yi5maXJzdEVmZmVjdD1udWxsO2IubGFzdEVmZmVjdD1udWxsO2IuY2hpbGQ9bnVsbD09PWE/Y2YoYixudWxsLG51bGwsYyk6YmYoYixhLmNoaWxkLG51bGwsYyk7Mj09PWIudGFnJiYoYT1iLnN0YXRlTm9kZSxiLm1lbW9pemVkUHJvcHM9YS5wcm9wcyxiLm1lbW9pemVkU3RhdGU9YS5zdGF0ZSk7cmV0dXJuIGIuY2hpbGR9fX1cbmZ1bmN0aW9uIGVmKGEsYixjKXtmdW5jdGlvbiBkKGEpe2EuZWZmZWN0VGFnfD00fXZhciBlPWEuY3JlYXRlSW5zdGFuY2UsZj1hLmNyZWF0ZVRleHRJbnN0YW5jZSxnPWEuYXBwZW5kSW5pdGlhbENoaWxkLGg9YS5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbixrPWEucHJlcGFyZVVwZGF0ZSxxPWEucGVyc2lzdGVuY2Usdj1iLmdldFJvb3RIb3N0Q29udGFpbmVyLHk9Yi5wb3BIb3N0Q29udGV4dCx1PWIuZ2V0SG9zdENvbnRleHQsej1iLnBvcEhvc3RDb250YWluZXIsRz1jLnByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsST1jLnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLEw9Yy5wb3BIeWRyYXRpb25TdGF0ZSxOPXZvaWQgMCxKPXZvaWQgMCx3PXZvaWQgMDthLm11dGF0aW9uPyhOPWZ1bmN0aW9uKCl7fSxKPWZ1bmN0aW9uKGEsYixjKXsoYi51cGRhdGVRdWV1ZT1jKSYmZChiKX0sdz1mdW5jdGlvbihhLGIsYyxlKXtjIT09ZSYmZChiKX0pOnE/RShcIjIzNVwiKTpFKFwiMjM2XCIpO1xucmV0dXJue2NvbXBsZXRlV29yazpmdW5jdGlvbihhLGIsYyl7dmFyIG09Yi5wZW5kaW5nUHJvcHM7aWYobnVsbD09PW0pbT1iLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigyMTQ3NDgzNjQ3IT09Yi5leHBpcmF0aW9uVGltZXx8MjE0NzQ4MzY0Nz09PWMpYi5wZW5kaW5nUHJvcHM9bnVsbDtzd2l0Y2goYi50YWcpe2Nhc2UgMTpyZXR1cm4gbnVsbDtjYXNlIDI6cmV0dXJuIG5lKGIpLG51bGw7Y2FzZSAzOnooYik7VihYLGIpO1YoaWUsYik7bT1iLnN0YXRlTm9kZTttLnBlbmRpbmdDb250ZXh0JiYobS5jb250ZXh0PW0ucGVuZGluZ0NvbnRleHQsbS5wZW5kaW5nQ29udGV4dD1udWxsKTtpZihudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpTChiKSxiLmVmZmVjdFRhZyY9LTM7TihiKTtyZXR1cm4gbnVsbDtjYXNlIDU6eShiKTtjPXYoKTt2YXIgQT1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKXt2YXIgcD1hLm1lbW9pemVkUHJvcHMscT1iLnN0YXRlTm9kZSx4PXUoKTtxPVxuayhxLEEscCxtLGMseCk7SihhLGIscSxBLHAsbSxjKTthLnJlZiE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCl9ZWxzZXtpZighbSlyZXR1cm4gbnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjZcIik6dm9pZCAwLG51bGw7YT11KCk7aWYoTChiKSlHKGIsYyxhKSYmZChiKTtlbHNle2E9ZShBLG0sYyxhLGIpO2E6Zm9yKHA9Yi5jaGlsZDtudWxsIT09cDspe2lmKDU9PT1wLnRhZ3x8Nj09PXAudGFnKWcoYSxwLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09cC50YWcmJm51bGwhPT1wLmNoaWxkKXtwLmNoaWxkW1wicmV0dXJuXCJdPXA7cD1wLmNoaWxkO2NvbnRpbnVlfWlmKHA9PT1iKWJyZWFrO2Zvcig7bnVsbD09PXAuc2libGluZzspe2lmKG51bGw9PT1wW1wicmV0dXJuXCJdfHxwW1wicmV0dXJuXCJdPT09YilicmVhayBhO3A9cFtcInJldHVyblwiXX1wLnNpYmxpbmdbXCJyZXR1cm5cIl09cFtcInJldHVyblwiXTtwPXAuc2libGluZ31oKGEsQSxtLGMpJiZkKGIpO2Iuc3RhdGVOb2RlPWF9bnVsbCE9PWIucmVmJiZcbihiLmVmZmVjdFRhZ3w9MTI4KX1yZXR1cm4gbnVsbDtjYXNlIDY6aWYoYSYmbnVsbCE9Yi5zdGF0ZU5vZGUpdyhhLGIsYS5tZW1vaXplZFByb3BzLG0pO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBtKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2NlwiKTp2b2lkIDAsbnVsbDthPXYoKTtjPXUoKTtMKGIpP0koYikmJmQoYik6Yi5zdGF0ZU5vZGU9ZihtLGEsYyxiKX1yZXR1cm4gbnVsbDtjYXNlIDc6KG09Yi5tZW1vaXplZFByb3BzKT92b2lkIDA6RShcIjE2NVwiKTtiLnRhZz04O0E9W107YTpmb3IoKHA9Yi5zdGF0ZU5vZGUpJiYocFtcInJldHVyblwiXT1iKTtudWxsIT09cDspe2lmKDU9PT1wLnRhZ3x8Nj09PXAudGFnfHw0PT09cC50YWcpRShcIjI0N1wiKTtlbHNlIGlmKDk9PT1wLnRhZylBLnB1c2gocC50eXBlKTtlbHNlIGlmKG51bGwhPT1wLmNoaWxkKXtwLmNoaWxkW1wicmV0dXJuXCJdPXA7cD1wLmNoaWxkO2NvbnRpbnVlfWZvcig7bnVsbD09PXAuc2libGluZzspe2lmKG51bGw9PT1cbnBbXCJyZXR1cm5cIl18fHBbXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7cD1wW1wicmV0dXJuXCJdfXAuc2libGluZ1tcInJldHVyblwiXT1wW1wicmV0dXJuXCJdO3A9cC5zaWJsaW5nfXA9bS5oYW5kbGVyO209cChtLnByb3BzLEEpO2IuY2hpbGQ9YmYoYixudWxsIT09YT9hLmNoaWxkOm51bGwsbSxjKTtyZXR1cm4gYi5jaGlsZDtjYXNlIDg6cmV0dXJuIGIudGFnPTcsbnVsbDtjYXNlIDk6cmV0dXJuIG51bGw7Y2FzZSAxMDpyZXR1cm4gbnVsbDtjYXNlIDQ6cmV0dXJuIHooYiksTihiKSxudWxsO2Nhc2UgMDpFKFwiMTY3XCIpO2RlZmF1bHQ6RShcIjE1NlwiKX19fX1cbmZ1bmN0aW9uIGZmKGEsYil7ZnVuY3Rpb24gYyhhKXt2YXIgYz1hLnJlZjtpZihudWxsIT09Yyl0cnl7YyhudWxsKX1jYXRjaChBKXtiKGEsQSl9fWZ1bmN0aW9uIGQoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIEVlJiZFZShhKTtzd2l0Y2goYS50YWcpe2Nhc2UgMjpjKGEpO3ZhciBkPWEuc3RhdGVOb2RlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtkLnByb3BzPWEubWVtb2l6ZWRQcm9wcyxkLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSxkLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2goQSl7YihhLEEpfWJyZWFrO2Nhc2UgNTpjKGEpO2JyZWFrO2Nhc2UgNzplKGEuc3RhdGVOb2RlKTticmVhaztjYXNlIDQ6ayYmZyhhKX19ZnVuY3Rpb24gZShhKXtmb3IodmFyIGI9YTs7KWlmKGQoYiksbnVsbD09PWIuY2hpbGR8fGsmJjQ9PT1iLnRhZyl7aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fFxuYltcInJldHVyblwiXT09PWEpcmV0dXJuO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ31lbHNlIGIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGR9ZnVuY3Rpb24gZihhKXtyZXR1cm4gNT09PWEudGFnfHwzPT09YS50YWd8fDQ9PT1hLnRhZ31mdW5jdGlvbiBnKGEpe2Zvcih2YXIgYj1hLGM9ITEsZj12b2lkIDAsZz12b2lkIDA7Oyl7aWYoIWMpe2M9YltcInJldHVyblwiXTthOmZvcig7Oyl7bnVsbD09PWM/RShcIjE2MFwiKTp2b2lkIDA7c3dpdGNoKGMudGFnKXtjYXNlIDU6Zj1jLnN0YXRlTm9kZTtnPSExO2JyZWFrIGE7Y2FzZSAzOmY9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2JyZWFrIGE7Y2FzZSA0OmY9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWM9ITB9aWYoNT09PWIudGFnfHw2PT09Yi50YWcpZShiKSxnP0ooZixiLnN0YXRlTm9kZSk6TihmLGIuc3RhdGVOb2RlKTtcbmVsc2UgaWYoND09PWIudGFnP2Y9Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpkKGIpLG51bGwhPT1iLmNoaWxkKXtiLmNoaWxkW1wicmV0dXJuXCJdPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iW1wicmV0dXJuXCJdfHxiW1wicmV0dXJuXCJdPT09YSlyZXR1cm47Yj1iW1wicmV0dXJuXCJdOzQ9PT1iLnRhZyYmKGM9ITEpfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX12YXIgaD1hLmdldFB1YmxpY0luc3RhbmNlLGs9YS5tdXRhdGlvbjthPWEucGVyc2lzdGVuY2U7a3x8KGE/RShcIjIzNVwiKTpFKFwiMjM2XCIpKTt2YXIgcT1rLmNvbW1pdE1vdW50LHY9ay5jb21taXRVcGRhdGUseT1rLnJlc2V0VGV4dENvbnRlbnQsdT1rLmNvbW1pdFRleHRVcGRhdGUsej1rLmFwcGVuZENoaWxkLEc9ay5hcHBlbmRDaGlsZFRvQ29udGFpbmVyLEk9ay5pbnNlcnRCZWZvcmUsTD1rLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuTj1rLnJlbW92ZUNoaWxkLEo9ay5yZW1vdmVDaGlsZEZyb21Db250YWluZXI7cmV0dXJue2NvbW1pdFJlc2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSl7eShhLnN0YXRlTm9kZSl9LGNvbW1pdFBsYWNlbWVudDpmdW5jdGlvbihhKXthOntmb3IodmFyIGI9YVtcInJldHVyblwiXTtudWxsIT09Yjspe2lmKGYoYikpe3ZhciBjPWI7YnJlYWsgYX1iPWJbXCJyZXR1cm5cIl19RShcIjE2MFwiKTtjPXZvaWQgMH12YXIgZD1iPXZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpiPWMuc3RhdGVOb2RlO2Q9ITE7YnJlYWs7Y2FzZSAzOmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2Nhc2UgNDpiPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZD0hMDticmVhaztkZWZhdWx0OkUoXCIxNjFcIil9Yy5lZmZlY3RUYWcmMTYmJih5KGIpLGMuZWZmZWN0VGFnJj0tMTcpO2E6Yjpmb3IoYz1hOzspe2Zvcig7bnVsbD09PWMuc2libGluZzspe2lmKG51bGw9PT1jW1wicmV0dXJuXCJdfHxmKGNbXCJyZXR1cm5cIl0pKXtjPVxubnVsbDticmVhayBhfWM9Y1tcInJldHVyblwiXX1jLnNpYmxpbmdbXCJyZXR1cm5cIl09Y1tcInJldHVyblwiXTtmb3IoYz1jLnNpYmxpbmc7NSE9PWMudGFnJiY2IT09Yy50YWc7KXtpZihjLmVmZmVjdFRhZyYyKWNvbnRpbnVlIGI7aWYobnVsbD09PWMuY2hpbGR8fDQ9PT1jLnRhZyljb250aW51ZSBiO2Vsc2UgYy5jaGlsZFtcInJldHVyblwiXT1jLGM9Yy5jaGlsZH1pZighKGMuZWZmZWN0VGFnJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWZvcih2YXIgZT1hOzspe2lmKDU9PT1lLnRhZ3x8Nj09PWUudGFnKWM/ZD9MKGIsZS5zdGF0ZU5vZGUsYyk6SShiLGUuc3RhdGVOb2RlLGMpOmQ/RyhiLGUuc3RhdGVOb2RlKTp6KGIsZS5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWUudGFnJiZudWxsIT09ZS5jaGlsZCl7ZS5jaGlsZFtcInJldHVyblwiXT1lO2U9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09YSlicmVhaztmb3IoO251bGw9PT1lLnNpYmxpbmc7KXtpZihudWxsPT09ZVtcInJldHVyblwiXXx8ZVtcInJldHVyblwiXT09PVxuYSlyZXR1cm47ZT1lW1wicmV0dXJuXCJdfWUuc2libGluZ1tcInJldHVyblwiXT1lW1wicmV0dXJuXCJdO2U9ZS5zaWJsaW5nfX0sY29tbWl0RGVsZXRpb246ZnVuY3Rpb24oYSl7ZyhhKTthW1wicmV0dXJuXCJdPW51bGw7YS5jaGlsZD1udWxsO2EuYWx0ZXJuYXRlJiYoYS5hbHRlcm5hdGUuY2hpbGQ9bnVsbCxhLmFsdGVybmF0ZVtcInJldHVyblwiXT1udWxsKX0sY29tbWl0V29yazpmdW5jdGlvbihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOmJyZWFrO2Nhc2UgNTp2YXIgYz1iLnN0YXRlTm9kZTtpZihudWxsIT1jKXt2YXIgZD1iLm1lbW9pemVkUHJvcHM7YT1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6ZDt2YXIgZT1iLnR5cGUsZj1iLnVwZGF0ZVF1ZXVlO2IudXBkYXRlUXVldWU9bnVsbDtudWxsIT09ZiYmdihjLGYsZSxhLGQsYil9YnJlYWs7Y2FzZSA2Om51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTYyXCIpOnZvaWQgMDtjPWIubWVtb2l6ZWRQcm9wczt1KGIuc3RhdGVOb2RlLG51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpcbmMsYyk7YnJlYWs7Y2FzZSAzOmJyZWFrO2RlZmF1bHQ6RShcIjE2M1wiKX19LGNvbW1pdExpZmVDeWNsZXM6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjp2YXIgYz1iLnN0YXRlTm9kZTtpZihiLmVmZmVjdFRhZyY0KWlmKG51bGw9PT1hKWMucHJvcHM9Yi5tZW1vaXplZFByb3BzLGMuc3RhdGU9Yi5tZW1vaXplZFN0YXRlLGMuY29tcG9uZW50RGlkTW91bnQoKTtlbHNle3ZhciBkPWEubWVtb2l6ZWRQcm9wczthPWEubWVtb2l6ZWRTdGF0ZTtjLnByb3BzPWIubWVtb2l6ZWRQcm9wcztjLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZTtjLmNvbXBvbmVudERpZFVwZGF0ZShkLGEpfWI9Yi51cGRhdGVRdWV1ZTtudWxsIT09YiYmS2UoYixjKTticmVhaztjYXNlIDM6Yz1iLnVwZGF0ZVF1ZXVlO251bGwhPT1jJiZLZShjLG51bGwhPT1iLmNoaWxkP2IuY2hpbGQuc3RhdGVOb2RlOm51bGwpO2JyZWFrO2Nhc2UgNTpjPWIuc3RhdGVOb2RlO251bGw9PT1hJiZiLmVmZmVjdFRhZyY0JiZxKGMsXG5iLnR5cGUsYi5tZW1vaXplZFByb3BzLGIpO2JyZWFrO2Nhc2UgNjpicmVhaztjYXNlIDQ6YnJlYWs7ZGVmYXVsdDpFKFwiMTYzXCIpfX0sY29tbWl0QXR0YWNoUmVmOmZ1bmN0aW9uKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKXt2YXIgYz1hLnN0YXRlTm9kZTtzd2l0Y2goYS50YWcpe2Nhc2UgNTpiKGgoYykpO2JyZWFrO2RlZmF1bHQ6YihjKX19fSxjb21taXREZXRhY2hSZWY6ZnVuY3Rpb24oYSl7YT1hLnJlZjtudWxsIT09YSYmYShudWxsKX19fXZhciBnZj17fTtcbmZ1bmN0aW9uIGhmKGEpe2Z1bmN0aW9uIGIoYSl7YT09PWdmP0UoXCIxNzRcIik6dm9pZCAwO3JldHVybiBhfXZhciBjPWEuZ2V0Q2hpbGRIb3N0Q29udGV4dCxkPWEuZ2V0Um9vdEhvc3RDb250ZXh0LGU9e2N1cnJlbnQ6Z2Z9LGY9e2N1cnJlbnQ6Z2Z9LGc9e2N1cnJlbnQ6Z2Z9O3JldHVybntnZXRIb3N0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiBiKGUuY3VycmVudCl9LGdldFJvb3RIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKCl7cmV0dXJuIGIoZy5jdXJyZW50KX0scG9wSG9zdENvbnRhaW5lcjpmdW5jdGlvbihhKXtWKGUsYSk7VihmLGEpO1YoZyxhKX0scG9wSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7Zi5jdXJyZW50PT09YSYmKFYoZSxhKSxWKGYsYSkpfSxwdXNoSG9zdENvbnRhaW5lcjpmdW5jdGlvbihhLGIpe1coZyxiLGEpO2I9ZChiKTtXKGYsYSxhKTtXKGUsYixhKX0scHVzaEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe3ZhciBkPWIoZy5jdXJyZW50KSxoPWIoZS5jdXJyZW50KTtcbmQ9YyhoLGEudHlwZSxkKTtoIT09ZCYmKFcoZixhLGEpLFcoZSxkLGEpKX0scmVzZXRIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKCl7ZS5jdXJyZW50PWdmO2cuY3VycmVudD1nZn19fVxuZnVuY3Rpb24gamYoYSl7ZnVuY3Rpb24gYihhLGIpe3ZhciBjPW5ldyBZKDUsbnVsbCwwKTtjLnR5cGU9XCJERUxFVEVEXCI7Yy5zdGF0ZU5vZGU9YjtjW1wicmV0dXJuXCJdPWE7Yy5lZmZlY3RUYWc9ODtudWxsIT09YS5sYXN0RWZmZWN0PyhhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1jLGEubGFzdEVmZmVjdD1jKTphLmZpcnN0RWZmZWN0PWEubGFzdEVmZmVjdD1jfWZ1bmN0aW9uIGMoYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpyZXR1cm4gYj1mKGIsYS50eXBlLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7Y2FzZSA2OnJldHVybiBiPWcoYixhLnBlbmRpbmdQcm9wcyksbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGQoYSl7Zm9yKGE9YVtcInJldHVyblwiXTtudWxsIT09YSYmNSE9PWEudGFnJiYzIT09YS50YWc7KWE9YVtcInJldHVyblwiXTt5PWF9dmFyIGU9YS5zaG91bGRTZXRUZXh0Q29udGVudDtcbmE9YS5oeWRyYXRpb247aWYoIWEpcmV0dXJue2VudGVySHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe30sdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oKXtFKFwiMTc1XCIpfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbigpe0UoXCIxNzZcIil9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9fTt2YXIgZj1hLmNhbkh5ZHJhdGVJbnN0YW5jZSxnPWEuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxoPWEuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLGs9YS5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxxPWEuaHlkcmF0ZUluc3RhbmNlLHY9YS5oeWRyYXRlVGV4dEluc3RhbmNlLHk9bnVsbCx1PW51bGwsej0hMTtyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbihhKXt1PVxuayhhLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTt5PWE7cmV0dXJuIHo9ITB9LHJlc2V0SHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXt1PXk9bnVsbDt6PSExfSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbihhKXtpZih6KXt2YXIgZD11O2lmKGQpe2lmKCFjKGEsZCkpe2Q9aChkKTtpZighZHx8IWMoYSxkKSl7YS5lZmZlY3RUYWd8PTI7ej0hMTt5PWE7cmV0dXJufWIoeSx1KX15PWE7dT1rKGQpfWVsc2UgYS5lZmZlY3RUYWd8PTIsej0hMSx5PWF9fSxwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjKXtiPXEoYS5zdGF0ZU5vZGUsYS50eXBlLGEubWVtb2l6ZWRQcm9wcyxiLGMsYSk7YS51cGRhdGVRdWV1ZT1iO3JldHVybiBudWxsIT09Yj8hMDohMX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIHYoYS5zdGF0ZU5vZGUsYS5tZW1vaXplZFByb3BzLGEpfSxwb3BIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbihhKXtpZihhIT09XG55KXJldHVybiExO2lmKCF6KXJldHVybiBkKGEpLHo9ITAsITE7dmFyIGM9YS50eXBlO2lmKDUhPT1hLnRhZ3x8XCJoZWFkXCIhPT1jJiZcImJvZHlcIiE9PWMmJiFlKGMsYS5tZW1vaXplZFByb3BzKSlmb3IoYz11O2M7KWIoYSxjKSxjPWgoYyk7ZChhKTt1PXk/aChhLnN0YXRlTm9kZSk6bnVsbDtyZXR1cm4hMH19fVxuZnVuY3Rpb24ga2YoYSl7ZnVuY3Rpb24gYihhKXtRYj1qYT0hMDt2YXIgYj1hLnN0YXRlTm9kZTtiLmN1cnJlbnQ9PT1hP0UoXCIxNzdcIik6dm9pZCAwO2IuaXNSZWFkeUZvckNvbW1pdD0hMTtpZC5jdXJyZW50PW51bGw7aWYoMTxhLmVmZmVjdFRhZylpZihudWxsIT09YS5sYXN0RWZmZWN0KXthLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hO3ZhciBjPWEuZmlyc3RFZmZlY3R9ZWxzZSBjPWE7ZWxzZSBjPWEuZmlyc3RFZmZlY3Q7eWcoKTtmb3IodD1jO251bGwhPT10Oyl7dmFyIGQ9ITEsZT12b2lkIDA7dHJ5e2Zvcig7bnVsbCE9PXQ7KXt2YXIgZj10LmVmZmVjdFRhZztmJjE2JiZ6Zyh0KTtpZihmJjEyOCl7dmFyIGc9dC5hbHRlcm5hdGU7bnVsbCE9PWcmJkFnKGcpfXN3aXRjaChmJi0yNDIpe2Nhc2UgMjpOZSh0KTt0LmVmZmVjdFRhZyY9LTM7YnJlYWs7Y2FzZSA2Ok5lKHQpO3QuZWZmZWN0VGFnJj0tMztPZSh0LmFsdGVybmF0ZSx0KTticmVhaztjYXNlIDQ6T2UodC5hbHRlcm5hdGUsXG50KTticmVhaztjYXNlIDg6U2M9ITAsQmcodCksU2M9ITF9dD10Lm5leHRFZmZlY3R9fWNhdGNoKFRjKXtkPSEwLGU9VGN9ZCYmKG51bGw9PT10P0UoXCIxNzhcIik6dm9pZCAwLGgodCxlKSxudWxsIT09dCYmKHQ9dC5uZXh0RWZmZWN0KSl9Q2coKTtiLmN1cnJlbnQ9YTtmb3IodD1jO251bGwhPT10Oyl7Yz0hMTtkPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09dDspe3ZhciBrPXQuZWZmZWN0VGFnO2smMzYmJkRnKHQuYWx0ZXJuYXRlLHQpO2smMTI4JiZFZyh0KTtpZihrJjY0KXN3aXRjaChlPXQsZj12b2lkIDAsbnVsbCE9PVImJihmPVIuZ2V0KGUpLFJbXCJkZWxldGVcIl0oZSksbnVsbD09ZiYmbnVsbCE9PWUuYWx0ZXJuYXRlJiYoZT1lLmFsdGVybmF0ZSxmPVIuZ2V0KGUpLFJbXCJkZWxldGVcIl0oZSkpKSxudWxsPT1mP0UoXCIxODRcIik6dm9pZCAwLGUudGFnKXtjYXNlIDI6ZS5zdGF0ZU5vZGUuY29tcG9uZW50RGlkQ2F0Y2goZi5lcnJvcix7Y29tcG9uZW50U3RhY2s6Zi5jb21wb25lbnRTdGFja30pO1xuYnJlYWs7Y2FzZSAzOm51bGw9PT1jYSYmKGNhPWYuZXJyb3IpO2JyZWFrO2RlZmF1bHQ6RShcIjE1N1wiKX12YXIgUWM9dC5uZXh0RWZmZWN0O3QubmV4dEVmZmVjdD1udWxsO3Q9UWN9fWNhdGNoKFRjKXtjPSEwLGQ9VGN9YyYmKG51bGw9PT10P0UoXCIxNzhcIik6dm9pZCAwLGgodCxkKSxudWxsIT09dCYmKHQ9dC5uZXh0RWZmZWN0KSl9amE9UWI9ITE7XCJmdW5jdGlvblwiPT09dHlwZW9mIERlJiZEZShhLnN0YXRlTm9kZSk7aGEmJihoYS5mb3JFYWNoKEcpLGhhPW51bGwpO251bGwhPT1jYSYmKGE9Y2EsY2E9bnVsbCxPYihhKSk7Yj1iLmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7MD09PWImJihxYT1SPW51bGwpO3JldHVybiBifWZ1bmN0aW9uIGMoYSl7Zm9yKDs7KXt2YXIgYj1GZyhhLmFsdGVybmF0ZSxhLEgpLGM9YVtcInJldHVyblwiXSxkPWEuc2libGluZzt2YXIgZT1hO2lmKDIxNDc0ODM2NDc9PT1IfHwyMTQ3NDgzNjQ3IT09ZS5leHBpcmF0aW9uVGltZSl7aWYoMiE9PWUudGFnJiYzIT09XG5lLnRhZyl2YXIgZj0wO2Vsc2UgZj1lLnVwZGF0ZVF1ZXVlLGY9bnVsbD09PWY/MDpmLmV4cGlyYXRpb25UaW1lO2Zvcih2YXIgZz1lLmNoaWxkO251bGwhPT1nOykwIT09Zy5leHBpcmF0aW9uVGltZSYmKDA9PT1mfHxmPmcuZXhwaXJhdGlvblRpbWUpJiYoZj1nLmV4cGlyYXRpb25UaW1lKSxnPWcuc2libGluZztlLmV4cGlyYXRpb25UaW1lPWZ9aWYobnVsbCE9PWIpcmV0dXJuIGI7bnVsbCE9PWMmJihudWxsPT09Yy5maXJzdEVmZmVjdCYmKGMuZmlyc3RFZmZlY3Q9YS5maXJzdEVmZmVjdCksbnVsbCE9PWEubGFzdEVmZmVjdCYmKG51bGwhPT1jLmxhc3RFZmZlY3QmJihjLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxjLmxhc3RFZmZlY3Q9YS5sYXN0RWZmZWN0KSwxPGEuZWZmZWN0VGFnJiYobnVsbCE9PWMubGFzdEVmZmVjdD9jLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hOmMuZmlyc3RFZmZlY3Q9YSxjLmxhc3RFZmZlY3Q9YSkpO2lmKG51bGwhPT1kKXJldHVybiBkO1xuaWYobnVsbCE9PWMpYT1jO2Vsc2V7YS5zdGF0ZU5vZGUuaXNSZWFkeUZvckNvbW1pdD0hMDticmVha319cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhKXt2YXIgYj1yZyhhLmFsdGVybmF0ZSxhLEgpO251bGw9PT1iJiYoYj1jKGEpKTtpZC5jdXJyZW50PW51bGw7cmV0dXJuIGJ9ZnVuY3Rpb24gZShhKXt2YXIgYj1HZyhhLmFsdGVybmF0ZSxhLEgpO251bGw9PT1iJiYoYj1jKGEpKTtpZC5jdXJyZW50PW51bGw7cmV0dXJuIGJ9ZnVuY3Rpb24gZihhKXtpZihudWxsIT09Uil7aWYoISgwPT09SHx8SD5hKSlpZihIPD1VYylmb3IoO251bGwhPT1GOylGPWsoRik/ZShGKTpkKEYpO2Vsc2UgZm9yKDtudWxsIT09RiYmIUEoKTspRj1rKEYpP2UoRik6ZChGKX1lbHNlIGlmKCEoMD09PUh8fEg+YSkpaWYoSDw9VWMpZm9yKDtudWxsIT09RjspRj1kKEYpO2Vsc2UgZm9yKDtudWxsIT09RiYmIUEoKTspRj1kKEYpfWZ1bmN0aW9uIGcoYSxiKXtqYT9FKFwiMjQzXCIpOnZvaWQgMDtqYT0hMDthLmlzUmVhZHlGb3JDb21taXQ9XG4hMTtpZihhIT09cmF8fGIhPT1IfHxudWxsPT09Ril7Zm9yKDstMTxoZTspZ2VbaGVdPW51bGwsaGUtLTtqZT1EO2llLmN1cnJlbnQ9RDtYLmN1cnJlbnQ9ITE7eCgpO3JhPWE7SD1iO0Y9c2UocmEuY3VycmVudCxudWxsLGIpfXZhciBjPSExLGQ9bnVsbDt0cnl7ZihiKX1jYXRjaChSYyl7Yz0hMCxkPVJjfWZvcig7Yzspe2lmKGViKXtjYT1kO2JyZWFrfXZhciBnPUY7aWYobnVsbD09PWcpZWI9ITA7ZWxzZXt2YXIgaz1oKGcsZCk7bnVsbD09PWs/RShcIjE4M1wiKTp2b2lkIDA7aWYoIWViKXt0cnl7Yz1rO2Q9Yjtmb3Ioaz1jO251bGwhPT1nOyl7c3dpdGNoKGcudGFnKXtjYXNlIDI6bmUoZyk7YnJlYWs7Y2FzZSA1OnFnKGcpO2JyZWFrO2Nhc2UgMzpwKGcpO2JyZWFrO2Nhc2UgNDpwKGcpfWlmKGc9PT1rfHxnLmFsdGVybmF0ZT09PWspYnJlYWs7Zz1nW1wicmV0dXJuXCJdfUY9ZShjKTtmKGQpfWNhdGNoKFJjKXtjPSEwO2Q9UmM7Y29udGludWV9YnJlYWt9fX1iPWNhO2ViPWphPSExO2NhPVxubnVsbDtudWxsIT09YiYmT2IoYik7cmV0dXJuIGEuaXNSZWFkeUZvckNvbW1pdD9hLmN1cnJlbnQuYWx0ZXJuYXRlOm51bGx9ZnVuY3Rpb24gaChhLGIpe3ZhciBjPWlkLmN1cnJlbnQ9bnVsbCxkPSExLGU9ITEsZj1udWxsO2lmKDM9PT1hLnRhZyljPWEscShhKSYmKGViPSEwKTtlbHNlIGZvcih2YXIgZz1hW1wicmV0dXJuXCJdO251bGwhPT1nJiZudWxsPT09YzspezI9PT1nLnRhZz9cImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5zdGF0ZU5vZGUuY29tcG9uZW50RGlkQ2F0Y2gmJihkPSEwLGY9amQoZyksYz1nLGU9ITApOjM9PT1nLnRhZyYmKGM9Zyk7aWYocShnKSl7aWYoU2N8fG51bGwhPT1oYSYmKGhhLmhhcyhnKXx8bnVsbCE9PWcuYWx0ZXJuYXRlJiZoYS5oYXMoZy5hbHRlcm5hdGUpKSlyZXR1cm4gbnVsbDtjPW51bGw7ZT0hMX1nPWdbXCJyZXR1cm5cIl19aWYobnVsbCE9PWMpe251bGw9PT1xYSYmKHFhPW5ldyBTZXQpO3FhLmFkZChjKTt2YXIgaD1cIlwiO2c9YTtkb3thOnN3aXRjaChnLnRhZyl7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6Y2FzZSA1OnZhciBrPVxuZy5fZGVidWdPd25lcixRYz1nLl9kZWJ1Z1NvdXJjZTt2YXIgbT1qZChnKTt2YXIgbj1udWxsO2smJihuPWpkKGspKTtrPVFjO209XCJcXG4gICAgaW4gXCIrKG18fFwiVW5rbm93blwiKSsoaz9cIiAoYXQgXCIray5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLFwiXCIpK1wiOlwiK2subGluZU51bWJlcitcIilcIjpuP1wiIChjcmVhdGVkIGJ5IFwiK24rXCIpXCI6XCJcIik7YnJlYWsgYTtkZWZhdWx0Om09XCJcIn1oKz1tO2c9Z1tcInJldHVyblwiXX13aGlsZShnKTtnPWg7YT1qZChhKTtudWxsPT09UiYmKFI9bmV3IE1hcCk7Yj17Y29tcG9uZW50TmFtZTphLGNvbXBvbmVudFN0YWNrOmcsZXJyb3I6YixlcnJvckJvdW5kYXJ5OmQ/Yy5zdGF0ZU5vZGU6bnVsbCxlcnJvckJvdW5kYXJ5Rm91bmQ6ZCxlcnJvckJvdW5kYXJ5TmFtZTpmLHdpbGxSZXRyeTplfTtSLnNldChjLGIpO3RyeXt2YXIgcD1iLmVycm9yO3AmJnAuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZ3x8Y29uc29sZS5lcnJvcihwKX1jYXRjaChWYyl7VmMmJlxuVmMuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZ3x8Y29uc29sZS5lcnJvcihWYyl9UWI/KG51bGw9PT1oYSYmKGhhPW5ldyBTZXQpLGhhLmFkZChjKSk6RyhjKTtyZXR1cm4gY31udWxsPT09Y2EmJihjYT1iKTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBrKGEpe3JldHVybiBudWxsIT09UiYmKFIuaGFzKGEpfHxudWxsIT09YS5hbHRlcm5hdGUmJlIuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gcShhKXtyZXR1cm4gbnVsbCE9PXFhJiYocWEuaGFzKGEpfHxudWxsIT09YS5hbHRlcm5hdGUmJnFhLmhhcyhhLmFsdGVybmF0ZSkpfWZ1bmN0aW9uIHYoKXtyZXR1cm4gMjAqKCgoSSgpKzEwMCkvMjB8MCkrMSl9ZnVuY3Rpb24geShhKXtyZXR1cm4gMCE9PWthP2thOmphP1FiPzE6SDohSGd8fGEuaW50ZXJuYWxDb250ZXh0VGFnJjE/digpOjF9ZnVuY3Rpb24gdShhLGIpe3JldHVybiB6KGEsYiwhMSl9ZnVuY3Rpb24geihhLGIpe2Zvcig7bnVsbCE9PWE7KXtpZigwPT09YS5leHBpcmF0aW9uVGltZXx8XG5hLmV4cGlyYXRpb25UaW1lPmIpYS5leHBpcmF0aW9uVGltZT1iO251bGwhPT1hLmFsdGVybmF0ZSYmKDA9PT1hLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZXx8YS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWU+YikmJihhLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT1iKTtpZihudWxsPT09YVtcInJldHVyblwiXSlpZigzPT09YS50YWcpe3ZhciBjPWEuc3RhdGVOb2RlOyFqYSYmYz09PXJhJiZiPEgmJihGPXJhPW51bGwsSD0wKTt2YXIgZD1jLGU9YjtSYj5JZyYmRShcIjE4NVwiKTtpZihudWxsPT09ZC5uZXh0U2NoZWR1bGVkUm9vdClkLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWUsbnVsbD09PU8/KHNhPU89ZCxkLm5leHRTY2hlZHVsZWRSb290PWQpOihPPU8ubmV4dFNjaGVkdWxlZFJvb3Q9ZCxPLm5leHRTY2hlZHVsZWRSb290PXNhKTtlbHNle3ZhciBmPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWZ8fGU8ZilkLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWV9RmF8fChsYT9cblNiJiYobWE9ZCxuYT0xLG0obWEsbmEpKToxPT09ZT93KDEsbnVsbCk6TChlKSk7IWphJiZjPT09cmEmJmI8SCYmKEY9cmE9bnVsbCxIPTApfWVsc2UgYnJlYWs7YT1hW1wicmV0dXJuXCJdfX1mdW5jdGlvbiBHKGEpe3ooYSwxLCEwKX1mdW5jdGlvbiBJKCl7cmV0dXJuIFVjPSgoV2MoKS1QZSkvMTB8MCkrMn1mdW5jdGlvbiBMKGEpe2lmKDAhPT1UYil7aWYoYT5UYilyZXR1cm47SmcoWGMpfXZhciBiPVdjKCktUGU7VGI9YTtYYz1LZyhKLHt0aW1lb3V0OjEwKihhLTIpLWJ9KX1mdW5jdGlvbiBOKCl7dmFyIGE9MCxiPW51bGw7aWYobnVsbCE9PU8pZm9yKHZhciBjPU8sZD1zYTtudWxsIT09ZDspe3ZhciBlPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWUpe251bGw9PT1jfHxudWxsPT09Tz9FKFwiMjQ0XCIpOnZvaWQgMDtpZihkPT09ZC5uZXh0U2NoZWR1bGVkUm9vdCl7c2E9Tz1kLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBpZihkPT09c2Epc2E9ZT1kLm5leHRTY2hlZHVsZWRSb290LFxuTy5uZXh0U2NoZWR1bGVkUm9vdD1lLGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtlbHNlIGlmKGQ9PT1PKXtPPWM7Ty5uZXh0U2NoZWR1bGVkUm9vdD1zYTtkLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBjLm5leHRTY2hlZHVsZWRSb290PWQubmV4dFNjaGVkdWxlZFJvb3QsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Q9Yy5uZXh0U2NoZWR1bGVkUm9vdH1lbHNle2lmKDA9PT1hfHxlPGEpYT1lLGI9ZDtpZihkPT09TylicmVhaztjPWQ7ZD1kLm5leHRTY2hlZHVsZWRSb290fX1jPW1hO251bGwhPT1jJiZjPT09Yj9SYisrOlJiPTA7bWE9YjtuYT1hfWZ1bmN0aW9uIEooYSl7dygwLGEpfWZ1bmN0aW9uIHcoYSxiKXtmYj1iO2ZvcihOKCk7bnVsbCE9PW1hJiYwIT09bmEmJigwPT09YXx8bmE8PWEpJiYhWWM7KW0obWEsbmEpLE4oKTtudWxsIT09ZmImJihUYj0wLFhjPS0xKTswIT09bmEmJkwobmEpO2ZiPW51bGw7WWM9ITE7UmI9MDtpZihVYil0aHJvdyBhPVpjLFpjPVxubnVsbCxVYj0hMSxhO31mdW5jdGlvbiBtKGEsYyl7RmE/RShcIjI0NVwiKTp2b2lkIDA7RmE9ITA7aWYoYzw9SSgpKXt2YXIgZD1hLmZpbmlzaGVkV29yaztudWxsIT09ZD8oYS5maW5pc2hlZFdvcms9bnVsbCxhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpOihhLmZpbmlzaGVkV29yaz1udWxsLGQ9ZyhhLGMpLG51bGwhPT1kJiYoYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKSl9ZWxzZSBkPWEuZmluaXNoZWRXb3JrLG51bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1nKGEsYyksbnVsbCE9PWQmJihBKCk/YS5maW5pc2hlZFdvcms9ZDphLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpKTtGYT0hMX1mdW5jdGlvbiBBKCl7cmV0dXJuIG51bGw9PT1mYnx8ZmIudGltZVJlbWFpbmluZygpPkxnPyExOlljPSEwfWZ1bmN0aW9uIE9iKGEpe251bGw9PT1tYT9FKFwiMjQ2XCIpOlxudm9pZCAwO21hLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPTA7VWJ8fChVYj0hMCxaYz1hKX12YXIgcj1oZihhKSxuPWpmKGEpLHA9ci5wb3BIb3N0Q29udGFpbmVyLHFnPXIucG9wSG9zdENvbnRleHQseD1yLnJlc2V0SG9zdENvbnRhaW5lcixNZT1kZihhLHIsbix1LHkpLHJnPU1lLmJlZ2luV29yayxHZz1NZS5iZWdpbkZhaWxlZFdvcmssRmc9ZWYoYSxyLG4pLmNvbXBsZXRlV29yaztyPWZmKGEsaCk7dmFyIHpnPXIuY29tbWl0UmVzZXRUZXh0Q29udGVudCxOZT1yLmNvbW1pdFBsYWNlbWVudCxCZz1yLmNvbW1pdERlbGV0aW9uLE9lPXIuY29tbWl0V29yayxEZz1yLmNvbW1pdExpZmVDeWNsZXMsRWc9ci5jb21taXRBdHRhY2hSZWYsQWc9ci5jb21taXREZXRhY2hSZWYsV2M9YS5ub3csS2c9YS5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssSmc9YS5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLEhnPWEudXNlU3luY1NjaGVkdWxpbmcseWc9YS5wcmVwYXJlRm9yQ29tbWl0LENnPWEucmVzZXRBZnRlckNvbW1pdCxcblBlPVdjKCksVWM9MixrYT0wLGphPSExLEY9bnVsbCxyYT1udWxsLEg9MCx0PW51bGwsUj1udWxsLHFhPW51bGwsaGE9bnVsbCxjYT1udWxsLGViPSExLFFiPSExLFNjPSExLHNhPW51bGwsTz1udWxsLFRiPTAsWGM9LTEsRmE9ITEsbWE9bnVsbCxuYT0wLFljPSExLFViPSExLFpjPW51bGwsZmI9bnVsbCxsYT0hMSxTYj0hMSxJZz0xRTMsUmI9MCxMZz0xO3JldHVybntjb21wdXRlQXN5bmNFeHBpcmF0aW9uOnYsY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcjp5LHNjaGVkdWxlV29yazp1LGJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEsYil7dmFyIGM9bGE7bGE9ITA7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7KGxhPWMpfHxGYXx8dygxLG51bGwpfX0sdW5iYXRjaGVkVXBkYXRlczpmdW5jdGlvbihhKXtpZihsYSYmIVNiKXtTYj0hMDt0cnl7cmV0dXJuIGEoKX1maW5hbGx5e1NiPSExfX1yZXR1cm4gYSgpfSxmbHVzaFN5bmM6ZnVuY3Rpb24oYSl7dmFyIGI9bGE7bGE9ITA7dHJ5e2E6e3ZhciBjPVxua2E7a2E9MTt0cnl7dmFyIGQ9YSgpO2JyZWFrIGF9ZmluYWxseXtrYT1jfWQ9dm9pZCAwfXJldHVybiBkfWZpbmFsbHl7bGE9YixGYT9FKFwiMTg3XCIpOnZvaWQgMCx3KDEsbnVsbCl9fSxkZWZlcnJlZFVwZGF0ZXM6ZnVuY3Rpb24oYSl7dmFyIGI9a2E7a2E9digpO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7a2E9Yn19fX1cbmZ1bmN0aW9uIGxmKGEpe2Z1bmN0aW9uIGIoYSl7YT1vZChhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX12YXIgYz1hLmdldFB1YmxpY0luc3RhbmNlO2E9a2YoYSk7dmFyIGQ9YS5jb21wdXRlQXN5bmNFeHBpcmF0aW9uLGU9YS5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLGY9YS5zY2hlZHVsZVdvcms7cmV0dXJue2NyZWF0ZUNvbnRhaW5lcjpmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBZKDMsbnVsbCwwKTthPXtjdXJyZW50OmMsY29udGFpbmVySW5mbzphLHBlbmRpbmdDaGlsZHJlbjpudWxsLHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lOjAsaXNSZWFkeUZvckNvbW1pdDohMSxmaW5pc2hlZFdvcms6bnVsbCxjb250ZXh0Om51bGwscGVuZGluZ0NvbnRleHQ6bnVsbCxoeWRyYXRlOmIsbmV4dFNjaGVkdWxlZFJvb3Q6bnVsbH07cmV0dXJuIGMuc3RhdGVOb2RlPWF9LHVwZGF0ZUNvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxxKXt2YXIgZz1iLmN1cnJlbnQ7aWYoYyl7Yz1cbmMuX3JlYWN0SW50ZXJuYWxGaWJlcjt2YXIgaDtiOnsyPT09a2QoYykmJjI9PT1jLnRhZz92b2lkIDA6RShcIjE3MFwiKTtmb3IoaD1jOzMhPT1oLnRhZzspe2lmKGxlKGgpKXtoPWguc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O2JyZWFrIGJ9KGg9aFtcInJldHVyblwiXSk/dm9pZCAwOkUoXCIxNzFcIil9aD1oLnN0YXRlTm9kZS5jb250ZXh0fWM9bGUoYyk/cGUoYyxoKTpofWVsc2UgYz1EO251bGw9PT1iLmNvbnRleHQ/Yi5jb250ZXh0PWM6Yi5wZW5kaW5nQ29udGV4dD1jO2I9cTtiPXZvaWQgMD09PWI/bnVsbDpiO3E9bnVsbCE9YSYmbnVsbCE9YS50eXBlJiZudWxsIT1hLnR5cGUucHJvdG90eXBlJiYhMD09PWEudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50P2QoKTplKGcpO0hlKGcse2V4cGlyYXRpb25UaW1lOnEscGFydGlhbFN0YXRlOntlbGVtZW50OmF9LGNhbGxiYWNrOmIsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiExLFxubmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7ZihnLHEpfSxiYXRjaGVkVXBkYXRlczphLmJhdGNoZWRVcGRhdGVzLHVuYmF0Y2hlZFVwZGF0ZXM6YS51bmJhdGNoZWRVcGRhdGVzLGRlZmVycmVkVXBkYXRlczphLmRlZmVycmVkVXBkYXRlcyxmbHVzaFN5bmM6YS5mbHVzaFN5bmMsZ2V0UHVibGljUm9vdEluc3RhbmNlOmZ1bmN0aW9uKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBjKGEuY2hpbGQuc3RhdGVOb2RlKTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19LGZpbmRIb3N0SW5zdGFuY2U6YixmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczpmdW5jdGlvbihhKXthPXBkKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfSxpbmplY3RJbnRvRGV2VG9vbHM6ZnVuY3Rpb24oYSl7dmFyIGM9YS5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtyZXR1cm4gQ2UoQih7fSxcbmEse2ZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOmZ1bmN0aW9uKGEpe3JldHVybiBiKGEpfSxmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gYz9jKGEpOm51bGx9fSkpfX19dmFyIG1mPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6bGZ9KSxuZj1tZiYmbGZ8fG1mLG9mPW5mW1wiZGVmYXVsdFwiXT9uZltcImRlZmF1bHRcIl06bmY7ZnVuY3Rpb24gcGYoYSxiLGMpe3ZhciBkPTM8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpudWxsO3JldHVybnskJHR5cGVvZjpVZSxrZXk6bnVsbD09ZD9udWxsOlwiXCIrZCxjaGlsZHJlbjphLGNvbnRhaW5lckluZm86YixpbXBsZW1lbnRhdGlvbjpjfX12YXIgcWY9XCJvYmplY3RcIj09PXR5cGVvZiBwZXJmb3JtYW5jZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHBlcmZvcm1hbmNlLm5vdyxyZj12b2lkIDA7cmY9cWY/ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9OmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9O1xudmFyIHNmPXZvaWQgMCx0Zj12b2lkIDA7XG5pZihsLmNhblVzZURPTSlpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFja3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIGNhbmNlbElkbGVDYWxsYmFjayl7dmFyIHVmPW51bGwsdmY9ITEsd2Y9LTEseGY9ITEseWY9MCx6Zj0zMyxBZj0zMyxCZjtCZj1xZj97ZGlkVGltZW91dDohMSx0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7dmFyIGE9eWYtcGVyZm9ybWFuY2Uubm93KCk7cmV0dXJuIDA8YT9hOjB9fTp7ZGlkVGltZW91dDohMSx0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7dmFyIGE9eWYtRGF0ZS5ub3coKTtyZXR1cm4gMDxhP2E6MH19O3ZhciBDZj1cIl9fcmVhY3RJZGxlQ2FsbGJhY2skXCIrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZnVuY3Rpb24oYSl7aWYoYS5zb3VyY2U9PT13aW5kb3cmJmEuZGF0YT09PUNmKXt2Zj0hMTthPXJmKCk7aWYoMD49eWYtYSlpZigtMSE9PXdmJiZ3Zjw9XG5hKUJmLmRpZFRpbWVvdXQ9ITA7ZWxzZXt4Znx8KHhmPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShEZikpO3JldHVybn1lbHNlIEJmLmRpZFRpbWVvdXQ9ITE7d2Y9LTE7YT11Zjt1Zj1udWxsO251bGwhPT1hJiZhKEJmKX19LCExKTt2YXIgRGY9ZnVuY3Rpb24oYSl7eGY9ITE7dmFyIGI9YS15ZitBZjtiPEFmJiZ6ZjxBZj8oOD5iJiYoYj04KSxBZj1iPHpmP3pmOmIpOnpmPWI7eWY9YStBZjt2Znx8KHZmPSEwLHdpbmRvdy5wb3N0TWVzc2FnZShDZixcIipcIikpfTtzZj1mdW5jdGlvbihhLGIpe3VmPWE7bnVsbCE9YiYmXCJudW1iZXJcIj09PXR5cGVvZiBiLnRpbWVvdXQmJih3Zj1yZigpK2IudGltZW91dCk7eGZ8fCh4Zj0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoRGYpKTtyZXR1cm4gMH07dGY9ZnVuY3Rpb24oKXt1Zj1udWxsO3ZmPSExO3dmPS0xfX1lbHNlIHNmPXdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrLHRmPXdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2s7ZWxzZSBzZj1mdW5jdGlvbihhKXtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe2Eoe3RpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXtyZXR1cm4gSW5maW5pdHl9fSl9KX0sXG50Zj1mdW5jdGlvbihhKXtjbGVhclRpbWVvdXQoYSl9O3ZhciBFZj0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8sRmY9e30sR2Y9e307XG5mdW5jdGlvbiBIZihhKXtpZihHZi5oYXNPd25Qcm9wZXJ0eShhKSlyZXR1cm4hMDtpZihGZi5oYXNPd25Qcm9wZXJ0eShhKSlyZXR1cm4hMTtpZihFZi50ZXN0KGEpKXJldHVybiBHZlthXT0hMDtGZlthXT0hMDtyZXR1cm4hMX1cbmZ1bmN0aW9uIElmKGEsYixjKXt2YXIgZD13YShiKTtpZihkJiZ2YShiLGMpKXt2YXIgZT1kLm11dGF0aW9uTWV0aG9kO2U/ZShhLGMpOm51bGw9PWN8fGQuaGFzQm9vbGVhblZhbHVlJiYhY3x8ZC5oYXNOdW1lcmljVmFsdWUmJmlzTmFOKGMpfHxkLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlJiYxPmN8fGQuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSYmITE9PT1jP0pmKGEsYik6ZC5tdXN0VXNlUHJvcGVydHk/YVtkLnByb3BlcnR5TmFtZV09YzooYj1kLmF0dHJpYnV0ZU5hbWUsKGU9ZC5hdHRyaWJ1dGVOYW1lc3BhY2UpP2Euc2V0QXR0cmlidXRlTlMoZSxiLFwiXCIrYyk6ZC5oYXNCb29sZWFuVmFsdWV8fGQuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSYmITA9PT1jP2Euc2V0QXR0cmlidXRlKGIsXCJcIik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKX1lbHNlIEtmKGEsYix2YShiLGMpP2M6bnVsbCl9XG5mdW5jdGlvbiBLZihhLGIsYyl7SGYoYikmJihudWxsPT1jP2EucmVtb3ZlQXR0cmlidXRlKGIpOmEuc2V0QXR0cmlidXRlKGIsXCJcIitjKSl9ZnVuY3Rpb24gSmYoYSxiKXt2YXIgYz13YShiKTtjPyhiPWMubXV0YXRpb25NZXRob2QpP2IoYSx2b2lkIDApOmMubXVzdFVzZVByb3BlcnR5P2FbYy5wcm9wZXJ0eU5hbWVdPWMuaGFzQm9vbGVhblZhbHVlPyExOlwiXCI6YS5yZW1vdmVBdHRyaWJ1dGUoYy5hdHRyaWJ1dGVOYW1lKTphLnJlbW92ZUF0dHJpYnV0ZShiKX1cbmZ1bmN0aW9uIExmKGEsYil7dmFyIGM9Yi52YWx1ZSxkPWIuY2hlY2tlZDtyZXR1cm4gQih7dHlwZTp2b2lkIDAsc3RlcDp2b2lkIDAsbWluOnZvaWQgMCxtYXg6dm9pZCAwfSxiLHtkZWZhdWx0Q2hlY2tlZDp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCx2YWx1ZTpudWxsIT1jP2M6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxjaGVja2VkOm51bGwhPWQ/ZDphLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWR9KX1mdW5jdGlvbiBNZihhLGIpe3ZhciBjPWIuZGVmYXVsdFZhbHVlO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbENoZWNrZWQ6bnVsbCE9Yi5jaGVja2VkP2IuY2hlY2tlZDpiLmRlZmF1bHRDaGVja2VkLGluaXRpYWxWYWx1ZTpudWxsIT1iLnZhbHVlP2IudmFsdWU6Yyxjb250cm9sbGVkOlwiY2hlY2tib3hcIj09PWIudHlwZXx8XCJyYWRpb1wiPT09Yi50eXBlP251bGwhPWIuY2hlY2tlZDpudWxsIT1iLnZhbHVlfX1cbmZ1bmN0aW9uIE5mKGEsYil7Yj1iLmNoZWNrZWQ7bnVsbCE9YiYmSWYoYSxcImNoZWNrZWRcIixiKX1mdW5jdGlvbiBPZihhLGIpe05mKGEsYik7dmFyIGM9Yi52YWx1ZTtpZihudWxsIT1jKWlmKDA9PT1jJiZcIlwiPT09YS52YWx1ZSlhLnZhbHVlPVwiMFwiO2Vsc2UgaWYoXCJudW1iZXJcIj09PWIudHlwZSl7aWYoYj1wYXJzZUZsb2F0KGEudmFsdWUpfHwwLGMhPWJ8fGM9PWImJmEudmFsdWUhPWMpYS52YWx1ZT1cIlwiK2N9ZWxzZSBhLnZhbHVlIT09XCJcIitjJiYoYS52YWx1ZT1cIlwiK2MpO2Vsc2UgbnVsbD09Yi52YWx1ZSYmbnVsbCE9Yi5kZWZhdWx0VmFsdWUmJmEuZGVmYXVsdFZhbHVlIT09XCJcIitiLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPVwiXCIrYi5kZWZhdWx0VmFsdWUpLG51bGw9PWIuY2hlY2tlZCYmbnVsbCE9Yi5kZWZhdWx0Q2hlY2tlZCYmKGEuZGVmYXVsdENoZWNrZWQ9ISFiLmRlZmF1bHRDaGVja2VkKX1cbmZ1bmN0aW9uIFBmKGEsYil7c3dpdGNoKGIudHlwZSl7Y2FzZSBcInN1Ym1pdFwiOmNhc2UgXCJyZXNldFwiOmJyZWFrO2Nhc2UgXCJjb2xvclwiOmNhc2UgXCJkYXRlXCI6Y2FzZSBcImRhdGV0aW1lXCI6Y2FzZSBcImRhdGV0aW1lLWxvY2FsXCI6Y2FzZSBcIm1vbnRoXCI6Y2FzZSBcInRpbWVcIjpjYXNlIFwid2Vla1wiOmEudmFsdWU9XCJcIjthLnZhbHVlPWEuZGVmYXVsdFZhbHVlO2JyZWFrO2RlZmF1bHQ6YS52YWx1ZT1hLnZhbHVlfWI9YS5uYW1lO1wiXCIhPT1iJiYoYS5uYW1lPVwiXCIpO2EuZGVmYXVsdENoZWNrZWQ9IWEuZGVmYXVsdENoZWNrZWQ7YS5kZWZhdWx0Q2hlY2tlZD0hYS5kZWZhdWx0Q2hlY2tlZDtcIlwiIT09YiYmKGEubmFtZT1iKX1mdW5jdGlvbiBRZihhKXt2YXIgYj1cIlwiO2FhLkNoaWxkcmVuLmZvckVhY2goYSxmdW5jdGlvbihhKXtudWxsPT1hfHxcInN0cmluZ1wiIT09dHlwZW9mIGEmJlwibnVtYmVyXCIhPT10eXBlb2YgYXx8KGIrPWEpfSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBSZihhLGIpe2E9Qih7Y2hpbGRyZW46dm9pZCAwfSxiKTtpZihiPVFmKGIuY2hpbGRyZW4pKWEuY2hpbGRyZW49YjtyZXR1cm4gYX1mdW5jdGlvbiBTZihhLGIsYyxkKXthPWEub3B0aW9ucztpZihiKXtiPXt9O2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKWJbXCIkXCIrY1tlXV09ITA7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyllPWIuaGFzT3duUHJvcGVydHkoXCIkXCIrYVtjXS52YWx1ZSksYVtjXS5zZWxlY3RlZCE9PWUmJihhW2NdLnNlbGVjdGVkPWUpLGUmJmQmJihhW2NdLmRlZmF1bHRTZWxlY3RlZD0hMCl9ZWxzZXtjPVwiXCIrYztiPW51bGw7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoYVtlXS52YWx1ZT09PWMpe2FbZV0uc2VsZWN0ZWQ9ITA7ZCYmKGFbZV0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PWJ8fGFbZV0uZGlzYWJsZWR8fChiPWFbZV0pfW51bGwhPT1iJiYoYi5zZWxlY3RlZD0hMCl9fVxuZnVuY3Rpb24gVGYoYSxiKXt2YXIgYz1iLnZhbHVlO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOm51bGwhPWM/YzpiLmRlZmF1bHRWYWx1ZSx3YXNNdWx0aXBsZTohIWIubXVsdGlwbGV9fWZ1bmN0aW9uIFVmKGEsYil7bnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTD9FKFwiOTFcIik6dm9pZCAwO3JldHVybiBCKHt9LGIse3ZhbHVlOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLGNoaWxkcmVuOlwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZX0pfWZ1bmN0aW9uIFZmKGEsYil7dmFyIGM9Yi52YWx1ZTtudWxsPT1jJiYoYz1iLmRlZmF1bHRWYWx1ZSxiPWIuY2hpbGRyZW4sbnVsbCE9YiYmKG51bGwhPWM/RShcIjkyXCIpOnZvaWQgMCxBcnJheS5pc0FycmF5KGIpJiYoMT49Yi5sZW5ndGg/dm9pZCAwOkUoXCI5M1wiKSxiPWJbMF0pLGM9XCJcIitiKSxudWxsPT1jJiYoYz1cIlwiKSk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6XCJcIitjfX1cbmZ1bmN0aW9uIFdmKGEsYil7dmFyIGM9Yi52YWx1ZTtudWxsIT1jJiYoYz1cIlwiK2MsYyE9PWEudmFsdWUmJihhLnZhbHVlPWMpLG51bGw9PWIuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9YykpO251bGwhPWIuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9Yi5kZWZhdWx0VmFsdWUpfWZ1bmN0aW9uIFhmKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7Yj09PWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJihhLnZhbHVlPWIpfXZhciBZZj17aHRtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixtYXRobWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsc3ZnOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn07XG5mdW5jdGlvbiBaZihhKXtzd2l0Y2goYSl7Y2FzZSBcInN2Z1wiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtjYXNlIFwibWF0aFwiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO2RlZmF1bHQ6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJ9fWZ1bmN0aW9uICRmKGEsYil7cmV0dXJuIG51bGw9PWF8fFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT09YT9aZihiKTpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI9PT1hJiZcImZvcmVpZ25PYmplY3RcIj09PWI/XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI6YX1cbnZhciBhZz12b2lkIDAsYmc9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNU0FwcCYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24/ZnVuY3Rpb24oYixjLGQsZSl7TVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gYShiLGMsZCxlKX0pfTphfShmdW5jdGlvbihhLGIpe2lmKGEubmFtZXNwYWNlVVJJIT09WWYuc3ZnfHxcImlubmVySFRNTFwiaW4gYSlhLmlubmVySFRNTD1iO2Vsc2V7YWc9YWd8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YWcuaW5uZXJIVE1MPVwiXFx4M2NzdmdcXHgzZVwiK2IrXCJcXHgzYy9zdmdcXHgzZVwiO2ZvcihiPWFnLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIGNnKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgZGc9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwLGZpbGxPcGFjaXR5OiEwLGZsb29kT3BhY2l0eTohMCxcbnN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0sZWc9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKGRnKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2VnLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7ZGdbYl09ZGdbYV19KX0pO1xuZnVuY3Rpb24gZmcoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpO3ZhciBlPWM7dmFyIGY9YltjXTtlPW51bGw9PWZ8fFwiYm9vbGVhblwiPT09dHlwZW9mIGZ8fFwiXCI9PT1mP1wiXCI6ZHx8XCJudW1iZXJcIiE9PXR5cGVvZiBmfHwwPT09Znx8ZGcuaGFzT3duUHJvcGVydHkoZSkmJmRnW2VdPyhcIlwiK2YpLnRyaW0oKTpmK1wicHhcIjtcImZsb2F0XCI9PT1jJiYoYz1cImNzc0Zsb2F0XCIpO2Q/YS5zZXRQcm9wZXJ0eShjLGUpOmFbY109ZX19dmFyIGdnPUIoe21lbnVpdGVtOiEwfSx7YXJlYTohMCxiYXNlOiEwLGJyOiEwLGNvbDohMCxlbWJlZDohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsa2V5Z2VuOiEwLGxpbms6ITAsbWV0YTohMCxwYXJhbTohMCxzb3VyY2U6ITAsdHJhY2s6ITAsd2JyOiEwfSk7XG5mdW5jdGlvbiBoZyhhLGIsYyl7YiYmKGdnW2FdJiYobnVsbCE9Yi5jaGlsZHJlbnx8bnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTD9FKFwiMTM3XCIsYSxjKCkpOnZvaWQgMCksbnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmKG51bGwhPWIuY2hpbGRyZW4/RShcIjYwXCIpOnZvaWQgMCxcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP3ZvaWQgMDpFKFwiNjFcIikpLG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZT9FKFwiNjJcIixjKCkpOnZvaWQgMCl9XG5mdW5jdGlvbiBpZyhhLGIpe2lmKC0xPT09YS5pbmRleE9mKFwiLVwiKSlyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGIuaXM7c3dpdGNoKGEpe2Nhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOmNhc2UgXCJjb2xvci1wcm9maWxlXCI6Y2FzZSBcImZvbnQtZmFjZVwiOmNhc2UgXCJmb250LWZhY2Utc3JjXCI6Y2FzZSBcImZvbnQtZmFjZS11cmlcIjpjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOmNhc2UgXCJmb250LWZhY2UtbmFtZVwiOmNhc2UgXCJtaXNzaW5nLWdseXBoXCI6cmV0dXJuITE7ZGVmYXVsdDpyZXR1cm4hMH19dmFyIGpnPVlmLmh0bWwsa2c9Qy50aGF0UmV0dXJucyhcIlwiKTtcbmZ1bmN0aW9uIGxnKGEsYil7YT05PT09YS5ub2RlVHlwZXx8MTE9PT1hLm5vZGVUeXBlP2E6YS5vd25lckRvY3VtZW50O3ZhciBjPUhkKGEpO2I9U2FbYl07Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF07Yy5oYXNPd25Qcm9wZXJ0eShlKSYmY1tlXXx8KFwidG9wU2Nyb2xsXCI9PT1lP3dkKFwidG9wU2Nyb2xsXCIsXCJzY3JvbGxcIixhKTpcInRvcEZvY3VzXCI9PT1lfHxcInRvcEJsdXJcIj09PWU/KHdkKFwidG9wRm9jdXNcIixcImZvY3VzXCIsYSksd2QoXCJ0b3BCbHVyXCIsXCJibHVyXCIsYSksYy50b3BCbHVyPSEwLGMudG9wRm9jdXM9ITApOlwidG9wQ2FuY2VsXCI9PT1lPyh5YyhcImNhbmNlbFwiLCEwKSYmd2QoXCJ0b3BDYW5jZWxcIixcImNhbmNlbFwiLGEpLGMudG9wQ2FuY2VsPSEwKTpcInRvcENsb3NlXCI9PT1lPyh5YyhcImNsb3NlXCIsITApJiZ3ZChcInRvcENsb3NlXCIsXCJjbG9zZVwiLGEpLGMudG9wQ2xvc2U9ITApOkRkLmhhc093blByb3BlcnR5KGUpJiZVKGUsRGRbZV0sYSksY1tlXT0hMCl9fVxudmFyIG1nPXt0b3BBYm9ydDpcImFib3J0XCIsdG9wQ2FuUGxheTpcImNhbnBsYXlcIix0b3BDYW5QbGF5VGhyb3VnaDpcImNhbnBsYXl0aHJvdWdoXCIsdG9wRHVyYXRpb25DaGFuZ2U6XCJkdXJhdGlvbmNoYW5nZVwiLHRvcEVtcHRpZWQ6XCJlbXB0aWVkXCIsdG9wRW5jcnlwdGVkOlwiZW5jcnlwdGVkXCIsdG9wRW5kZWQ6XCJlbmRlZFwiLHRvcEVycm9yOlwiZXJyb3JcIix0b3BMb2FkZWREYXRhOlwibG9hZGVkZGF0YVwiLHRvcExvYWRlZE1ldGFkYXRhOlwibG9hZGVkbWV0YWRhdGFcIix0b3BMb2FkU3RhcnQ6XCJsb2Fkc3RhcnRcIix0b3BQYXVzZTpcInBhdXNlXCIsdG9wUGxheTpcInBsYXlcIix0b3BQbGF5aW5nOlwicGxheWluZ1wiLHRvcFByb2dyZXNzOlwicHJvZ3Jlc3NcIix0b3BSYXRlQ2hhbmdlOlwicmF0ZWNoYW5nZVwiLHRvcFNlZWtlZDpcInNlZWtlZFwiLHRvcFNlZWtpbmc6XCJzZWVraW5nXCIsdG9wU3RhbGxlZDpcInN0YWxsZWRcIix0b3BTdXNwZW5kOlwic3VzcGVuZFwiLHRvcFRpbWVVcGRhdGU6XCJ0aW1ldXBkYXRlXCIsdG9wVm9sdW1lQ2hhbmdlOlwidm9sdW1lY2hhbmdlXCIsXG50b3BXYWl0aW5nOlwid2FpdGluZ1wifTtmdW5jdGlvbiBuZyhhLGIsYyxkKXtjPTk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50O2Q9PT1qZyYmKGQ9WmYoYSkpO2Q9PT1qZz9cInNjcmlwdFwiPT09YT8oYT1jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYS5pbm5lckhUTUw9XCJcXHgzY3NjcmlwdFxceDNlXFx4M2Mvc2NyaXB0XFx4M2VcIixhPWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKSk6YT1cInN0cmluZ1wiPT09dHlwZW9mIGIuaXM/Yy5jcmVhdGVFbGVtZW50KGEse2lzOmIuaXN9KTpjLmNyZWF0ZUVsZW1lbnQoYSk6YT1jLmNyZWF0ZUVsZW1lbnROUyhkLGEpO3JldHVybiBhfWZ1bmN0aW9uIG9nKGEsYil7cmV0dXJuKDk9PT1iLm5vZGVUeXBlP2I6Yi5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShhKX1cbmZ1bmN0aW9uIHBnKGEsYixjLGQpe3ZhciBlPWlnKGIsYyk7c3dpdGNoKGIpe2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6VShcInRvcExvYWRcIixcImxvYWRcIixhKTt2YXIgZj1jO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihmIGluIG1nKW1nLmhhc093blByb3BlcnR5KGYpJiZVKGYsbWdbZl0sYSk7Zj1jO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7VShcInRvcExvYWRcIixcImxvYWRcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImZvcm1cIjpVKFwidG9wUmVzZXRcIixcInJlc2V0XCIsYSk7VShcInRvcFN1Ym1pdFwiLFwic3VibWl0XCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6VShcInRvcFRvZ2dsZVwiLFwidG9nZ2xlXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOk1mKGEsYyk7Zj1MZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7XG5sZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmY9UmYoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6VGYoYSxjKTtmPUIoe30sYyx7dmFsdWU6dm9pZCAwfSk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmYoYSxjKTtmPVVmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7ZGVmYXVsdDpmPWN9aGcoYixmLGtnKTt2YXIgZz1mLGg7Zm9yKGggaW4gZylpZihnLmhhc093blByb3BlcnR5KGgpKXt2YXIgaz1nW2hdO1wic3R5bGVcIj09PWg/ZmcoYSxrLGtnKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1oPyhrPWs/ay5fX2h0bWw6dm9pZCAwLG51bGwhPWsmJmJnKGEsaykpOlwiY2hpbGRyZW5cIj09PWg/XCJzdHJpbmdcIj09PXR5cGVvZiBrPyhcInRleHRhcmVhXCIhPT1ifHxcIlwiIT09aykmJmNnKGEsayk6XCJudW1iZXJcIj09PXR5cGVvZiBrJiZjZyhhLFxuXCJcIitrKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09aCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWgmJlwiYXV0b0ZvY3VzXCIhPT1oJiYoUmEuaGFzT3duUHJvcGVydHkoaCk/bnVsbCE9ayYmbGcoZCxoKTplP0tmKGEsaCxrKTpudWxsIT1rJiZJZihhLGgsaykpfXN3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpCYyhhKTtQZihhLGMpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkJjKGEpO1hmKGEsYyk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWMudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixjLnZhbHVlKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWMubXVsdGlwbGU7Yj1jLnZhbHVlO251bGwhPWI/U2YoYSwhIWMubXVsdGlwbGUsYiwhMSk6bnVsbCE9Yy5kZWZhdWx0VmFsdWUmJlNmKGEsISFjLm11bHRpcGxlLGMuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLm9uQ2xpY2smJihhLm9uY2xpY2s9XG5DKX19XG5mdW5jdGlvbiBzZyhhLGIsYyxkLGUpe3ZhciBmPW51bGw7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOmM9TGYoYSxjKTtkPUxmKGEsZCk7Zj1bXTticmVhaztjYXNlIFwib3B0aW9uXCI6Yz1SZihhLGMpO2Q9UmYoYSxkKTtmPVtdO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpjPUIoe30sYyx7dmFsdWU6dm9pZCAwfSk7ZD1CKHt9LGQse3ZhbHVlOnZvaWQgMH0pO2Y9W107YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6Yz1VZihhLGMpO2Q9VWYoYSxkKTtmPVtdO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiIT09dHlwZW9mIGMub25DbGljayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQub25DbGljayYmKGEub25jbGljaz1DKX1oZyhiLGQsa2cpO3ZhciBnLGg7YT1udWxsO2ZvcihnIGluIGMpaWYoIWQuaGFzT3duUHJvcGVydHkoZykmJmMuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWNbZ10paWYoXCJzdHlsZVwiPT09Zylmb3IoaCBpbiBiPWNbZ10sYiliLmhhc093blByb3BlcnR5KGgpJiYoYXx8KGE9e30pLGFbaF09XG5cIlwiKTtlbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIT09ZyYmXCJjaGlsZHJlblwiIT09ZyYmXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWcmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1nJiZcImF1dG9Gb2N1c1wiIT09ZyYmKFJhLmhhc093blByb3BlcnR5KGcpP2Z8fChmPVtdKTooZj1mfHxbXSkucHVzaChnLG51bGwpKTtmb3IoZyBpbiBkKXt2YXIgaz1kW2ddO2I9bnVsbCE9Yz9jW2ddOnZvaWQgMDtpZihkLmhhc093blByb3BlcnR5KGcpJiZrIT09YiYmKG51bGwhPWt8fG51bGwhPWIpKWlmKFwic3R5bGVcIj09PWcpaWYoYil7Zm9yKGggaW4gYikhYi5oYXNPd25Qcm9wZXJ0eShoKXx8ayYmay5oYXNPd25Qcm9wZXJ0eShoKXx8KGF8fChhPXt9KSxhW2hdPVwiXCIpO2ZvcihoIGluIGspay5oYXNPd25Qcm9wZXJ0eShoKSYmYltoXSE9PWtbaF0mJihhfHwoYT17fSksYVtoXT1rW2hdKX1lbHNlIGF8fChmfHwoZj1bXSksZi5wdXNoKGcsYSkpLGE9aztlbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09XG5nPyhrPWs/ay5fX2h0bWw6dm9pZCAwLGI9Yj9iLl9faHRtbDp2b2lkIDAsbnVsbCE9ayYmYiE9PWsmJihmPWZ8fFtdKS5wdXNoKGcsXCJcIitrKSk6XCJjaGlsZHJlblwiPT09Zz9iPT09a3x8XCJzdHJpbmdcIiE9PXR5cGVvZiBrJiZcIm51bWJlclwiIT09dHlwZW9mIGt8fChmPWZ8fFtdKS5wdXNoKGcsXCJcIitrKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWcmJihSYS5oYXNPd25Qcm9wZXJ0eShnKT8obnVsbCE9ayYmbGcoZSxnKSxmfHxiPT09a3x8KGY9W10pKTooZj1mfHxbXSkucHVzaChnLGspKX1hJiYoZj1mfHxbXSkucHVzaChcInN0eWxlXCIsYSk7cmV0dXJuIGZ9XG5mdW5jdGlvbiB0ZyhhLGIsYyxkLGUpe1wiaW5wdXRcIj09PWMmJlwicmFkaW9cIj09PWUudHlwZSYmbnVsbCE9ZS5uYW1lJiZOZihhLGUpO2lnKGMsZCk7ZD1pZyhjLGUpO2Zvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7Zis9Mil7dmFyIGc9YltmXSxoPWJbZisxXTtcInN0eWxlXCI9PT1nP2ZnKGEsaCxrZyk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zz9iZyhhLGgpOlwiY2hpbGRyZW5cIj09PWc/Y2coYSxoKTpkP251bGwhPWg/S2YoYSxnLGgpOmEucmVtb3ZlQXR0cmlidXRlKGcpOm51bGwhPWg/SWYoYSxnLGgpOkpmKGEsZyl9c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOk9mKGEsZSk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2YoYSxlKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZT12b2lkIDAsYj1hLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUsYS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhZS5tdWx0aXBsZSxjPWUudmFsdWUsbnVsbCE9Yz9TZihhLFxuISFlLm11bHRpcGxlLGMsITEpOmIhPT0hIWUubXVsdGlwbGUmJihudWxsIT1lLmRlZmF1bHRWYWx1ZT9TZihhLCEhZS5tdWx0aXBsZSxlLmRlZmF1bHRWYWx1ZSwhMCk6U2YoYSwhIWUubXVsdGlwbGUsZS5tdWx0aXBsZT9bXTpcIlwiLCExKSl9fVxuZnVuY3Rpb24gdWcoYSxiLGMsZCxlKXtzd2l0Y2goYil7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcih2YXIgZiBpbiBtZyltZy5oYXNPd25Qcm9wZXJ0eShmKSYmVShmLG1nW2ZdLGEpO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2JyZWFrO2Nhc2UgXCJmb3JtXCI6VShcInRvcFJlc2V0XCIsXCJyZXNldFwiLGEpO1UoXCJ0b3BTdWJtaXRcIixcInN1Ym1pdFwiLGEpO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6VShcInRvcFRvZ2dsZVwiLFwidG9nZ2xlXCIsYSk7YnJlYWs7Y2FzZSBcImlucHV0XCI6TWYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGUsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwic2VsZWN0XCI6VGYoYSxjKTtcblUoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOlZmKGEsYyksVShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKSxsZyhlLFwib25DaGFuZ2VcIil9aGcoYixjLGtnKTtkPW51bGw7Zm9yKHZhciBnIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShnKSYmKGY9Y1tnXSxcImNoaWxkcmVuXCI9PT1nP1wic3RyaW5nXCI9PT10eXBlb2YgZj9hLnRleHRDb250ZW50IT09ZiYmKGQ9W1wiY2hpbGRyZW5cIixmXSk6XCJudW1iZXJcIj09PXR5cGVvZiBmJiZhLnRleHRDb250ZW50IT09XCJcIitmJiYoZD1bXCJjaGlsZHJlblwiLFwiXCIrZl0pOlJhLmhhc093blByb3BlcnR5KGcpJiZudWxsIT1mJiZsZyhlLGcpKTtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6QmMoYSk7UGYoYSxjKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpCYyhhKTtYZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpjYXNlIFwib3B0aW9uXCI6YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5vbkNsaWNrJiZcbihhLm9uY2xpY2s9Qyl9cmV0dXJuIGR9ZnVuY3Rpb24gdmcoYSxiKXtyZXR1cm4gYS5ub2RlVmFsdWUhPT1ifVxudmFyIHdnPU9iamVjdC5mcmVlemUoe2NyZWF0ZUVsZW1lbnQ6bmcsY3JlYXRlVGV4dE5vZGU6b2csc2V0SW5pdGlhbFByb3BlcnRpZXM6cGcsZGlmZlByb3BlcnRpZXM6c2csdXBkYXRlUHJvcGVydGllczp0ZyxkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOnVnLGRpZmZIeWRyYXRlZFRleHQ6dmcsd2FybkZvclVubWF0Y2hlZFRleHQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDpmdW5jdGlvbigpe30sd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0OmZ1bmN0aW9uKCl7fSxyZXN0b3JlQ29udHJvbGxlZFN0YXRlOmZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6T2YoYSxjKTtiPWMubmFtZTtpZihcInJhZGlvXCI9PT1jLnR5cGUmJm51bGwhPWIpe2ZvcihjPWE7Yy5wYXJlbnROb2RlOyljPVxuYy5wYXJlbnROb2RlO2M9Yy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbbmFtZVxceDNkXCIrSlNPTi5zdHJpbmdpZnkoXCJcIitiKSsnXVt0eXBlXFx4M2RcInJhZGlvXCJdJyk7Zm9yKGI9MDtiPGMubGVuZ3RoO2IrKyl7dmFyIGQ9Y1tiXTtpZihkIT09YSYmZC5mb3JtPT09YS5mb3JtKXt2YXIgZT1yYihkKTtlP3ZvaWQgMDpFKFwiOTBcIik7Q2MoZCk7T2YoZCxlKX19fWJyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOldmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmI9Yy52YWx1ZSxudWxsIT1iJiZTZihhLCEhYy5tdWx0aXBsZSxiLCExKX19fSk7bmMuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudCh3Zyk7dmFyIHhnPW51bGwsTWc9bnVsbDtmdW5jdGlvbiBOZyhhKXtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZSYmOSE9PWEubm9kZVR5cGUmJjExIT09YS5ub2RlVHlwZSYmKDghPT1hLm5vZGVUeXBlfHxcIiByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSBcIiE9PWEubm9kZVZhbHVlKSl9XG5mdW5jdGlvbiBPZyhhKXthPWE/OT09PWEubm9kZVR5cGU/YS5kb2N1bWVudEVsZW1lbnQ6YS5maXJzdENoaWxkOm51bGw7cmV0dXJuISghYXx8MSE9PWEubm9kZVR5cGV8fCFhLmhhc0F0dHJpYnV0ZShcImRhdGEtcmVhY3Ryb290XCIpKX1cbnZhciBaPW9mKHtnZXRSb290SG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub2RlVHlwZTtzd2l0Y2goYil7Y2FzZSA5OmNhc2UgMTE6YT0oYT1hLmRvY3VtZW50RWxlbWVudCk/YS5uYW1lc3BhY2VVUkk6JGYobnVsbCxcIlwiKTticmVhaztkZWZhdWx0OmI9OD09PWI/YS5wYXJlbnROb2RlOmEsYT1iLm5hbWVzcGFjZVVSSXx8bnVsbCxiPWIudGFnTmFtZSxhPSRmKGEsYil9cmV0dXJuIGF9LGdldENoaWxkSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gJGYoYSxiKX0sZ2V0UHVibGljSW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LHByZXBhcmVGb3JDb21taXQ6ZnVuY3Rpb24oKXt4Zz10ZDt2YXIgYT1kYSgpO2lmKEtkKGEpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBhKXZhciBiPXtzdGFydDphLnNlbGVjdGlvblN0YXJ0LGVuZDphLnNlbGVjdGlvbkVuZH07ZWxzZSBhOnt2YXIgYz13aW5kb3cuZ2V0U2VsZWN0aW9uJiZ3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5pZihjJiYwIT09Yy5yYW5nZUNvdW50KXtiPWMuYW5jaG9yTm9kZTt2YXIgZD1jLmFuY2hvck9mZnNldCxlPWMuZm9jdXNOb2RlO2M9Yy5mb2N1c09mZnNldDt0cnl7Yi5ub2RlVHlwZSxlLm5vZGVUeXBlfWNhdGNoKHope2I9bnVsbDticmVhayBhfXZhciBmPTAsZz0tMSxoPS0xLGs9MCxxPTAsdj1hLHk9bnVsbDtiOmZvcig7Oyl7Zm9yKHZhciB1Ozspe3YhPT1ifHwwIT09ZCYmMyE9PXYubm9kZVR5cGV8fChnPWYrZCk7diE9PWV8fDAhPT1jJiYzIT09di5ub2RlVHlwZXx8KGg9ZitjKTszPT09di5ub2RlVHlwZSYmKGYrPXYubm9kZVZhbHVlLmxlbmd0aCk7aWYobnVsbD09PSh1PXYuZmlyc3RDaGlsZCkpYnJlYWs7eT12O3Y9dX1mb3IoOzspe2lmKHY9PT1hKWJyZWFrIGI7eT09PWImJisraz09PWQmJihnPWYpO3k9PT1lJiYrK3E9PT1jJiYoaD1mKTtpZihudWxsIT09KHU9di5uZXh0U2libGluZykpYnJlYWs7dj15O3k9di5wYXJlbnROb2RlfXY9dX1iPS0xPT09Z3x8LTE9PT1oP251bGw6XG57c3RhcnQ6ZyxlbmQ6aH19ZWxzZSBiPW51bGx9Yj1ifHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBiPW51bGw7TWc9e2ZvY3VzZWRFbGVtOmEsc2VsZWN0aW9uUmFuZ2U6Yn07dWQoITEpfSxyZXNldEFmdGVyQ29tbWl0OmZ1bmN0aW9uKCl7dmFyIGE9TWcsYj1kYSgpLGM9YS5mb2N1c2VkRWxlbSxkPWEuc2VsZWN0aW9uUmFuZ2U7aWYoYiE9PWMmJmZhKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxjKSl7aWYoS2QoYykpaWYoYj1kLnN0YXJ0LGE9ZC5lbmQsdm9pZCAwPT09YSYmKGE9YiksXCJzZWxlY3Rpb25TdGFydFwiaW4gYyljLnNlbGVjdGlvblN0YXJ0PWIsYy5zZWxlY3Rpb25FbmQ9TWF0aC5taW4oYSxjLnZhbHVlLmxlbmd0aCk7ZWxzZSBpZih3aW5kb3cuZ2V0U2VsZWN0aW9uKXtiPXdpbmRvdy5nZXRTZWxlY3Rpb24oKTt2YXIgZT1jW0ViKCldLmxlbmd0aDthPU1hdGgubWluKGQuc3RhcnQsZSk7ZD12b2lkIDA9PT1kLmVuZD9hOk1hdGgubWluKGQuZW5kLGUpOyFiLmV4dGVuZCYmYT5cbmQmJihlPWQsZD1hLGE9ZSk7ZT1KZChjLGEpO3ZhciBmPUpkKGMsZCk7aWYoZSYmZiYmKDEhPT1iLnJhbmdlQ291bnR8fGIuYW5jaG9yTm9kZSE9PWUubm9kZXx8Yi5hbmNob3JPZmZzZXQhPT1lLm9mZnNldHx8Yi5mb2N1c05vZGUhPT1mLm5vZGV8fGIuZm9jdXNPZmZzZXQhPT1mLm9mZnNldCkpe3ZhciBnPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7Zy5zZXRTdGFydChlLm5vZGUsZS5vZmZzZXQpO2IucmVtb3ZlQWxsUmFuZ2VzKCk7YT5kPyhiLmFkZFJhbmdlKGcpLGIuZXh0ZW5kKGYubm9kZSxmLm9mZnNldCkpOihnLnNldEVuZChmLm5vZGUsZi5vZmZzZXQpLGIuYWRkUmFuZ2UoZykpfX1iPVtdO2ZvcihhPWM7YT1hLnBhcmVudE5vZGU7KTE9PT1hLm5vZGVUeXBlJiZiLnB1c2goe2VsZW1lbnQ6YSxsZWZ0OmEuc2Nyb2xsTGVmdCx0b3A6YS5zY3JvbGxUb3B9KTtpYShjKTtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKWE9YltjXSxhLmVsZW1lbnQuc2Nyb2xsTGVmdD1hLmxlZnQsYS5lbGVtZW50LnNjcm9sbFRvcD1cbmEudG9wfU1nPW51bGw7dWQoeGcpO3hnPW51bGx9LGNyZWF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YT1uZyhhLGIsYyxkKTthW1FdPWU7YVtvYl09YjtyZXR1cm4gYX0sYXBwZW5kSW5pdGlhbENoaWxkOmZ1bmN0aW9uKGEsYil7YS5hcHBlbmRDaGlsZChiKX0sZmluYWxpemVJbml0aWFsQ2hpbGRyZW46ZnVuY3Rpb24oYSxiLGMsZCl7cGcoYSxiLGMsZCk7YTp7c3dpdGNoKGIpe2Nhc2UgXCJidXR0b25cIjpjYXNlIFwiaW5wdXRcIjpjYXNlIFwic2VsZWN0XCI6Y2FzZSBcInRleHRhcmVhXCI6YT0hIWMuYXV0b0ZvY3VzO2JyZWFrIGF9YT0hMX1yZXR1cm4gYX0scHJlcGFyZVVwZGF0ZTpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiBzZyhhLGIsYyxkLGUpfSxzaG91bGRTZXRUZXh0Q29udGVudDpmdW5jdGlvbihhLGIpe3JldHVyblwidGV4dGFyZWFcIj09PWF8fFwic3RyaW5nXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJudW1iZXJcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm9iamVjdFwiPT09XG50eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9PWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwic3RyaW5nXCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9LHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4hIWIuaGlkZGVufSxjcmVhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCl7YT1vZyhhLGIpO2FbUV09ZDtyZXR1cm4gYX0sbm93OnJmLG11dGF0aW9uOntjb21taXRNb3VudDpmdW5jdGlvbihhKXthLmZvY3VzKCl9LGNvbW1pdFVwZGF0ZTpmdW5jdGlvbihhLGIsYyxkLGUpe2Fbb2JdPWU7dGcoYSxiLGMsZCxlKX0scmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbihhKXthLnRleHRDb250ZW50PVwiXCJ9LGNvbW1pdFRleHRVcGRhdGU6ZnVuY3Rpb24oYSxiLGMpe2Eubm9kZVZhbHVlPWN9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGEsYil7YS5hcHBlbmRDaGlsZChiKX0sYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjpmdW5jdGlvbihhLFxuYil7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGEpOmEuYXBwZW5kQ2hpbGQoYil9LGluc2VydEJlZm9yZTpmdW5jdGlvbihhLGIsYyl7YS5pbnNlcnRCZWZvcmUoYixjKX0saW5zZXJ0SW5Db250YWluZXJCZWZvcmU6ZnVuY3Rpb24oYSxiLGMpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYixjKTphLmluc2VydEJlZm9yZShiLGMpfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihhLGIpe2EucmVtb3ZlQ2hpbGQoYil9LHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjpmdW5jdGlvbihhLGIpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTphLnJlbW92ZUNoaWxkKGIpfX0saHlkcmF0aW9uOntjYW5IeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMSE9PWEubm9kZVR5cGV8fGIudG9Mb3dlckNhc2UoKSE9PWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT9udWxsOmF9LGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxcbmIpe3JldHVyblwiXCI9PT1ifHwzIT09YS5ub2RlVHlwZT9udWxsOmF9LGdldE5leHRIeWRyYXRhYmxlU2libGluZzpmdW5jdGlvbihhKXtmb3IoYT1hLm5leHRTaWJsaW5nO2EmJjEhPT1hLm5vZGVUeXBlJiYzIT09YS5ub2RlVHlwZTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfSxnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDpmdW5jdGlvbihhKXtmb3IoYT1hLmZpcnN0Q2hpbGQ7YSYmMSE9PWEubm9kZVR5cGUmJjMhPT1hLm5vZGVUeXBlOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9LGh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkLGUsZil7YVtRXT1mO2Fbb2JdPWM7cmV0dXJuIHVnKGEsYixjLGUsZCl9LGh5ZHJhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2FbUV09YztyZXR1cm4gdmcoYSxiKX0sZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sXG5kaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fX0sc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOnNmLGNhbmNlbERlZmVycmVkQ2FsbGJhY2s6dGYsdXNlU3luY1NjaGVkdWxpbmc6ITB9KTtyYz1aLmJhdGNoZWRVcGRhdGVzO1xuZnVuY3Rpb24gUGcoYSxiLGMsZCxlKXtOZyhjKT92b2lkIDA6RShcIjIwMFwiKTt2YXIgZj1jLl9yZWFjdFJvb3RDb250YWluZXI7aWYoZilaLnVwZGF0ZUNvbnRhaW5lcihiLGYsYSxlKTtlbHNle2Q9ZHx8T2coYyk7aWYoIWQpZm9yKGY9dm9pZCAwO2Y9Yy5sYXN0Q2hpbGQ7KWMucmVtb3ZlQ2hpbGQoZik7dmFyIGc9Wi5jcmVhdGVDb250YWluZXIoYyxkKTtmPWMuX3JlYWN0Um9vdENvbnRhaW5lcj1nO1oudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe1oudXBkYXRlQ29udGFpbmVyKGIsZyxhLGUpfSl9cmV0dXJuIFouZ2V0UHVibGljUm9vdEluc3RhbmNlKGYpfWZ1bmN0aW9uIFFnKGEsYil7dmFyIGM9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7TmcoYik/dm9pZCAwOkUoXCIyMDBcIik7cmV0dXJuIHBmKGEsYixudWxsLGMpfVxuZnVuY3Rpb24gUmcoYSxiKXt0aGlzLl9yZWFjdFJvb3RDb250YWluZXI9Wi5jcmVhdGVDb250YWluZXIoYSxiKX1SZy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEsYil7Wi51cGRhdGVDb250YWluZXIoYSx0aGlzLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCxiKX07UmcucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oYSl7Wi51cGRhdGVDb250YWluZXIobnVsbCx0aGlzLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCxhKX07XG52YXIgU2c9e2NyZWF0ZVBvcnRhbDpRZyxmaW5kRE9NTm9kZTpmdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxGaWJlcjtpZihiKXJldHVybiBaLmZpbmRIb3N0SW5zdGFuY2UoYik7XCJmdW5jdGlvblwiPT09dHlwZW9mIGEucmVuZGVyP0UoXCIxODhcIik6RShcIjIxM1wiLE9iamVjdC5rZXlzKGEpKX0saHlkcmF0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFBnKG51bGwsYSxiLCEwLGMpfSxyZW5kZXI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBQZyhudWxsLGEsYiwhMSxjKX0sdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6ZnVuY3Rpb24oYSxiLGMsZCl7bnVsbD09YXx8dm9pZCAwPT09YS5fcmVhY3RJbnRlcm5hbEZpYmVyP0UoXCIzOFwiKTp2b2lkIDA7cmV0dXJuIFBnKGEsYixjLCExLGQpfSx1bm1vdW50Q29tcG9uZW50QXROb2RlOmZ1bmN0aW9uKGEpe05nKGEpP3ZvaWQgMDpcbkUoXCI0MFwiKTtyZXR1cm4gYS5fcmVhY3RSb290Q29udGFpbmVyPyhaLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24oKXtQZyhudWxsLG51bGwsYSwhMSxmdW5jdGlvbigpe2EuX3JlYWN0Um9vdENvbnRhaW5lcj1udWxsfSl9KSwhMCk6ITF9LHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDpRZyx1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczp0Yyx1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6Wi5kZWZlcnJlZFVwZGF0ZXMsZmx1c2hTeW5jOlouZmx1c2hTeW5jLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntFdmVudFBsdWdpbkh1YjptYixFdmVudFBsdWdpblJlZ2lzdHJ5OlZhLEV2ZW50UHJvcGFnYXRvcnM6Q2IsUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OnFjLFJlYWN0RE9NQ29tcG9uZW50VHJlZTpzYixSZWFjdERPTUV2ZW50TGlzdGVuZXI6eGR9fTtcblouaW5qZWN0SW50b0RldlRvb2xzKHtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpwYixidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE2LjIuMFwiLHJlbmRlcmVyUGFja2FnZU5hbWU6XCJyZWFjdC1kb21cIn0pO3ZhciBUZz1PYmplY3QuZnJlZXplKHtkZWZhdWx0OlNnfSksVWc9VGcmJlNnfHxUZzttb2R1bGUuZXhwb3J0cz1VZ1tcImRlZmF1bHRcIl0/VWdbXCJkZWZhdWx0XCJdOlVnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgZG9jID0gb2JqZWN0ID8gb2JqZWN0Lm93bmVyRG9jdW1lbnQgfHwgb2JqZWN0IDogZG9jdW1lbnQ7XG4gIHZhciBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgaW5uZXJIVE1MOiB0cnVlLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCBcImluamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdSdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnJXMnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCBcIkRPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlc1wiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG5cbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBEb3duY2FzZSByZWZlcmVuY2VzIHRvIHdoaXRlbGlzdCBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBtZW1iZXJzaGlwXG4gICAgICAvLyB3aXRob3V0IGNhc2Utc2Vuc2l0aXZpdHkuIFRoaXMgYWxsb3dzIHRoZSB3aGl0ZWxpc3QgdG8gcGljayB1cFxuICAgICAgLy8gYGFsbG93ZnVsbHNjcmVlbmAsIHdoaWNoIHNob3VsZCBiZSB3cml0dGVuIHVzaW5nIHRoZSBwcm9wZXJ0eSBjb25maWd1cmF0aW9uXG4gICAgICAvLyBmb3IgYGFsbG93RnVsbHNjcmVlbmBcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcblxuLyoqXG4gKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAqXG4gKiBhdHRyaWJ1dGVOYW1lOlxuICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICogYXR0cmlidXRlTmFtZXNwYWNlXG4gKiBwcm9wZXJ0eU5hbWU6XG4gKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAqIG11dGF0aW9uTWV0aG9kOlxuICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gKiAgIGluaXRpYWwgcmVuZGVyLlxuICogbXVzdFVzZVByb3BlcnR5OlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHdyaXRlYWJsZSBhdHRyaWJ1dGUuXG4gKiBAbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzU3RyaW5nQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlO1xuICB9XG4gIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gIHJldHVybiBwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHdpdGhpbiB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzXG4gKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAqIG5vdCBiZSBzZXQgb24gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgaXMgd2l0aGluIHJlc2VydmVkIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpIHtcbiAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xufVxuXG52YXIgaW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IGluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICAvLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICAvLyBuYW1lIHdhcm5pbmdzLlxuICBQcm9wZXJ0aWVzOiB7XG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuICAgIC8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbiAgICBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIEtlZXAgaXQgaW4gdGhlIHdoaXRlbGlzdCBiZWNhdXNlIGl0IGlzIGNhc2Utc2Vuc2l0aXZlIGZvciBTVkcuXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gaXRlbVNjb3BlIGlzIGZvciBmb3IgTWljcm9kYXRhIHN1cHBvcnQuXG4gICAgLy8gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVGhlc2UgYXR0cmlidXRlcyBtdXN0IHN0YXkgaW4gdGhlIHdoaXRlLWxpc3QgYmVjYXVzZSB0aGV5IGhhdmVcbiAgICAvLyBkaWZmZXJlbnQgYXR0cmlidXRlIG5hbWVzIChzZWUgRE9NQXR0cmlidXRlTmFtZXMgYmVsb3cpXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgLy8gQXR0cmlidXRlcyB3aXRoIG11dGF0aW9uIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHdoaXRlbGlzdFxuICAgIC8vIFNldCB0aGUgc3RyaW5nIGJvb2xlYW4gZmxhZyB0byBhbGxvdyB0aGUgYmVoYXZpb3JcbiAgICB2YWx1ZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLFxuICogbmFtZXNwYWNpbmcsIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC5cbiAqXG4gKiBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gKiB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICogbmFtZSB3YXJuaW5ncy5cbiAqXG4gKiBTVkcgQXR0cmlidXRlcyBMaXN0OlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG4gKiBTTUlMIFNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvc21pbFxuICovXG52YXIgQVRUUlMgPSBbJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3gtaGVpZ2h0JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbG5zOnhsaW5rJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddO1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgcHJlc2VydmVBbHBoYTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDFcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfVxufTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5BVFRSUy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgcmVhY3ROYW1lID0gb3JpZ2luYWwucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG5cbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1tyZWFjdE5hbWVdID0gMDtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNbcmVhY3ROYW1lXSA9IG9yaWdpbmFsO1xufSk7XG5cbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDIgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgd2FybmluZyhnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cblxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGxpc3RlbmVyO1xuXG4gIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICBpZiAoIXByb3BzKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaXN0ZW5lciA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAhKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlRXZlbnRzKGV2ZW50cykge1xuICBpZiAoZXZlbnRzKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50UXVldWUoc2ltdWxhdGVkKSB7XG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxudmFyIEV2ZW50UGx1Z2luSHViID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDEsXG5cdGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcblx0ZXh0cmFjdEV2ZW50czogZXh0cmFjdEV2ZW50cyxcblx0ZW5xdWV1ZUV2ZW50czogZW5xdWV1ZUV2ZW50cyxcblx0cHJvY2Vzc0V2ZW50UXVldWU6IHByb2Nlc3NFdmVudFF1ZXVlXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gdm9pZCAwO1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzJDEobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gcHJvcHM7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSBPYmplY3QuZnJlZXplKHtcblx0cHJlY2FjaGVGaWJlck5vZGU6IHByZWNhY2hlRmliZXJOb2RlJDEsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59KTtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYWx0ZXJuYXRlID0gZnJvbS5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCF0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0byA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIF9hbHRlcm5hdGUgPSB0by5hbHRlcm5hdGU7XG4gICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSBwYXRoVG8ubGVuZ3RoOyBfaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9bX2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIHRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcblx0YWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1xufSk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIG9iamVjdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0O1xuICB2YXIgc3RhcnRWYWx1ZSA9IGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQ7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICB9XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG59XG5cbi8qIGVzbGludCB2YWxpZC10eXBlb2Y6IDAgKi9cblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgXCIgKyBcInNlZWluZyB0aGlzLCB5b3UncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiBcIiArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSAgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IHZvaWQgMDtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbnZhciBTeW50aGV0aWNFdmVudCQxID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlc30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OiBmdW5jdGlvbiAoaG9zdENvbXBvbmVudEltcGwpIHtcbiAgICAvLyBUaGUgZmliZXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgZHluYW1pYyBkaXNwYXRjaCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gaW5qZWN0IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmaWJlckhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50SW1wbDtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKGZpYmVySG9zdENvbXBvbmVudCAmJiB0eXBlb2YgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRmliZXIgbmVlZHMgdG8gYmUgaW5qZWN0ZWQgdG8gaGFuZGxlIGEgZmliZXIgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxudmFyIGluamVjdGlvbiQzID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uO1xuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMyxcblx0ZW5xdWV1ZVN0YXRlUmVzdG9yZTogZW5xdWV1ZVN0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzTmVzdGluZ0JhdGNoZWQgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBpbmplY3Rpb24kNCA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSBURVhUX05PREUgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnQpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgcGFnZVg6IG51bGwsXG4gIHBhZ2VZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogbnVsbCxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbnZhciBSZWFjdEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXM6XG52YXIgTm9FZmZlY3QgPSAwOyAvLyAgICAgICAgICAgMGIwMDAwMDAwMFxudmFyIFBlcmZvcm1lZFdvcmsgPSAxOyAvLyAgICAgIDBiMDAwMDAwMDFcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gMjsgLy8gICAgICAgICAgMGIwMDAwMDAxMFxudmFyIFVwZGF0ZSA9IDQ7IC8vICAgICAgICAgICAgIDBiMDAwMDAxMDBcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSA2OyAvLyAwYjAwMDAwMTEwXG52YXIgRGVsZXRpb24gPSA4OyAvLyAgICAgICAgICAgMGIwMDAwMTAwMFxudmFyIENvbnRlbnRSZXNldCA9IDE2OyAvLyAgICAgIDBiMDAwMTAwMDBcbnZhciBDYWxsYmFjayA9IDMyOyAvLyAgICAgICAgICAwYjAwMTAwMDAwXG52YXIgRXJyID0gNjQ7IC8vICAgICAgICAgICAgICAgMGIwMTAwMDAwMFxudmFyIFJlZiA9IDEyODsgLy8gICAgICAgICAgICAgIDBiMTAwMDAwMDBcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3RbJ3JldHVybiddKSB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBfaGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xudmFyIF9oYW5kbGVUb3BMZXZlbCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0Z2V0IF9oYW5kbGVUb3BMZXZlbCAoKSB7IHJldHVybiBfaGFuZGxlVG9wTGV2ZWw7IH0sXG5cdHNldEhhbmRsZVRvcExldmVsOiBzZXRIYW5kbGVUb3BMZXZlbCxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG52YXIgQnJvd3NlckV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzJDFcbn07XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cyA9IGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG5cbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDYW5jZWwnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjYW5jZWwnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDYW5jZWwnLCAnY2FuY2VsJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENsb3NlJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2xvc2UnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDbG9zZScsICdjbG9zZScsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENsb3NlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlcy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgfVxuXG4gICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUkJDEgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZSQkMS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBlbmQgPSBsZW5ndGggKyBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICBsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG4gICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gb3V0ZXJOb2RlKSB7XG4gICAgICAgIC8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4gICAgICAgIC8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuICAgICAgICAvLyB2YWxpZCBzZWxlY3Rpb24gaXMgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGJvdGggZXF1YWwgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5uZXh0U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gc3RhcnRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSBzdGFydE1hcmtlci5vZmZzZXQgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gZW5kTWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0ID09PSBlbmRNYXJrZXIub2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24kMShmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICovXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuICAgIHdoaWxlIChhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBhbmNlc3RvcixcbiAgICAgICAgICBsZWZ0OiBhbmNlc3Rvci5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxMZWZ0ID0gaW5mby5sZWZ0O1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSB2b2lkIDA7XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG59XG5cbi8qKlxuICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gKiB0aGUgaW5wdXQuXG4gKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0LFxuICAgICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyQzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QkMSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG5cbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0ID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IG5hdGl2ZUV2ZW50VGFyZ2V0IDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIGFsbCBsaXN0ZW5lcnMgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbiAgICAvLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbiAgICBpZiAoIWRvYyB8fCAhaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcygnb25TZWxlY3QnLCBkb2MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b2dnbGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtub3duSFRNTFRvcExldmVsVHlwZXMuaW5kZXhPZih0b3BMZXZlbFR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgdG9wTGV2ZWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudCQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG5zZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCk7XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMi5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZW5hYmxlQXN5bmNTdWJ0cmVlQVBJID0gdHJ1ZTtcbnZhciBlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVDcmVhdGVSb290ID0gZmFsc2U7XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcblxue1xuICB2YXIgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleF0pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNldCQxKCkge1xuICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcik7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lck5hbWUgPSBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSB3b3JrLWluLXByb2dyZXNzIGZpYmVyIGFuZFxuLy8gb25seSBkdXJpbmcgYmVnaW4gb3IgY29tcGxldGUgcGhhc2UuIERvIG5vdCBjYWxsIGl0IHVuZGVyIGFueSBvdGhlclxuLy8gY2lyY3Vtc3RhbmNlcy5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAvLyBPdGhlcndpc2UgdGhpcyByZXR1cm4gcG9pbnRlciBtaWdodCBwb2ludCB0byB0aGUgd3JvbmcgdHJlZTpcbiAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gZmliZXI7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UocGhhc2UpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IHBoYXNlO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgcGhhc2U6IG51bGwsXG4gIHJlc2V0Q3VycmVudEZpYmVyOiByZXNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudEZpYmVyOiBzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRQaGFzZTogc2V0Q3VycmVudFBoYXNlLFxuICBnZXRDdXJyZW50RmliZXJPd25lck5hbWU6IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSxcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTogZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bVxufTtcblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXJbJ3JldHVybiddICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXJbJ3JldHVybiddKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhaXNXYWl0aW5nRm9yQ2FsbGJhY2spIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIGJlZ2luTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nJCQxID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3Vyc29yID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDb250ZXh0KCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59XG5cbnZhciBOb1dvcmsgPSAwOyAvLyBUT0RPOiBVc2UgYW4gb3BhcXVlIHR5cGUgb25jZSBFU0xpbnQgZXQgYWwgc3VwcG9ydCB0aGUgc3ludGF4XG5cbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IDIxNDc0ODM2NDc7IC8vIE1heCBpbnQzMjogTWF0aC5wb3coMiwgMzEpIC0gMVxuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNVcGRhdGVzID0gMTtcblxue1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG57XG4gIHZhciBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzWydyZXR1cm4nXSA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblxuICB0aGlzLmludGVybmFsQ29udGV4dFRhZyA9IGludGVybmFsQ29udGV4dFRhZztcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIGN1cnJlbnQua2V5LCBjdXJyZW50LmludGVybmFsQ29udGV4dFRhZyk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIE5vQ29udGV4dCk7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZSxcbiAgICAgIGtleSA9IGVsZW1lbnQua2V5O1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gY3JlYXRlRmliZXIoQ2xhc3NDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSA6IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEN1cnJlbnRseSBhc3N1bWVkIHRvIGJlIGEgY29udGludWF0aW9uIGFuZCB0aGVyZWZvcmUgaXMgYSBmaWJlciBhbHJlYWR5LlxuICAgIC8vIFRPRE86IFRoZSB5aWVsZCBzeXN0ZW0gaXMgY3VycmVudGx5IGJyb2tlbiBmb3IgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgIC8vIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmaWJlciB0aGF0IGlzO1xuICAgIC8vIHRoZSBjdXJyZW50IG9yIGEgd29ya0luUHJvZ3Jlc3M/IFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmVcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIHdlIGNhbiByZXVzZSB0aGF0IGZpYmVyIG9yIGlmIHdlIG5lZWQgdG8gY2xvbmUgaXQuXG4gICAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBjbGV2ZXIgd2F5IHRvIHJlc3RydWN0dXJlIHRoaXMuXG4gICAgZmliZXIgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudHM7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb250ZW50O1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihDYWxsQ29tcG9uZW50LCBjYWxsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIudHlwZSA9IGNhbGwuaGFuZGxlcjtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY2FsbDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihSZXR1cm5Db21wb25lbnQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwb3J0YWwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gfHwgW107XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcigpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBpc1JlYWR5Rm9yQ29tbWl0OiBmYWxzZSxcbiAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbntcbiAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbn1cblxuLy8gQ2FsbGJhY2tzIGFyZSBub3QgdmFsaWRhdGVkIHVudGlsIGludm9jYXRpb25cblxuXG4vLyBTaW5nbHkgbGlua2VkLWxpc3Qgb2YgdXBkYXRlcy4gV2hlbiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkLCBpdCBpcyBhZGRlZCB0b1xuLy8gdGhlIHF1ZXVlIG9mIHRoZSBjdXJyZW50IGZpYmVyIGFuZCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhlIHR3byBxdWV1ZXNcbi8vIGFyZSBzZXBhcmF0ZSBidXQgdGhleSBzaGFyZSBhIHBlcnNpc3RlbnQgc3RydWN0dXJlLlxuLy9cbi8vIER1cmluZyByZWNvbmNpbGlhdGlvbiwgdXBkYXRlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLFxuLy8gYnV0IHRoZXkgcmVtYWluIG9uIHRoZSBjdXJyZW50IGZpYmVyLiBUaGF0IGVuc3VyZXMgdGhhdCBpZiBhIHdvcmstaW4tcHJvZ3Jlc3Ncbi8vIGlzIGFib3J0ZWQsIHRoZSBhYm9ydGVkIHVwZGF0ZXMgYXJlIHJlY292ZXJlZCBieSBjbG9uaW5nIGZyb20gY3VycmVudC5cbi8vXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhbHdheXMgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gV2hlbiB0aGUgdHJlZSBpcyBjb21taXR0ZWQsIHRoZSB3b3JrLWluLXByb2dyZXNzIGJlY29tZXMgdGhlIGN1cnJlbnQuXG5cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0OiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuICB7XG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3QgPSBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gdXBkYXRlLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpIHtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKChxdWV1ZTEuaXNQcm9jZXNzaW5nIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBxdWV1ZTIuaXNQcm9jZXNzaW5nKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcXVldWUsIGFkZCB0aGUgdXBkYXRlIHRvIHRoYXQgcXVldWUgYW5kIGV4aXQuXG4gIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGVpdGhlciBxdWV1ZSBpcyBlbXB0eSwgd2UgbmVlZCB0byBhZGQgdG8gYm90aCBxdWV1ZXMuXG4gIGlmIChxdWV1ZTEubGFzdCA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdCA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBib3RoIGxpc3RzIGFyZSBub3QgZW1wdHksIHRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBmb3IgYm90aCBsaXN0c1xuICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIHdlIHNob3VsZCBvbmx5IGFwcGVuZCB0byBvbmUgb2ZcbiAgLy8gdGhlIGxpc3RzLlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0YCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgcXVldWUyLmxhc3QgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHJldHVybiB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAvLyBUaGVzZSBmaWVsZHMgYXJlIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIFJlc2V0IHRoZW0uXG4gICAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFNldCB0aGlzIGZsYWcgc28gd2UgY2FuIHdhcm4gaWYgc2V0U3RhdGUgaXMgY2FsbGVkIGluc2lkZSB0aGUgdXBkYXRlXG4gICAgLy8gZnVuY3Rpb24gb2YgYW5vdGhlciBzZXRTdGF0ZS5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuIElmIHdlIHNraXAgb3ZlciBhbnkgdXBkYXRlcywgd2UnbGxcbiAgLy8gaW5jcmVhc2UgdGhpcyBhY2NvcmRpbmdseS5cbiAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKHF1ZXVlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgcXVldWUuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgdmFyIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3Q7XG4gIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHF1ZXVlLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiB1cGRhdGVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIG5vIHByZXZpb3VzIHVwZGF0ZXMgd2VyZSBza2lwcGVkLCBkcm9wIHRoaXMgdXBkYXRlIGZyb20gdGhlIHF1ZXVlIGJ5XG4gICAgLy8gYWR2YW5jaW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgcXVldWUuZmlyc3QgPSB1cGRhdGUubmV4dDtcbiAgICAgIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSB1cGRhdGVcbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWU6IElkayBob3cgdG8gdHlwZSB0aGlzIHByb3Blcmx5LlxuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBxdWV1ZS5oYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBsaXN0IG9mIGNhbGxiYWNrcy5cbiAgICAgIHZhciBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICAgICAgaWYgKF9jYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrTGlzdC5wdXNoKHVwZGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKHF1ZXVlLmNhbGxiYWNrTGlzdCAhPT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfSBlbHNlIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCAmJiAhcXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHkuIFdlIGNhbiByZXNldCBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWRpZFNraXApIHtcbiAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gIGlmIChjYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXBkYXRlID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgLy8gVGhpcyB1cGRhdGUgbWlnaHQgYmUgcHJvY2Vzc2VkIGFnYWluLiBDbGVhciB0aGUgY2FsbGJhY2sgc28gaXQncyBvbmx5XG4gICAgLy8gY2FsbGVkIG9uY2UuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gbnVsbDtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgLy8gQ2xhc3MgY29tcG9uZW50IHN0YXRlIHVwZGF0ZXJcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IHRydWUsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID0gIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdGFuY2Uuc3RhdGU7XG4gICAgICB3YXJuaW5nKG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICAgd2FybmluZyhub0dldERlZmF1bHRQcm9wc09uRVM2LCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VQcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZUNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlRGVmYXVsdFByb3BzLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZC4gKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyhmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgIShuZXh0UHJvcHMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgIXVzZVN5bmNTY2hlZHVsaW5nICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKSkge1xuICAgICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAvLyBCYWlsb3V0IGFuZCBjb21lIGJhY2sgdG8gdGhpcyBmaWJlciBsYXRlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICEoY3VycmVudCA9PT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgaGF2ZSBtb3VudGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciB2YWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChmbi5wcm90b3R5cGUgJiYgdHlwZW9mIGZuLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDYWxsID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDYWxsID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENhbGwgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDYWxsID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDYWxsKSB7XG4gICAgICBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBUT0RPOiBXaGVuIGJhaWxpbmcgb3V0LCB3ZSBtaWdodCBuZWVkIHRvIHJldHVybiB0aGUgc3RhdGVOb2RlIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBjaGlsZC4gVG8gY2hlY2sgaXQgZm9yIHdvcmsuXG4gICAgICAvLyByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDYWxsLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlcnJvciAmJiBlcnJvci5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICBpZiAoc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nICcgKyAnY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCAnICsgJ29yIGZvcmNlVXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgJyArICdjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBob3N0Q29udGV4dCA9IFJlYWN0RmliZXJIb3N0Q29udGV4dChjb25maWcpO1xuICB2YXIgaHlkcmF0aW9uQ29udGV4dCA9IFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0KGNvbmZpZyk7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICByZXNldEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5yZXNldEhvc3RDb250YWluZXI7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQmVnaW5Xb3JrID0gUmVhY3RGaWJlckJlZ2luV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lIGluIG1zLlxuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgdmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCgpO1xuICAgIHJlc2V0SG9zdENvbnRhaW5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICB9XG4gICAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+KENhbGxiYWNrIHwgRXJyIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgUGVyZm9ybWVkV29yayk7XG4gICAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSb290KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9XG5cbiAgICBwcmVwYXJlRm9yQ29tbWl0KCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjYXVnaHQgYW55IGVycm9ycyBkdXJpbmcgdGhpcyBjb21taXQsIHNjaGVkdWxlIHRoZWlyIGJvdW5kYXJpZXNcbiAgICAvLyB0byB1cGRhdGUuXG4gICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcykge1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmZvckVhY2goc2NoZWR1bGVFcnJvclJlY292ZXJ5KTtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgb25VbmNhdWdodEVycm9yKF9lcnJvcjMpO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ1RpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gICAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICAgIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IENhbGxzIG5lZWQgdG8gdmlzaXQgc3RhdGVOb2RlXG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5leHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3NbJ3JldHVybiddO1xuICAgICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICAgIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbkZhaWxlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgdW5oYW5kbGVkIGVycm9ycywgc3dpdGNoIHRvIHRoZSBzbG93IHdvcmsgbG9vcC5cbiAgICAgIC8vIFRPRE86IEhvdyB0byBhdm9pZCB0aGlzIGNoZWNrIGluIHRoZSBmYXN0IHBhdGg/IE1heWJlIHRoZSByZW5kZXJlclxuICAgICAgLy8gY291bGQga2VlcCB0cmFjayBvZiB3aGljaCByb290cyBoYXZlIHVuaGFuZGxlZCBlcnJvcnMgYW5kIGNhbGwgYVxuICAgICAgLy8gZm9ya2VkIHZlcnNpb24gb2YgcmVuZGVyUm9vdC5cbiAgICAgIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdENhdGNoQmxvY2socm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gcmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IuXG4gICAgLy8gQ29uY2VwdHVhbGx5LCB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLiBXZSBuZWVkIHRvIHVud2luZCB0aGVcbiAgICAvLyBjb250ZXh0IHN0YWNrLCB0b28uXG4gICAgdW53aW5kQ29udGV4dHMoZmFpbGVkV29yaywgYm91bmRhcnkpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdXNpbmcgYSBmb3JrZWQgdmVyc2lvbiBvZlxuICAgIC8vIHBlcmZvcm1Vbml0T2ZXb3JrIHRoYXQgZGVsZXRlcyB0aGUgYm91bmRhcnkncyBjaGlsZHJlbi4gVGhlIGVudGlyZVxuICAgIC8vIGZhaWxlZCBzdWJyZWUgd2lsbCBiZSB1bm1vdW50ZWQuIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCBhIHNwZWNpYWxcbiAgICAvLyBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgZXJyb3IgYm91bmRhcnksIHdoaWNoIHRyaWdnZXJzXG4gICAgLy8gYSByZS1yZW5kZXIuXG4gICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhib3VuZGFyeSk7XG5cbiAgICAvLyBDb250aW51ZSB3b3JraW5nLlxuICAgIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gV2UncmUgYWJvdXQgdG8gbXV0YXRlIHRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUuIElmIHRoZSByb290IHdhcyBwZW5kaW5nXG4gICAgLy8gY29tbWl0LCBpdCBubyBsb25nZXIgaXM6IHdlJ2xsIG5lZWQgdG8gY29tcGxldGUgaXQgYWdhaW4uXG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgICAvLyBwcmV2aW91c2x5IHlpZWxkZWQgd29yay5cbiAgICBpZiAocm9vdCAhPT0gbmV4dFJvb3QgfHwgZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgICByZXNldENvbnRleHRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCB3b3JrTG9vcCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHdoaWxlIChkaWRFcnJvcikge1xuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgZmF0YWwgZXJyb3IuIERvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWlsZWRXb3JrID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBpZiAoZmFpbGVkV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGJ1dCB0aGVyZSdzIG5vIGN1cnJlbnQgdW5pdCBvZiB3b3JrLiBUaGlzIGNhblxuICAgICAgICAvLyBoYXBwZW4gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiQ2FwdHVyZVwiIHRoZSBlcnJvciBieSBmaW5kaW5nIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LiBJZiB0aGVyZSBpcyBub1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIHdlIHVzZSB0aGUgcm9vdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcik7XG4gICAgICAhKGJvdW5kYXJ5ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIHdlIGp1c3QgY2FwdHVyZWQgd2FzIGEgZmF0YWwgZXJyb3IuIFRoaXMgaGFwcGVuc1xuICAgICAgICAvLyB3aGVuIHRoZSBlcnJvciBwcm9wYWdhdGVzIHRvIHRoZSByb290IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgcmVuZGVyUm9vdENhdGNoQmxvY2ssIG51bGwsIHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSdyZSBmaW5pc2hlZCB3b3JraW5nLiBFeGl0IHRoZSBlcnJvciBsb29wLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHVuY2F1Z2h0RXJyb3IgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG5cbiAgICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgICBpZiAodW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgb25VbmNhdWdodEVycm9yKHVuY2F1Z2h0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiByb290LmlzUmVhZHlGb3JDb21taXQgPyByb290LmN1cnJlbnQuYWx0ZXJuYXRlIDogbnVsbDtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLCBvciBudWxsIGlmIHRoZSBlcnJvciBpcyBpZ25vcmVkXG4gIGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcikge1xuICAgIC8vIEl0IGlzIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHdlIGV4aXRlZCB0aGUgdXNlciBjb2RlLlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LlxuICAgIHZhciBib3VuZGFyeSA9IG51bGw7XG5cbiAgICAvLyBQYXNzZWQgdG8gbG9nQ2FwdHVyZWRFcnJvcigpXG4gICAgdmFyIGVycm9yQm91bmRhcnlGb3VuZCA9IGZhbHNlO1xuICAgIHZhciB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuXG4gICAgLy8gSG9zdCBjb250YWluZXJzIGFyZSBhIHNwZWNpYWwgY2FzZS4gSWYgdGhlIGZhaWxlZCB3b3JrIGl0c2VsZiBpcyBhIGhvc3RcbiAgICAvLyBjb250YWluZXIsIHRoZW4gaXQgYWN0cyBhcyBpdHMgb3duIGJvdW5kYXJ5LiBJbiBhbGwgb3RoZXIgY2FzZXMsIHdlXG4gICAgLy8gaWdub3JlIHRoZSB3b3JrIGl0c2VsZiBhbmQgb25seSBzZWFyY2ggdGhyb3VnaCB0aGUgcGFyZW50cy5cbiAgICBpZiAoZmFpbGVkV29yay50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBib3VuZGFyeSA9IGZhaWxlZFdvcms7XG5cbiAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KGZhaWxlZFdvcmspKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vdCBhbHJlYWR5IGZhaWxlZCwgdGhlcmUgbXVzdCBoYXZlIGJlZW4gYW4gZXJyb3Igd2hlblxuICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHVubW91bnQgaXQuIFRoaXMgaXMgYSB3b3JzdC1jYXNlIHNjZW5hcmlvIGFuZFxuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBwb3NzaWJsZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGZhaWxlZFdvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5IVxuICAgICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgLy8gVHJlYXQgdGhlIHJvb3QgbGlrZSBhIG5vLW9wIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkobm9kZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgaW4gYSBmYWlsZWQgc3RhdGUuXG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZywgdGhhdCBtZWFucyB0aGlzIGVycm9yIHdhc1xuICAgICAgICAgIC8vIHRocm93biB3aGlsZSB1bm1vdW50aW5nIGEgZmFpbGVkIHN1YnRyZWUuIFdlIHNob3VsZCBpZ25vcmVcbiAgICAgICAgICAvLyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKGlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgd2Ugc2hvdWxkIGNoZWNrIHRvIHNlZSBpZlxuICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhpcyBjb21taXQuXG4gICAgICAgICAgLy8gVGhpcyBjYXNlIGV4aXN0cyBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBjYW4gYmUgdGhyb3duIGR1cmluZ1xuICAgICAgICAgIC8vIGEgc2luZ2xlIGNvbW1pdCB3aXRob3V0IGludGVycnVwdGlvbi5cbiAgICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzICE9PSBudWxsICYmIChjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUpIHx8IG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZS5hbHRlcm5hdGUpKSkge1xuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCBpZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5IC3igJQgd2Uga2VlcCBsb29raW5nLlxuICAgICAgICAgIGJvdW5kYXJ5ID0gbnVsbDtcbiAgICAgICAgICB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBmYWlsZWQgYm91bmRhcmllcy4gVGhpcyBsZXRzIHVzIGtub3cgdGhhdFxuICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnMgaW4gdGhpcyBzdWJ0cmVlIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpcyB1bnNhZmUgb3V0c2lkZSBvZiB0aGUgYmVnaW4gYW5kIGNvbXBsZXRlIHBoYXNlcy5cbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBjb21taXQgcGhhc2Ugd2hlbiBhbiBlcnJvciBpcyBjYXB0dXJlZC5cbiAgICAgIC8vIFRoZSByaXNrIGlzIHRoYXQgdGhlIHJldHVybiBwYXRoIGZyb20gdGhpcyBGaWJlciBtYXkgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgLy8gVGhhdCByaXNrIGlzIGFjY2VwdGFibGUgZ2l2ZW4gdGhlIGJlbmVmaXQgb2YgcHJvdmlkaW5nIHVzZXJzIG1vcmUgY29udGV4dC5cbiAgICAgIHZhciBfY29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmYWlsZWRXb3JrKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNhcHR1cmVkIGVycm9ycy4gVGhpcyBpcyBzdG9yZWQgYXMgYSBnbG9iYWxcbiAgICAgIC8vIG1hcCBvZiBlcnJvcnMgYW5kIHRoZWlyIGNvbXBvbmVudCBzdGFjayBsb2NhdGlvbiBrZXllZCBieSB0aGUgYm91bmRhcmllc1xuICAgICAgLy8gdGhhdCBjYXB0dXJlIHRoZW0uIFdlIG1vc3RseSB1c2UgdGhpcyBNYXAgYXMgYSBTZXQ7IGl0J3MgYSBNYXAgb25seSB0b1xuICAgICAgLy8gYXZvaWQgYWRkaW5nIGEgZmllbGQgdG8gRmliZXIgdG8gc3RvcmUgdGhlIGVycm9yLlxuICAgICAgaWYgKGNhcHR1cmVkRXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIGNhcHR1cmVkRXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogX2NvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBfY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeTogZXJyb3JCb3VuZGFyeUZvdW5kID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBlcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lOiBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgd2lsbFJldHJ5OiB3aWxsUmV0cnlcbiAgICAgIH07XG5cbiAgICAgIGNhcHR1cmVkRXJyb3JzLnNldChib3VuZGFyeSwgY2FwdHVyZWRFcnJvcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAgICAgLy8gQSBjeWNsZSBtYXkgc3RpbGwgb2NjdXIgaWYgbG9nQ2FwdHVyZWRFcnJvciByZW5kZXJzIGEgY29tcG9uZW50IHRoYXQgdGhyb3dzLlxuICAgICAgICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZSAmJiBlLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gICAgICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCBkZWZlciBzY2hlZHVsaW5nIGFuIHVwZGF0ZSBvbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHVudGlsIGFmdGVyIHRoZSBjb21taXQgaXMgY29tcGxldGVcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2NoZWR1bGUgYW4gdXBkYXRlIG5vdy5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY3R1YWxseSBuZWNlc3NhcnkgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U/IElzIGl0XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIHVud2luZCBhbmQgY29udGludWUgcmVuZGVyaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5LFxuICAgICAgICAvLyB3aXRob3V0IGNvcnJ1cHRpbmcgaW50ZXJuYWwgc3RhdGU/XG4gICAgICAgIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShib3VuZGFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSBlbHNlIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIG5vIGJvdW5kYXJ5IGlzIGZvdW5kLCB3ZSdsbCBuZWVkIHRvIHRocm93IHRoZSBlcnJvclxuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2FwdHVyZWRFcnJvcihmaWJlcikge1xuICAgIC8vIFRPRE86IGNhcHR1cmVkRXJyb3JzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkIG5lZWRpbmdcbiAgICAvLyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCAmJiAoY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsZWRCb3VuZGFyeShmaWJlcikge1xuICAgIC8vIFRPRE86IGZhaWxlZEJvdW5kYXJpZXMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWRcbiAgICAvLyBuZWVkaW5nIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFcnJvckhhbmRsaW5nKGVmZmVjdGZ1bEZpYmVyKSB7XG4gICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICBpZiAoY2FwdHVyZWRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBlZmZlY3RmdWxGaWJlciA9IGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjYXB0dXJlZEVycm9yICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnTm8gZXJyb3IgZm9yIGdpdmVuIHVuaXQgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHN3aXRjaCAoZWZmZWN0ZnVsRmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBlZmZlY3RmdWxGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgYm91bmRhcnkgdG8gaGFuZGxlIHRoZSBlcnJvciwgdXN1YWxseSBieSBzY2hlZHVsaW5nXG4gICAgICAgIC8vIGFuIHVwZGF0ZSB0byBpdHNlbGZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goY2FwdHVyZWRFcnJvci5lcnJvciwgaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud2luZENvbnRleHRzKGZyb20sIHRvKSB7XG4gICAgdmFyIG5vZGUgPSBmcm9tO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdG8gfHwgbm9kZS5hbHRlcm5hdGUgPT09IHRvKSB7XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcihub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCkge1xuICAgIC8vIEdpdmVuIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUsIHJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lLiBXZSB1c2Ugcm91bmRpbmdcbiAgICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gICAgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiB+MTAwMG1zLiAxMjAwbXMgbWF4LlxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gMTAwMDtcbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMjAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICBpZiAoZXhwaXJhdGlvbkNvbnRleHQgIT09IE5vV29yaykge1xuICAgICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSBpZiAoaXNXb3JraW5nKSB7XG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAgIC8vIHRoZSB3b3JrIHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh1c2VTeW5jU2NoZWR1bGluZyAmJiAhKGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBSZXN0YXJ0IHRoZSByb290IGZyb20gdGhlIHRvcC5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbmV4dFJvb3QgPSBudWxsO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgY2FsbGJhY2tJRCA9IC0xO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayhjYWxsYmFja0lEKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG5cbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHksIGlmIGl0J3MgaGlnaGVyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICAgIGlmIChwcmV2aW91c0ZsdXNoZWRSb290ICE9PSBudWxsICYmIHByZXZpb3VzRmx1c2hlZFJvb3QgPT09IGhpZ2hlc3RQcmlvcml0eVJvb3QpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICAgIGRlYWRsaW5lID0gZGw7XG5cbiAgICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAgIC8vIHRoZSBkZWFkbGluZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkgJiYgZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8PSBtaW5FeHBpcmF0aW9uVGltZSkgJiYgIWRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBoaWdoZXN0IHByaW9yaXR5IHdvcmsuXG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAgIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIGNhbGxiYWNrSUQgPSAtMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sXG4vLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydCBvZiB0aGUgZnJhbWUsIHRoZW5cbi8vIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC4gV2l0aGluIHRoZVxuLy8gcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lIHJhdGUuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbntcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbnZhciBub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcbnZhciBjSUMgPSB2b2lkIDA7XG5cbmlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHJJQyA9IGZ1bmN0aW9uIChmcmFtZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnJhbWVDYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjSUMgPSBmdW5jdGlvbiAodGltZW91dElEKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuLy8gaXNBdHRyaWJ1dGVOYW1lU2FmZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNob3VsZElnbm9yZVZhbHVlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xuXG5cblxuXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCB8fCBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eUluZm8gJiYgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbi8qKlxuICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cblxuLyoqXG4gKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIGdldFN0YWNrKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBnZXRTdGFjayk7XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgbWluOiB1bmRlZmluZWQsXG4gICAgbWF4OiB1bmRlZmluZWRcbiAgfSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgLy8gTm90ZTogSUU5IHJlcG9ydHMgYSBudW1iZXIgaW5wdXRzIGFzICd0ZXh0Jywgc28gY2hlY2sgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICB2YXIgdmFsdWVBc051bWJlciA9IHBhcnNlRmxvYXQobm9kZS52YWx1ZSkgfHwgMDtcblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSAhPSB2YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbiAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgLy8gcHJvdmlkZWQuXG5cbiAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICdyZXNldCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb2xvcic6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAndGltZSc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLiVzJywgZ2V0U3RhY2soKSk7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0oKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgY29ycmVjdE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gICdpbic6ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gICd0eXBlb2YnOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IGlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKCFzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHZhciB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBDaHJvbWUgaXMgdGhlIG9ubHkgbWFqb3IgYnJvd3NlciBub3Qgc2hpcHBpbmcgPHRpbWU+LiBCdXQgYXMgb2YgSnVseVxuICAgIC8vIDIwMTcgaXQgaW50ZW5kcyB0byBzaGlwIGl0IGR1ZSB0byB3aWRlc3ByZWFkIHVzYWdlLiBXZSBpbnRlbnRpb25hbGx5XG4gICAgLy8gKmRvbid0KiB3YXJuIGZvciA8dGltZT4gZXZlbiBpZiBpdCdzIHVucmVjb2duaXplZCBieSBDaHJvbWUgYmVjYXVzZVxuICAgIC8vIGl0IHNvb24gd2lsbCBiZSwgYW5kIG1hbnkgYXBwcyBoYXZlIGJlZW4gdXNpbmcgaXQgYW55d2F5LlxuICAgIHRpbWU6IHRydWUsXG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgdmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB2YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJywgbm9ybWFsaXplZFNlcnZlclRleHQsIG5vcm1hbGl6ZWRDbGllbnRUZXh0KTtcbiAgfTtcblxuICB2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJXMnLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuICB2YXIgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICB3YXJuaW5nKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjayk7XG5cbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMsIGdldFN0YWNrKTtcblxuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMkMShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhciBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbztcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAoZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxKHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxKHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlJDEsXG5cdHNldEluaXRpYWxQcm9wZXJ0aWVzOiBzZXRJbml0aWFsUHJvcGVydGllcyQxLFxuXHRkaWZmUHJvcGVydGllczogZGlmZlByb3BlcnRpZXMkMSxcblx0dXBkYXRlUHJvcGVydGllczogdXBkYXRlUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFRleHQ6IGRpZmZIeWRyYXRlZFRleHQkMSxcblx0d2FybkZvclVubWF0Y2hlZFRleHQ6IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxLFxuXHRyZXN0b3JlQ29udHJvbGxlZFN0YXRlOiByZXN0b3JlQ29udHJvbGxlZFN0YXRlXG59KTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvJDEgPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoY2hpbGRUYWcgPT0gbnVsbCwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nJDEgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBjcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xudmFyIGNyZWF0ZVRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUkMTtcbnZhciBzZXRJbml0aWFsUHJvcGVydGllcyA9IHNldEluaXRpYWxQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZlByb3BlcnRpZXMgPSBkaWZmUHJvcGVydGllcyQxO1xudmFyIHVwZGF0ZVByb3BlcnRpZXMgPSB1cGRhdGVQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkUHJvcGVydGllcyA9IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRUZXh0ID0gZGlmZkh5ZHJhdGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JVbm1hdGNoZWRUZXh0ID0gd2FybkZvclVubWF0Y2hlZFRleHQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDE7XG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZyQxLnVwZGF0ZWRBbmNlc3RvckluZm87XG52YXIgcHJlY2FjaGVGaWJlck5vZGUgPSBwcmVjYWNoZUZpYmVyTm9kZSQxO1xudmFyIHVwZGF0ZUZpYmVyUHJvcHMgPSB1cGRhdGVGaWJlclByb3BzJDE7XG5cblxue1xuICB2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fCBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5pbmplY3Rpb24kMy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KFJlYWN0RE9NRmliZXJDb21wb25lbnQpO1xuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRE9NUmVuZGVyZXIgPSByZWFjdFJlY29uY2lsZXIoe1xuICBnZXRSb290SG9zdENvbnRleHQ6IGZ1bmN0aW9uIChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocGFyZW50SG9zdENvbnRleHQsIHR5cGUpIHtcbiAgICB7XG4gICAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvMiA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICAgIH1cbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG4gIH0sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0sXG4gIHByZXBhcmVGb3JDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICAgIHNldEVuYWJsZWQoZmFsc2UpO1xuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICAgIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gICAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIH0sXG4gIGNyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgfVxuICAgIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIH0sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbiAgfSxcbiAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuICEhcHJvcHMuaGlkZGVuO1xuICB9LFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgICByZXR1cm4gdGV4dE5vZGU7XG4gIH0sXG5cblxuICBub3c6IG5vdyxcblxuICBtdXRhdGlvbjoge1xuICAgIGNvbW1pdE1vdW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gICAgICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9LFxuICAgIHJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gICAgICBkb21FbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfSxcbiAgICBjb21taXRUZXh0VXBkYXRlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaHlkcmF0aW9uOiB7XG4gICAgY2FuSHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgaHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgICAgIC8vIGdldCBhdHRhY2hlZC5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICB9LFxuICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICAgICAge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazogcklDLFxuICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrOiBjSUMsXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6ICFlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NXG59KTtcblxuaW5qZWN0aW9uJDQuaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyhET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybmluZyhob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHNob3VsZEh5ZHJhdGUpO1xuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG5ld1Jvb3Q7XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIG5ld1Jvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgdGhpcy5fcmVhY3RSb290Q29udGFpbmVyID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZyh3YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSBnZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoaW5zdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlLiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1YixcbiAgICAvLyBVc2VkIGJ5IHRlc3QtdXRpbHNcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudFBsdWdpblJlZ2lzdHJ5LFxuICAgIEV2ZW50UHJvcGFnYXRvcnM6IEV2ZW50UHJvcGFnYXRvcnMsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQsXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUsXG4gICAgUmVhY3RET01FdmVudExpc3RlbmVyOiBSZWFjdERPTUV2ZW50TGlzdGVuZXJcbiAgfVxufTtcblxuaWYgKGVuYWJsZUNyZWF0ZVJvb3QpIHtcbiAgUmVhY3RET00uY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICAgIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIH07XG59XG5cbnZhciBmb3VuZERldlRvb2xzID0gRE9NUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAxLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxudmFyIFJlYWN0RE9NJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01cbn0pO1xuXG52YXIgUmVhY3RET00kMyA9ICggUmVhY3RET00kMiAmJiBSZWFjdERPTSApIHx8IFJlYWN0RE9NJDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0RG9tID0gUmVhY3RET00kM1snZGVmYXVsdCddID8gUmVhY3RET00kM1snZGVmYXVsdCddIDogUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG5cbnZhciBCcm93c2VyUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJyb3dzZXJSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcm93c2VyUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxCcm93c2VyUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gQnJvd3NlclJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQnJvd3NlclJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmb3JjZVJlZnJlc2g6IFByb3BUeXBlcy5ib29sLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShfRE9NVXRpbHMuY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gISgwLCBfRE9NVXRpbHMuc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSkoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBfRE9NVXRpbHMuZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoIWJhc2VuYW1lIHx8ICgwLCBfUGF0aFV0aWxzLmhhc0Jhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gKDAsIF9QYXRoVXRpbHMuc3RyaXBCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmICgoMCwgX0RPTVV0aWxzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQpKGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnknO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIHdpbmRvdy5sb2NhdGlvbi5oYXNoLlxuICovXG5cbnZhciBIYXNoUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEhhc2hSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhhc2hSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIYXNoUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxIYXNoUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEhhc2hSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIEhhc2hSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gSGFzaFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuSGFzaFJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgaGFzaFR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2hhc2hiYW5nJywgJ25vc2xhc2gnLCAnc2xhc2gnXSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBIYXNoUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0hhc2hSb3V0ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArICgwLCBfUGF0aFV0aWxzLnN0cmlwTGVhZGluZ1NsYXNoKShwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogX1BhdGhVdGlscy5zdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgY3JlYXRlSGFzaEhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoX0RPTVV0aWxzLmNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKSgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gX0RPTVV0aWxzLmdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRoYXNoVHlwZSA9IHByb3BzLmhhc2hUeXBlLFxuICAgICAgaGFzaFR5cGUgPSBfcHJvcHMkaGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/ICdzbGFzaCcgOiBfcHJvcHMkaGFzaFR5cGU7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyAoMCwgX1BhdGhVdGlscy5zdHJpcFRyYWlsaW5nU2xhc2gpKCgwLCBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCkocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCFiYXNlbmFtZSB8fCAoMCwgX1BhdGhVdGlscy5oYXNCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcHJvcGVybHktZW5jb2RlZCBoYXNoLlxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgICBpZiAoIWZvcmNlTmV4dFBvcCAmJiAoMCwgX0xvY2F0aW9uVXRpbHMubG9jYXRpb25zQXJlRXF1YWwpKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpIHJldHVybjsgLy8gSWdub3JlIHRoaXMgY2hhbmdlOyB3ZSBhbHJlYWR5IHNldFN0YXRlIGluIHB1c2gvcmVwbGFjZS5cblxuICAgICAgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgICAgIGhhbmRsZVBvcChsb2NhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2YgcGF0aHMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3IgcGF0aHMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkodG9Mb2NhdGlvbikpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFsoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShpbml0aWFsTG9jYXRpb24pXTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICcjJyArIGVuY29kZVBhdGgoYmFzZW5hbWUgKyAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGhpc3RvcnkubG9jYXRpb24pKTtcblxuICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbFBhdGhzW3ByZXZJbmRleF0gPSBwYXRoO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoY2FuR29XaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJyk7XG5cbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVIYXNoSGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgTWVtb3J5Um91dGVyIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBNZW1vcnlSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTWVtb3J5Um91dGVyLmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGxvY2F0aW9uIGluIG1lbW9yeS5cbiAqL1xuXG52YXIgTWVtb3J5Um91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lbW9yeVJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVtb3J5Um91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPE1lbW9yeVJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBNZW1vcnlSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBNZW1vcnlSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGluaXRpYWxJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IF9QYXRoVXRpbHMuY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSb3V0ZSBmcm9tICcuL1JvdXRlJztcbmltcG9ydCBMaW5rIGZyb20gJy4vTGluayc7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWYuYXJpYUN1cnJlbnQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG8nLCAnZXhhY3QnLCAnc3RyaWN0JywgJ2xvY2F0aW9uJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdjbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnc3R5bGUnLCAnaXNBY3RpdmUnLCAnYXJpYUN1cnJlbnQnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICBwYXRoOiAodHlwZW9mIHRvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0bykpID09PSAnb2JqZWN0JyA/IHRvLnBhdGhuYW1lIDogdG8sXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIHN0cmljdDogc3RyaWN0LFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oX3JlZjIpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF9yZWYyLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoID0gX3JlZjIubWF0Y2g7XG5cbiAgICAgIHZhciBpc0FjdGl2ZSA9ICEhKGdldElzQWN0aXZlID8gZ2V0SXNBY3RpdmUobWF0Y2gsIGxvY2F0aW9uKSA6IG1hdGNoKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe1xuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNsYXNzTmFtZTogaXNBY3RpdmUgPyBbY2xhc3NOYW1lLCBhY3RpdmVDbGFzc05hbWVdLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS5qb2luKCcgJykgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGUsXG4gICAgICAgICdhcmlhLWN1cnJlbnQnOiBpc0FjdGl2ZSAmJiBhcmlhQ3VycmVudFxuICAgICAgfSwgcmVzdCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5OYXZMaW5rLnByb3BUeXBlcyA9IHtcbiAgdG86IExpbmsucHJvcFR5cGVzLnRvLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBhY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYWN0aXZlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBpc0FjdGl2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGFyaWFDdXJyZW50OiBQcm9wVHlwZXMub25lT2YoWydwYWdlJywgJ3N0ZXAnLCAnbG9jYXRpb24nLCAndHJ1ZSddKVxufTtcblxuTmF2TGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZScsXG4gIGFyaWFDdXJyZW50OiAndHJ1ZSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5hdkxpbms7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qcyIsInZhciBpc2FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJylcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdXG4gIHZhciBrZXkgPSAwXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIHBhdGggPSAnJ1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nXG4gIHZhciByZXNcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdXG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV1cbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoXG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XVxuICAgIHZhciBwcmVmaXggPSByZXNbMl1cbiAgICB2YXIgbmFtZSA9IHJlc1szXVxuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdXG4gICAgdmFyIGdyb3VwID0gcmVzWzVdXG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdXG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddXG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKVxuICAgICAgcGF0aCA9ICcnXG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlclxuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cFxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KVxuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KVxuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpXG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fVxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fVxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXVxuICAgICAgdmFyIHNlZ21lbnRcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKVxuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKVxuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXNcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpXG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdFxuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlXG4gIHZhciByb3V0ZSA9ICcnXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KVxuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSdcblxuICAgICAga2V5cy5wdXNoKHRva2VuKVxuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJ1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknXG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmVcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJylcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXJcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/J1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJ1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSdcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBQcm9tcHQgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1Byb21wdCc7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwcm9tcHRpbmcgdGhlIHVzZXIgYmVmb3JlIG5hdmlnYXRpbmcgYXdheVxuICogZnJvbSBhIHNjcmVlbiB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbnZhciBQcm9tcHQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJvbXB0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQcm9tcHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb21wdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFByb21wdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB0aGlzLnVuYmxvY2soKTtcblxuICAgIHRoaXMudW5ibG9jayA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5ibG9jayhtZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLnVuYmxvY2spIHtcbiAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgdGhpcy51bmJsb2NrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFByb21wdD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy53aGVuKSB0aGlzLmVuYWJsZSh0aGlzLnByb3BzLm1lc3NhZ2UpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy53aGVuKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMud2hlbiB8fCB0aGlzLnByb3BzLm1lc3NhZ2UgIT09IG5leHRQcm9wcy5tZXNzYWdlKSB0aGlzLmVuYWJsZShuZXh0UHJvcHMubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFByb21wdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUHJvbXB0LnByb3BUeXBlcyA9IHtcbiAgd2hlbjogUHJvcFR5cGVzLmJvb2wsXG4gIG1lc3NhZ2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSkuaXNSZXF1aXJlZFxufTtcblByb21wdC5kZWZhdWx0UHJvcHMgPSB7XG4gIHdoZW46IHRydWVcbn07XG5Qcm9tcHQuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGJsb2NrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1Byb21wdC5qcyIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUmVkaXJlY3QgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgUmVkaXJlY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUmVkaXJlY3QuanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tICdoaXN0b3J5JztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgdXBkYXRpbmcgdGhlIGxvY2F0aW9uIHByb2dyYW1tYXRpY2FsbHlcbiAqIHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxudmFyIFJlZGlyZWN0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlZGlyZWN0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZWRpcmVjdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVkaXJlY3QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBSZWRpcmVjdC5wcm90b3R5cGUuaXNTdGF0aWMgPSBmdW5jdGlvbiBpc1N0YXRpYygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJvdXRlciAmJiB0aGlzLmNvbnRleHQucm91dGVyLnN0YXRpY0NvbnRleHQ7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8UmVkaXJlY3Q+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgaWYgKHRoaXMuaXNTdGF0aWMoKSkgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIHByZXZUbyA9IGNyZWF0ZUxvY2F0aW9uKHByZXZQcm9wcy50byk7XG4gICAgdmFyIG5leHRUbyA9IGNyZWF0ZUxvY2F0aW9uKHRoaXMucHJvcHMudG8pO1xuXG4gICAgaWYgKGxvY2F0aW9uc0FyZUVxdWFsKHByZXZUbywgbmV4dFRvKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1lvdSB0cmllZCB0byByZWRpcmVjdCB0byB0aGUgc2FtZSByb3V0ZSB5b3VcXCdyZSBjdXJyZW50bHkgb246ICcgKyAoJ1wiJyArIG5leHRUby5wYXRobmFtZSArIG5leHRUby5zZWFyY2ggKyAnXCInKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiBwZXJmb3JtKCkge1xuICAgIHZhciBoaXN0b3J5ID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5O1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBwdXNoID0gX3Byb3BzLnB1c2gsXG4gICAgICAgIHRvID0gX3Byb3BzLnRvO1xuXG5cbiAgICBpZiAocHVzaCkge1xuICAgICAgaGlzdG9yeS5wdXNoKHRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKHRvKTtcbiAgICB9XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUmVkaXJlY3Q7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJlZGlyZWN0LnByb3BUeXBlcyA9IHtcbiAgcHVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGZyb206IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZFxufTtcblJlZGlyZWN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgcHVzaDogZmFsc2Vcbn07XG5SZWRpcmVjdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzIiwiaW1wb3J0IF9jcmVhdGVCcm93c2VySGlzdG9yeSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVCcm93c2VySGlzdG9yeSBhcyBjcmVhdGVCcm93c2VySGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVIYXNoSGlzdG9yeSBmcm9tICcuL2NyZWF0ZUhhc2hIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIYXNoSGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGZyb20gJy4vY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVNZW1vcnlIaXN0b3J5IH07XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanMiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzSGlzdG9yeSwgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSwgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gIXN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBMZWFkaW5nU2xhc2gsIHN0cmlwVHJhaWxpbmdTbGFzaCwgaGFzQmFzZW5hbWUsIHN0cmlwQmFzZW5hbWUsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBjYW5Vc2VET00sIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGdldENvbmZpcm1hdGlvbiwgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpO1xuICAgIH0sXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbiAgICB9XG4gIH0sXG4gIG5vc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBzdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgY3JlYXRlSGFzaEhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhbkdvV2l0aG91dFJlbG9hZCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG5cbiAgdmFyIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIF9IYXNoUGF0aENvZGVycyRoYXNoVCA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXSxcbiAgICAgIGVuY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZW5jb2RlUGF0aCxcbiAgICAgIGRlY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZGVjb2RlUGF0aDtcblxuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgbG9jYXRpb25zQXJlRXF1YWwocHJldkxvY2F0aW9uLCBsb2NhdGlvbikpIHJldHVybjsgLy8gQSBoYXNoY2hhbmdlIGRvZXNuJ3QgYWx3YXlzID09IGxvY2F0aW9uIGNoYW5nZS5cblxuICAgICAgaWYgKGlnbm9yZVBhdGggPT09IGNyZWF0ZVBhdGgobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgodG9Mb2NhdGlvbikpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGZyb21Mb2NhdGlvbikpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseSBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZS5cbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgdmFyIGFsbFBhdGhzID0gW2NyZWF0ZVBhdGgoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbikpO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgICB2YXIgbmV4dFBhdGhzID0gYWxsUGF0aHMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICBuZXh0UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgYWxsUGF0aHMgPSBuZXh0UGF0aHM7XG5cbiAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoOyBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaycpO1xuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUkVQTEFDRSwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB3YXJuaW5nKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSGFzaEhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IHsgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS5cbiAqL1xudmFyIGNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPSBwcm9wcy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX3Byb3BzJGluaXRpYWxFbnRyaWVzID09PSB1bmRlZmluZWQgPyBbJy8nXSA6IF9wcm9wcyRpbml0aWFsRW50cmllcyxcbiAgICAgIF9wcm9wcyRpbml0aWFsSW5kZXggPSBwcm9wcy5pbml0aWFsSW5kZXgsXG4gICAgICBpbml0aWFsSW5kZXggPSBfcHJvcHMkaW5pdGlhbEluZGV4ID09PSB1bmRlZmluZWQgPyAwIDogX3Byb3BzJGluaXRpYWxJbmRleCxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4LCAwLCBpbml0aWFsRW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBjcmVhdGVQYXRoO1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN0YXRpY1JvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBjcmVhdGVQYXRoLCBwYXJzZVBhdGggfSBmcm9tICdoaXN0b3J5L1BhdGhVdGlscyc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxudmFyIG5vcm1hbGl6ZUxvY2F0aW9uID0gZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24ob2JqZWN0KSB7XG4gIHZhciBfb2JqZWN0JHBhdGhuYW1lID0gb2JqZWN0LnBhdGhuYW1lLFxuICAgICAgcGF0aG5hbWUgPSBfb2JqZWN0JHBhdGhuYW1lID09PSB1bmRlZmluZWQgPyAnLycgOiBfb2JqZWN0JHBhdGhuYW1lLFxuICAgICAgX29iamVjdCRzZWFyY2ggPSBvYmplY3Quc2VhcmNoLFxuICAgICAgc2VhcmNoID0gX29iamVjdCRzZWFyY2ggPT09IHVuZGVmaW5lZCA/ICcnIDogX29iamVjdCRzZWFyY2gsXG4gICAgICBfb2JqZWN0JGhhc2ggPSBvYmplY3QuaGFzaCxcbiAgICAgIGhhc2ggPSBfb2JqZWN0JGhhc2ggPT09IHVuZGVmaW5lZCA/ICcnIDogX29iamVjdCRoYXNoO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxudmFyIGFkZEJhc2VuYW1lID0gZnVuY3Rpb24gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSkgKyBsb2NhdGlvbi5wYXRobmFtZVxuICB9KTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHZhciBiYXNlID0gYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKTtcblxuICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlKSAhPT0gMCkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyKGJhc2UubGVuZ3RoKVxuICB9KTtcbn07XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKGxvY2F0aW9uKSA6IG5vcm1hbGl6ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbn07XG5cbnZhciBjcmVhdGVVUkwgPSBmdW5jdGlvbiBjcmVhdGVVUkwobG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyBsb2NhdGlvbiA6IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xufTtcblxudmFyIHN0YXRpY0hhbmRsZXIgPSBmdW5jdGlvbiBzdGF0aWNIYW5kbGVyKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdZb3UgY2Fubm90ICVzIHdpdGggPFN0YXRpY1JvdXRlcj4nLCBtZXRob2ROYW1lKTtcbiAgfTtcbn07XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgdG9wLWxldmVsIEFQSSBmb3IgYSBcInN0YXRpY1wiIDxSb3V0ZXI+LCBzby1jYWxsZWQgYmVjYXVzZSBpdFxuICogY2FuJ3QgYWN0dWFsbHkgY2hhbmdlIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBJbnN0ZWFkLCBpdCBqdXN0IHJlY29yZHNcbiAqIGxvY2F0aW9uIGNoYW5nZXMgaW4gYSBjb250ZXh0IG9iamVjdC4gVXNlZnVsIG1haW5seSBpbiB0ZXN0aW5nIGFuZFxuICogc2VydmVyLXJlbmRlcmluZyBzY2VuYXJpb3MuXG4gKi9cblxudmFyIFN0YXRpY1JvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdGF0aWNSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YXRpY1JvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRpY1JvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1NsYXNoKF90aGlzLnByb3BzLmJhc2VuYW1lICsgY3JlYXRlVVJMKHBhdGgpKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVQdXNoID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wcy5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9ICdQVVNIJztcbiAgICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICAgIH0sIF90aGlzLmhhbmRsZVJlcGxhY2UgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzMi5iYXNlbmFtZSxcbiAgICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMyLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlTGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RoaXMuaGFuZGxlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IHtcbiAgICAgICAgc3RhdGljQ29udGV4dDogdGhpcy5wcm9wcy5jb250ZXh0XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8U3RhdGljUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IFN0YXRpY1JvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGJhc2VuYW1lID0gX3Byb3BzLmJhc2VuYW1lLFxuICAgICAgICBjb250ZXh0ID0gX3Byb3BzLmNvbnRleHQsXG4gICAgICAgIGxvY2F0aW9uID0gX3Byb3BzLmxvY2F0aW9uLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnYmFzZW5hbWUnLCAnY29udGV4dCcsICdsb2NhdGlvbiddKTtcblxuICAgIHZhciBoaXN0b3J5ID0ge1xuICAgICAgY3JlYXRlSHJlZjogdGhpcy5jcmVhdGVIcmVmLFxuICAgICAgYWN0aW9uOiAnUE9QJyxcbiAgICAgIGxvY2F0aW9uOiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpLFxuICAgICAgcHVzaDogdGhpcy5oYW5kbGVQdXNoLFxuICAgICAgcmVwbGFjZTogdGhpcy5oYW5kbGVSZXBsYWNlLFxuICAgICAgZ286IHN0YXRpY0hhbmRsZXIoJ2dvJyksXG4gICAgICBnb0JhY2s6IHN0YXRpY0hhbmRsZXIoJ2dvQmFjaycpLFxuICAgICAgZ29Gb3J3YXJkOiBzdGF0aWNIYW5kbGVyKCdnb0ZvcndhcmQnKSxcbiAgICAgIGxpc3RlbjogdGhpcy5oYW5kbGVMaXN0ZW4sXG4gICAgICBibG9jazogdGhpcy5oYW5kbGVCbG9ja1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBoaXN0b3J5OiBoaXN0b3J5IH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGljUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5TdGF0aWNSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29udGV4dDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG59O1xuU3RhdGljUm91dGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgYmFzZW5hbWU6ICcnLFxuICBsb2NhdGlvbjogJy8nXG59O1xuU3RhdGljUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTdGF0aWNSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN3aXRjaCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3dpdGNoJztcblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN3aXRjaCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxTd2l0Y2g+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuICB9O1xuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcblxuICAgIHZhciBtYXRjaCA9IHZvaWQgMCxcbiAgICAgICAgY2hpbGQgPSB2b2lkIDA7XG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHJldHVybjtcblxuICAgICAgdmFyIF9lbGVtZW50JHByb3BzID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICBwYXRoUHJvcCA9IF9lbGVtZW50JHByb3BzLnBhdGgsXG4gICAgICAgICAgZXhhY3QgPSBfZWxlbWVudCRwcm9wcy5leGFjdCxcbiAgICAgICAgICBzdHJpY3QgPSBfZWxlbWVudCRwcm9wcy5zdHJpY3QsXG4gICAgICAgICAgc2Vuc2l0aXZlID0gX2VsZW1lbnQkcHJvcHMuc2Vuc2l0aXZlLFxuICAgICAgICAgIGZyb20gPSBfZWxlbWVudCRwcm9wcy5mcm9tO1xuXG4gICAgICB2YXIgcGF0aCA9IHBhdGhQcm9wIHx8IGZyb207XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gZWxlbWVudDtcbiAgICAgICAgbWF0Y2ggPSBwYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIGV4YWN0OiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pIDogcm91dGUubWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgbG9jYXRpb246IGxvY2F0aW9uLCBjb21wdXRlZE1hdGNoOiBtYXRjaCB9KSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3dpdGNoLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblN3aXRjaC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAncmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aCc7XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IHdpdGhSb3V0ZXIgZnJvbSAncmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL3dpdGhSb3V0ZXIuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cbnZhciB3aXRoUm91dGVyID0gZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgWyd3cmFwcGVkQ29tcG9uZW50UmVmJ10pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHsgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocm91dGVDb21wb25lbnRQcm9wcykge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZW1haW5pbmdQcm9wcywgcm91dGVDb21wb25lbnRQcm9wcywgeyByZWY6IHdyYXBwZWRDb21wb25lbnRSZWYgfSkpO1xuICAgICAgfSB9KTtcbiAgfTtcblxuICBDLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgJyknO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gIEMucHJvcFR5cGVzID0ge1xuICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5mdW5jXG4gIH07XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXldICYmICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbi8vaW1wb3J0ZWQgdGhlIHJlYWN0LXJvdXRlclxuLypcblx0Tm8gbW9yZSBiYWNrZW5kIHJvdXRlcyB0byBjb25uZWN0IHRvIHlvdXIgZnJvbnQgZW5kIGZpbGVzXG5cdEFsbCBmcm9udCBlbmQgcm91dGVzIGFyZSBub3cgZG9uZSBzdHJpY3RseSBvbiB0aGUgZnJvbnQgZW5kLCB0aHJvdWdoIHJlYWN0XG4qL1xuaW1wb3J0IHsgU3dpdGNoLCBSb3V0ZSB9IGZyb20gXCJyZWFjdC1yb3V0ZXItZG9tXCI7XG5cbmltcG9ydCBIb21lIGZyb20gXCIuL2NvbXBvbmVudHMvSG9tZVwiO1xuXG4vKlxuXHR0aGlzIGlzIHdoZXJlIHlvdXIgcm91dGVzIGFyZSBzZXR1cFxuXHR0aGV5IGFyZSBpbXBvcnRlZCBpbnRvIHRoZSBhcHAuanMgZmlsZVxuKi9cbmV4cG9ydCBkZWZhdWx0IChcbiAgXHQ8U3dpdGNoPlxuICAgIFx0PFJvdXRlIGV4YWN0IHBhdGg9XCIvXCIgY29tcG9uZW50PXtIb21lfSAvPlxuICAgIDwvU3dpdGNoPlxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9yb3V0ZXMuanMiLCIvLyBUaGlzIGlzIHRoZSBub24tYmFiZWwgd2F5IHRvIGltcG9ydFxuLy8gdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vLyBUaGlzIGlzIHRoZSBiYWJlbCB3YXlcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuXG4vLyBmZXRjaCBkb2VzIG5vdCB3b3JrIGZvciBhcGkgY2FsbHMgaW4gcmVhY3Rcbi8vIGF4aW9zIGRvZXNcbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9AdGhlamFzb25maWxlL2ZldGNoLXZzLWF4aW9zLWpzLWZvci1tYWtpbmctaHR0cC1yZXF1ZXN0cy0yYjI2MWNkZDNhZjVcbmltcG9ydCBvbWRiX2FwaSBmcm9tICcuLy4uL2FwaS9vbWRiX2FwaSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhvbWUgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdGl0bGU6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgc2VhcmNoTW92aWVzKCkge1xuICAgIGlmKHRoaXMucmVmcy5tb3ZpZVNlYXJjaGVyLnZhbHVlLmxlbmd0aCA+IDMpe1xuICAgICAgb21kYl9hcGkodGhpcy5yZWZzLm1vdmllU2VhcmNoZXIudmFsdWUuc3BsaXQoXCIgXCIpLmpvaW4oXCIrXCIpLnRvTG93ZXJDYXNlKCkpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhyZXMpXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHRpdGxlOiByZXMuZGF0YVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cblxuXG4gIC8vIHRvIHNlZSB5b3VyIGRhdGEgYmVmb3JlIHJlbmRlci4uLnlvdSBuZWVkIHRvIHdyYXAgeW91ciByZXF1ZXN0IGluIGEgY29tcG9uZW50V2lsbE1vdW50KCkgZnVuY3Rpb25cbiAgLy8gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAvLyAgIGxldCBhcGlfa2V5ID0gJzFhMThkZGIzJ1xuICAvLyAgIC8vIGxldCBhcGlfdXJsID0gYGh0dHA6Ly93d3cub21kYmFwaS5jb20vP2FwaWtleT0ke2FwaV9rZXl9JnQ9JHttb3ZpZX1gXG4gIC8vICAgbGV0IGFwaV91cmwgPSBgaHR0cDovL3d3dy5vbWRiYXBpLmNvbS8/YXBpa2V5PSR7YXBpX2tleX0mdGBcbiAgLy9cbiAgLy8gICBheGlvcy5nZXQoYXBpX3VybCwge1xuICAvLyAgICAgaGVhZGVyczoge1xuICAvLyAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAvLyAgICAgICAnYWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gIC8vICAgICB9XG4gIC8vICAgfSkudGhlbigocmVzdWx0cykgPT4ge1xuICAvLyAgICAgY29uc29sZS5sb2cocmVzdWx0cylcbiAgLy8gICAgIHRoaXMuc2V0U3RhdGUoe1xuICAvLyAgICAgICB0aXRsZTogcmVzdWx0cy5kYXRhXG4gIC8vICAgICB9KVxuICAvLyAgICAgdGhpcy5yZWZzLm1vdmllU2VhcmNoZXIudmFsdWUgPSBcIlwiO1xuICAvLyAgIH0pO1xuICAvLyB9XG5cbiAgcmVuZGVyKCkge1xuICAgICAgY29uc29sZS5sb2codGhpcy5zdGF0ZS50aXRsZSlcbiAgICAgIGNvbnN0IGRpc3BsYXlNb3ZpZVNlYXJjaCA9ICgpID0+IHtcbiAgICAgICAgaWYodGhpcy5zdGF0ZS50aXRsZSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vdmllLXNlYXJjaC1tb3ZpZVwiPlxuICAgICAgICAgICAgICB7Lyogd3JhcCB0aGlzIGltZyB0YWcgaW4gYW4gYXRhZy4uLmFkZCB0aGUgYWNjb3JkaW5nIHJlZGlyZWN0IHRhcmdldDogYmxhbmsuLi4gKi99XG4gICAgICAgICAgICAgIHsvKiByZW1lbWJlciB0byBhZGQgaHR0cHM6Ly8gdG8gdGhlIHVybCBvciB0aGUgbGluayB3aWxsIG5vdCByZWRpcmVjdCAqL31cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb3ZpZS1wb3N0ZXItZGl2XCI+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj17XCJodHRwczovL3d3dy5pbWRiLmNvbS90aXRsZS9cIiArIHRoaXMuc3RhdGUudGl0bGUuaW1kYklEfSB0YXJnZXQ9XCJfYmxhbmtcIj48aW1nIGNsYXNzTmFtZT1cIm1vdmllLXBvc3RlclwiIGFsaWduPVwiY2VudGVyXCIgc3JjPXt0aGlzLnN0YXRlLnRpdGxlLlBvc3Rlcn0vPjxwIGNsYXNzTmFtZT1cImltZGItcGFnZS1saW5rLXRhZ1wiIGFsaWduPVwiY2VudGVyXCI+e3RoaXMuc3RhdGUudGl0bGUuVGl0bGV9PC9wPjwvYT5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW92aWUtc2VhcmNoLWluZm9cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vdmllLXRpdGxlXCI+PHNwYW4+VGl0bGU6IDwvc3Bhbj48c3BhbiBzdHlsZT17e2NvbG9yOiBcInNsYXRlZ3JheVwifX0+e3RoaXMuc3RhdGUudGl0bGUuVGl0bGV9PC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW92aWUteWVhclwiPjxzcGFuPlllYXI6IDwvc3Bhbj48c3BhbiBzdHlsZT17e2NvbG9yOiBcInNsYXRlZ3JheVwifX0+e3RoaXMuc3RhdGUudGl0bGUuWWVhcn08L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb3ZpZS1wbG90XCI+PHNwYW4+UGxvdDogPC9zcGFuPjxzcGFuIHN0eWxlPXt7Y29sb3I6IFwic2xhdGVncmF5XCJ9fT57dGhpcy5zdGF0ZS50aXRsZS5QbG90fTwvc3Bhbj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vdmllLWRpcmVjdG9yXCI+PHNwYW4+RGlyZWN0b3I6IDwvc3Bhbj48c3BhbiBzdHlsZT17e2NvbG9yOiBcInNsYXRlZ3JheVwifX0+e3RoaXMuc3RhdGUudGl0bGUuRGlyZWN0b3J9PC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW92aWUtYWN0b3JzXCI+PHNwYW4+QWN0b3JzOiA8L3NwYW4+PHNwYW4gc3R5bGU9e3tjb2xvcjogXCJzbGF0ZWdyYXlcIn19Pnt0aGlzLnN0YXRlLnRpdGxlLkFjdG9yc308L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb3ZpZS1nZW5yZVwiPjxzcGFuPkdlbnJlOiA8L3NwYW4+PHNwYW4gc3R5bGU9e3tjb2xvcjogXCJzbGF0ZWdyYXlcIn19Pnt0aGlzLnN0YXRlLnRpdGxlLkdlbnJlfTwvc3Bhbj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vdmllLWF3YXJkc1wiPjxzcGFuPkF3YXJkczogPC9zcGFuPjxzcGFuIHN0eWxlPXt7Y29sb3I6IFwic2xhdGVncmF5XCJ9fT57dGhpcy5zdGF0ZS50aXRsZS5Bd2FyZHN9PC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW92aWUtYnVkZ2V0XCI+PHNwYW4+Qm94IE9mZmljZTogPC9zcGFuPjxzcGFuIHN0eWxlPXt7Y29sb3I6IFwic2xhdGVncmF5XCJ9fT57dGhpcy5zdGF0ZS50aXRsZS5Cb3hPZmZpY2V9PC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW92aWUtcmF0ZWRcIj48c3Bhbj5SYXRlZDogPC9zcGFuPjxzcGFuIHN0eWxlPXt7Y29sb3I6IFwic2xhdGVncmF5XCJ9fT57dGhpcy5zdGF0ZS50aXRsZS5SYXRlZH08L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJtb3ZpZS1oZWFkZXJcIj5SZWFjdCBNb3ZpZSBTZWFyY2hlcjwvaDM+XG4gICAgICAgICAgPGZvcm0+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1vdmllLWlucHV0XCJcbiAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgIHJlZj1cIm1vdmllU2VhcmNoZXJcIlxuICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJUeXBlIEEgTW92aWUgVGl0bGUgSGVyZVwiXG4gICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5zZWFyY2hNb3ZpZXMuYmluZCh0aGlzKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgIDxicj48L2JyPlxuICAgICAgICAgIHtkaXNwbGF5TW92aWVTZWFyY2goKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvY29tcG9uZW50cy9Ib21lLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKHV0aWxzLm1lcmdlKGRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHRoaXMuZGVmYXVsdHMsIHsgbWV0aG9kOiAnZ2V0JyB9LCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIC8vIE5vdGU6IHN0YXR1cyBpcyBub3QgZXhwb3NlZCBieSBYRG9tYWluUmVxdWVzdFxuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgcmV0dXJuIGVycm9yO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBidG9hIHBvbHlmaWxsIGZvciBJRTwxMCBjb3VydGVzeSBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRjaGFtYmVycy9CYXNlNjQuanNcblxudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuZnVuY3Rpb24gRSgpIHtcbiAgdGhpcy5tZXNzYWdlID0gJ1N0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3Rlcic7XG59XG5FLnByb3RvdHlwZSA9IG5ldyBFcnJvcjtcbkUucHJvdG90eXBlLmNvZGUgPSA1O1xuRS5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG5mdW5jdGlvbiBidG9hKGlucHV0KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcoaW5wdXQpO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIGZvciAoXG4gICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICB2YXIgYmxvY2ssIGNoYXJDb2RlLCBpZHggPSAwLCBtYXAgPSBjaGFycztcbiAgICAvLyBpZiB0aGUgbmV4dCBzdHIgaW5kZXggZG9lcyBub3QgZXhpc3Q6XG4gICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAvLyAgIGNoZWNrIGlmIGQgaGFzIG5vIGZyYWN0aW9uYWwgZGlnaXRzXG4gICAgc3RyLmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAvLyBcIjggLSBpZHggJSAxICogOFwiIGdlbmVyYXRlcyB0aGUgc2VxdWVuY2UgMiwgNCwgNiwgOFxuICAgIG91dHB1dCArPSBtYXAuY2hhckF0KDYzICYgYmxvY2sgPj4gOCAtIGlkeCAlIDEgKiA4KVxuICApIHtcbiAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGlkeCArPSAzIC8gNCk7XG4gICAgaWYgKGNoYXJDb2RlID4gMHhGRikge1xuICAgICAgdGhyb3cgbmV3IEUoKTtcbiAgICB9XG4gICAgYmxvY2sgPSBibG9jayA8PCA4IHwgY2hhckNvZGU7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidG9hO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J0b2EuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIFN1cHBvcnQgYmFzZVVSTCBjb25maWdcbiAgaWYgKGNvbmZpZy5iYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKGNvbmZpZy51cmwpKSB7XG4gICAgY29uZmlnLnVybCA9IGNvbWJpbmVVUkxzKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnMgfHwge31cbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChtb3ZpZSkgPT4ge1xuICBsZXQgYXBpX2tleSA9ICcxYTE4ZGRiMydcbiAgbGV0IGFwaV91cmwgPSBgaHR0cDovL3d3dy5vbWRiYXBpLmNvbS8/YXBpa2V5PSR7YXBpX2tleX0mdD0ke21vdmllfWBcbiAgcmV0dXJuIGF4aW9zLmdldChhcGlfdXJsLCB7XG5cdGhlYWRlcnM6IHtcblx0XHQnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuXHRcdCdhY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcblx0fVxuICB9KS50aGVuKChyZXN1bHRzKSA9PiB7XG4gIFx0cmV0dXJuIHJlc3VsdHNcbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvYXBpL29tZGJfYXBpLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==